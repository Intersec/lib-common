/***************************************************************************/
/*                                                                         */
/* Copyright 2025 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include <netdb.h>
#include <lib-common/el.h>
#include <lib-common/net.h>
#include <lib-common/thr.h>
#include <lib-common/z.h>

/* {{{ net_addr */

static struct {
    bool fail;
    lstr_t fail_reason;
    int remaining_calls;

    data_t priv;

    sockunion_t ipv4;
    sockunion_t ipv6;
} zchk_net_g = {
#define _G zchk_net_g
    .fail_reason = LSTR_EMPTY,
};

static int zchk_wait_dns_completion(int timeout_ms, bool expect_failure)
{
    const int wait_step_value_ms = 100;

    Z_ASSERT(timeout_ms > 0, "invalid timeout provided");
    while (timeout_ms > 0) {
        el_loop_timeout(wait_step_value_ms);
        if (_G.fail && !expect_failure) {
            if (!_G.fail_reason.len) {
                _G.fail_reason = LSTR("unknown");
            }
            Z_ASSERT(false, "dns resolution failure: %pL", &_G.fail_reason);
        } else if (_G.remaining_calls == 0) {
            return 0;
        }
        timeout_ms -= wait_step_value_ms;
    }

    Z_ASSERT(false, "dns timeout");
    Z_HELPER_END;
}

static int
zchk_net_addr_parse_url_no_https(const char *addr, const char *user,
                                 const char *pass, const char *host, int port,
                                 const char *path, const char *args,
                                 const char *path_no_args)
{
    http_url_t url;

    Z_ASSERT_N(parse_http_url(addr, false, &url));

    Z_ASSERT_STREQUAL(url.user, user);
    Z_ASSERT_STREQUAL(url.pass, pass);
    Z_ASSERT_STREQUAL(url.host, host);
    Z_ASSERT(url.port == port);
    Z_ASSERT_STREQUAL(url.path, path);
    Z_ASSERT_STREQUAL(url.args, args);
    Z_ASSERT_STREQUAL(url.path_without_args, path_no_args);

    Z_HELPER_END;
}

static inline void zchk_end_resolved_addr_test(void)
{
    lstr_wipe(&_G.fail_reason);
}

/* Reset context with the expected number of calls to trigger */
static inline void zchk_start_resolved_addr_test(int nbr_addr_calls)
{
    zchk_end_resolved_addr_test();

    p_clear(&_G, 1);
    _G.remaining_calls = nbr_addr_calls;
}

/* Update context based on callback call triggered at the end of address
 * resolution. For convenience, both "standard" and block callbacks point to
 * this function. */
static void
zchk_update_test_on_callback_call(const struct dns_resolv_res_t * nonnull res,
                                  data_t priv)
{
    _G.fail |= _G.remaining_calls <= 0 || res->err.len;
    _G.remaining_calls--;

    if (res->err.len) {
        lstr_dup(LSTR_SB_V(&res->err));
        return;
    }

    _G.priv = priv;
    if (res->su.family == AF_INET) {
        _G.ipv4 = res->su;
    } else if (res->su.family == AF_INET6) {
        _G.ipv6 = res->su;
    }
}

/* XXX: the Z_GROUP_EXPORT() macro generates the following warning if we don't
 * have a dedicated function to manage blocks (except for asan compilation),
 * leading to a compilation error afterwards:
 *    warning: rewriting sub-expression within a macro (may not be correct)
 * As a consequence, create this wrap function to avoid the issue.
 */
static dns_resolv_ctx_t *
zchk_call_addr_info_async_b(sa_family_t af, lstr_t host, in_port_t port)
{
    return addr_info_async_b(af, host, port,
                             ^(const struct dns_resolv_res_t * nonnull res) {
        zchk_update_test_on_callback_call(res, DATA_PTR(NULL));
    });
}

static dns_resolv_ctx_t *
zchk_call_addr_resolve_async_b(lstr_t addr, in_port_t port,
                               sb_t * nonnull err)
{
    return addr_resolve_async_b("test addr", addr, 1, port,
                                ^(const struct dns_resolv_res_t * nonnull res)
    {
        zchk_update_test_on_callback_call(res, DATA_PTR(NULL));
    }, err);
}

/* Resolve host address and check the result against the ipv4 and ipv6
 * provided. */
static int
zchk_check_resolved_addr(bool any_family, const lstr_t host,
                         const in_port_t port, sockunion_t *const ipv4,
                         sockunion_t *const ipv6)
{
    t_scope;
    const struct addrinfo hint = {
        .ai_family   = AF_UNSPEC,
        .ai_socktype = SOCK_STREAM,
    };
    struct addrinfo *res, *p;
    bool ipv4_found = false;
    bool ipv6_found = false;

    THROW_ERR_IF(getaddrinfo(host.s, t_fmt("%d", port), &hint, &res) != 0);

    /* We have to check the following DNS resolution based on the fact
     * that ipv4/ipv6 values from host parameter can provide several
     * results. As a consequence, we have to iterate into the full list to
     * guarantee that IP retrieved is correct. */
    for (p = res; p != NULL; p = p->ai_next) {
        if (p->ai_family == AF_INET && ipv4) {
            ipv4_found |= !memcmp(&ipv4->sin, p->ai_addr, p->ai_addrlen);
        } else if (p->ai_family == AF_INET6 && ipv6) {
            ipv6_found |= !memcmp(&ipv6->sin6, p->ai_addr, p->ai_addrlen);
        } else {
            continue;
        }
    }
    freeaddrinfo(res);

    if (any_family) {
        /* Only one address resolution is fine, but we don't know in advance
         * which one. */
        Z_ASSERT(ipv4_found || ipv6_found, "addrinfo mismatched / not found");
    } else {
        if (ipv4) {
            Z_ASSERT(ipv4_found, "addrinfo on IPv4 mismatched / not found");
        }
        if (ipv6) {
            Z_ASSERT(ipv6_found, "addrinfo on IPv6 mismatched / not found");
        }
    }
    Z_HELPER_END;
}

Z_GROUP_EXPORT(net_addr)
{
    t_scope;
#define NET_ADDR_IPV4        "1.1.1.1"
#define NET_ADDR_IPV6        "1:1:1:1:1:1:1:1"
#define NET_ADDR_PORT        4242
#define NET_ADDR_DNS_LOCAL   "localhost"
#define NET_ADDR_DNS_EXTERNE "www.intersec.com"

    lstr_t ipv4 = LSTR(NET_ADDR_IPV4);
    lstr_t ipv6 = LSTR(NET_ADDR_IPV6);
    lstr_t local_addr = LSTR(NET_ADDR_DNS_LOCAL);
    lstr_t remote_addr = LSTR(NET_ADDR_DNS_EXTERNE);
    lstr_t tcp_ipv4 = LSTR(NET_ADDR_IPV4 ":" TOSTR(NET_ADDR_PORT));
    lstr_t tcp_ipv6 = LSTR("[" NET_ADDR_IPV6 "]:" TOSTR(NET_ADDR_PORT));

#define CHECK_FILTER(_res, _cidr, _addr, _mask)                              \
    do {                                                                     \
        Z_ASSERT_N(addr_filter_build(LSTR(_cidr), &filter));                 \
        Z_ASSERT_EQ((_res), addr_filter_matches(&filter, &su));              \
                                                                             \
        if (filter.family == AF_INET) {                                      \
            inet_ntop(AF_INET, &filter.u.v4.addr, buf, sizeof(buf));         \
            Z_ASSERT_LSTREQUAL(LSTR(buf), LSTR(_addr));                      \
            inet_ntop(AF_INET, &filter.u.v4.mask, buf, sizeof(buf));         \
            Z_ASSERT_LSTREQUAL(LSTR(buf), LSTR(_mask));                      \
        } else {                                                             \
            inet_ntop(AF_INET6, &filter.u.v6.addr, buf, sizeof(buf));        \
            Z_ASSERT_LSTREQUAL(LSTR(buf), LSTR(_addr));                      \
            inet_ntop(AF_INET6, &filter.u.v6.mask, buf, sizeof(buf));        \
            Z_ASSERT_LSTREQUAL(LSTR(buf), LSTR(_mask));                      \
        }                                                                    \
    } while (0)

    Z_TEST(ipv4, "IPv4") {
        sockunion_t su;
        addr_filter_t filter;
        char buf[INET6_ADDRSTRLEN];

        Z_ASSERT_N(addr_info(&su, AF_INET, ps_initlstr(&ipv4),
                             NET_ADDR_PORT));
        Z_ASSERT_LSTREQUAL(ipv4, t_sockunion_gethost_lstr(&su));
        Z_ASSERT_EQ(NET_ADDR_PORT, sockunion_getport(&su));
        Z_ASSERT_LSTREQUAL(t_addr_fmt_lstr(&su), tcp_ipv4);

        CHECK_FILTER(0, "1.1.1.2/25", "1.1.1.0", "255.255.255.128");
        CHECK_FILTER(-1, "1.1.1.130/25", "1.1.1.128", "255.255.255.128");
        CHECK_FILTER(-1, "192.168.0.1/16", "192.168.0.0", "255.255.0.0");
        CHECK_FILTER(-1, "1.1.1.3/32", "1.1.1.3", "255.255.255.255");
        CHECK_FILTER(0, "2.2.2.2/0", "0.0.0.0", "0.0.0.0");
        CHECK_FILTER(0, "1.1.1.1", "1.1.1.1", "255.255.255.255");
        CHECK_FILTER(-1, "1.1.1.4", "1.1.1.4", "255.255.255.255");

    } Z_TEST_END;

    Z_TEST(ipv6, "IPv6") {
        sockunion_t su;
        addr_filter_t filter;
        char buf[INET6_ADDRSTRLEN];

        Z_ASSERT_N(addr_info(&su, AF_INET6, ps_initlstr(&ipv6),
                             NET_ADDR_PORT));
        Z_ASSERT_LSTREQUAL(ipv6, t_sockunion_gethost_lstr(&su));
        Z_ASSERT_EQ(NET_ADDR_PORT, sockunion_getport(&su));
        Z_ASSERT_LSTREQUAL(t_addr_fmt_lstr(&su), tcp_ipv6);

        CHECK_FILTER(0, "1:1:1:1:1:1:1:2/65", "1:1:1:1::",
                     "ffff:ffff:ffff:ffff:8000::");
        CHECK_FILTER(-1, "1:1:1:1:abcd:1:1:2/65", "1:1:1:1:8000::",
                     "ffff:ffff:ffff:ffff:8000::");
        CHECK_FILTER(-1, "fe80::202:b3ff:fe1e:8329/32",
                     "fe80::", "ffff:ffff::");
        CHECK_FILTER(-1, "1:1:1:1:1:1:1:3/128", "1:1:1:1:1:1:1:3",
                     "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff");
        CHECK_FILTER(0, "2:2:2:2:2:2:2:2/0", "::", "::");
        CHECK_FILTER(0, "1:1:1:1:1:1:1:1", "1:1:1:1:1:1:1:1",
                     "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff");
        CHECK_FILTER(-1, "1:1:1:1:1:1:1:3", "1:1:1:1:1:1:1:3",
                     "ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff");
    } Z_TEST_END;

    Z_TEST(local_addr_resolution, "local_addr_resolution") {
        SB_1k(err);
        MODULE_REQUIRE(thr);

        /* Use the async mechanism to run DNS resolution in parallel.
         * 1. Direct API using a classic C callback. */
        zchk_start_resolved_addr_test(1);
        Z_ASSERT_P(addr_info_async(AF_INET, local_addr, NET_ADDR_PORT,
                                   &zchk_update_test_on_callback_call,
                                   DATA_U64(42)));
        Z_HELPER_RUN(zchk_wait_dns_completion(1000, false));
        Z_HELPER_RUN(zchk_check_resolved_addr(
            false, local_addr, NET_ADDR_PORT, &_G.ipv4, NULL));
        Z_ASSERT_EQ(42U, _G.priv.u64, "private data check failed");

        /* 2. Direct API using a block callback. */
        zchk_start_resolved_addr_test(1);

        Z_ASSERT_P(zchk_call_addr_info_async_b(AF_INET, local_addr,
                                               NET_ADDR_PORT));
        Z_HELPER_RUN(zchk_wait_dns_completion(1000, false));
        Z_HELPER_RUN(zchk_check_resolved_addr(
            false, local_addr, NET_ADDR_PORT, &_G.ipv4, NULL));

        /* 3. Resolve addr API with port generation. */
        zchk_start_resolved_addr_test(1);
        Z_ASSERT_P(zchk_call_addr_resolve_async_b(
            local_addr, NET_ADDR_PORT, &err), "%*pL", SB_FMT_ARG(&err));
        Z_HELPER_RUN(zchk_wait_dns_completion(1000, false));
        Z_HELPER_RUN(zchk_check_resolved_addr(
            true, local_addr, NET_ADDR_PORT, &_G.ipv4, &_G.ipv6));

        zchk_end_resolved_addr_test();
        MODULE_RELEASE(thr);
    } Z_TEST_END;

    Z_TEST(remote_addr_resolution, "remote_addr_resolution") {
        Z_TEST_FLAGS("slow");
        MODULE_REQUIRE(thr);

        /* 1. direct API using a block callback. */
        zchk_start_resolved_addr_test(2);
        zchk_call_addr_info_async_b(AF_INET, remote_addr, NET_ADDR_PORT);
        zchk_call_addr_info_async_b(AF_INET6, remote_addr, NET_ADDR_PORT);
        Z_HELPER_RUN(zchk_wait_dns_completion(10000, false));
        Z_HELPER_RUN(zchk_check_resolved_addr(
            false, remote_addr, NET_ADDR_PORT, &_G.ipv4, &_G.ipv6));

        zchk_end_resolved_addr_test();
        MODULE_RELEASE(thr);
    } Z_TEST_END;

    Z_TEST(sockunion_for_each, "sockunion_for_each") {
        lstr_t ip = LSTR("127.0.0.1:1337");
        SB_1k(sus_buf);
        int idx = 0;
        sockunion_t su;

        addr_resolve("IPv4", tcp_ipv4, &su);
        sb_add(&sus_buf, &su, sockunion_len(&su));
        addr_resolve("IPv6", tcp_ipv6, &su);
        sb_add(&sus_buf, &su, sockunion_len(&su));
        addr_resolve("IP", ip, &su);
        sb_add(&sus_buf, &su, sockunion_len(&su));

        sockunion_for_each(sock, (sockunion_t *)sus_buf.data, 3) {
            switch (idx) {
              case 0:
                Z_ASSERT_LSTREQUAL(t_addr_fmt_lstr(sock), tcp_ipv4);
                break;
              case 1:
                Z_ASSERT_LSTREQUAL(t_addr_fmt_lstr(sock), tcp_ipv6);
                break;
              case 2:
                Z_ASSERT_LSTREQUAL(t_addr_fmt_lstr(sock), ip);
                break;
              default:
                Z_ASSERT(false);
                break;
            }
            idx++;
        }
        Z_ASSERT_EQ(idx, 3);
    } Z_TEST_END;

#undef CHECK_FILTER
#undef NET_ADDR_PORT
#undef NET_ADDR_IPV6
#undef NET_ADDR_IPV4



    Z_TEST(parse_http_url, "parse_http_url")
    {
        http_url_t url;

#define T_VALID(_addr, _user, _pass, _host, _port, _path, _args,             \
                _path_no_args)                                               \
    Z_HELPER_RUN(zchk_net_addr_parse_url_no_https(                           \
        _addr, _user, _pass, _host, _port, _path, _args, _path_no_args))

        T_VALID("http://host.com/test", "", "", "host.com", 80, "/test", "",
                "/test");
        T_VALID("http://host.com/test@test", "", "", "host.com", 80,
                "/test@test", "", "/test@test");
        T_VALID("http://localhost", "", "", "localhost", 80, "/", "", "/");
        T_VALID("http://host.com", "", "", "host.com", 80, "/", "", "/");
        T_VALID("http://host.com:8080", "", "", "host.com", 8080,
                "/", "", "/");
        T_VALID("http://user:pass@host.com/", "user", "pass", "host.com", 80,
                "/", "", "/");
        T_VALID("http://host.com/test?args", "", "", "host.com", 80,
                "/test?args", "?args", "/test");
        T_VALID("http://user:pass@host.com:42/test?args", "user", "pass",
                "host.com", 42, "/test?args", "?args", "/test");
        T_VALID("http://user:pass@host.com:42/test@test", "user", "pass",
                "host.com", 42, "/test@test", "", "/test@test");
#undef T_VALID

#define T_INVALID(_addr)  Z_ASSERT_NEG(parse_http_url(_addr, false, &url))
        T_INVALID("toto");
        T_INVALID("http://");
        T_INVALID("http://user@host.com");
        T_INVALID("http://user@host.com:42/test?args");
        T_INVALID("user@host.com");
        T_INVALID("http://host.com:-8080");
        T_INVALID("http://host.com:");
        T_INVALID("http://host.com:/test?args");
        T_INVALID("http://:pass@host.com");
        T_INVALID("http://user:@host.com");
#undef T_INVALID

        /* HTTP port. */
        Z_ASSERT_N(parse_http_url("http://host.com", true, &url));
        Z_ASSERT_EQ(url.port, 80);

        /* HTTPS port. */
        Z_ASSERT_N(parse_http_url("https://host.com", true, &url));
        Z_ASSERT_EQ(url.port, 443);

    } Z_TEST_END;

} Z_GROUP_END;

/* }}} */
