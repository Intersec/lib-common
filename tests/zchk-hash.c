/***************************************************************************/
/*                                                                         */
/* Copyright 2020 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

/* LCOV_EXCL_START */

#include <lib-common/hash.h>
#include <lib-common/z.h>

/* {{{ hash32 */

Z_GROUP_EXPORT(hash32) {
    Z_TEST(jenkins, "jenkins") {
        lstr_t s = LSTR("hakunamatata");

        Z_ASSERT_EQ(jenkins_hash(s.s, -1), 0xb536a6ee);
        Z_ASSERT_EQ(jenkins_hash(s.s, s.len), 0xb536a6ee);
    } Z_TEST_END;

    Z_TEST(murmur_hash3_x86_32, "murmur_hash3_x86_32") {
        lstr_t s = LSTR("Est-ce que vous voulez etre ma femme ? "
                        "Et apres on boira un cafe.");

        /* XXX murmur_hash3_x86_32 is aligned on 32bits words, avoid using a
         * string that fits on 32bits words so the test is complete.
         */
        assert (s.len % 4);

        Z_ASSERT_EQ(murmur_hash3_x86_32(s.s, s.len, 0xdeadc0de), 0x7455ebb5u);
    } Z_TEST_END;

    Z_TEST(murmur_hash3_x86_32_update, "murmur_hash3_x86_32_update") {
        lstr_t s;
        byte hash[4];
        murmur_hash3_x86_32_ctx ctx;

        murmur_hash3_x86_32_starts(&ctx, 0xdeadc0de);
        s = LSTR("Est-ce que vous voulez etre ma femme ? ");
        assert (s.len % 4);
        murmur_hash3_x86_32_update(&ctx, s.s, s.len);
        s = LSTR("Et apres on boira un cafe.");
        murmur_hash3_x86_32_update(&ctx, s.s, s.len);
        murmur_hash3_x86_32_finish(&ctx, hash);

        Z_ASSERT_EQ(get_unaligned_cpu32(hash), 0x7455ebb5u);
    } Z_TEST_END;
} Z_GROUP_END;

/* }}} */
/* {{{ sha2 */

/*
 * FIPS-180-2 test vectors
 */
static byte sha2_test_buf[3][57] =
{
    { "abc" },
    { "abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq" },
    { "" }
};

static const int sha2_test_buflen[3] =
{
    3, 56, 1000
};

static const byte sha2_test_sum[6][32] =
{
    /*
     * SHA-224 test vectors
     */
    { 0x23, 0x09, 0x7D, 0x22, 0x34, 0x05, 0xD8, 0x22,
      0x86, 0x42, 0xA4, 0x77, 0xBD, 0xA2, 0x55, 0xB3,
      0x2A, 0xAD, 0xBC, 0xE4, 0xBD, 0xA0, 0xB3, 0xF7,
      0xE3, 0x6C, 0x9D, 0xA7 },
    { 0x75, 0x38, 0x8B, 0x16, 0x51, 0x27, 0x76, 0xCC,
      0x5D, 0xBA, 0x5D, 0xA1, 0xFD, 0x89, 0x01, 0x50,
      0xB0, 0xC6, 0x45, 0x5C, 0xB4, 0xF5, 0x8B, 0x19,
      0x52, 0x52, 0x25, 0x25 },
    { 0x20, 0x79, 0x46, 0x55, 0x98, 0x0C, 0x91, 0xD8,
      0xBB, 0xB4, 0xC1, 0xEA, 0x97, 0x61, 0x8A, 0x4B,
      0xF0, 0x3F, 0x42, 0x58, 0x19, 0x48, 0xB2, 0xEE,
      0x4E, 0xE7, 0xAD, 0x67 },

    /*
     * SHA-256 test vectors
     */
    { 0xBA, 0x78, 0x16, 0xBF, 0x8F, 0x01, 0xCF, 0xEA,
      0x41, 0x41, 0x40, 0xDE, 0x5D, 0xAE, 0x22, 0x23,
      0xB0, 0x03, 0x61, 0xA3, 0x96, 0x17, 0x7A, 0x9C,
      0xB4, 0x10, 0xFF, 0x61, 0xF2, 0x00, 0x15, 0xAD },
    { 0x24, 0x8D, 0x6A, 0x61, 0xD2, 0x06, 0x38, 0xB8,
      0xE5, 0xC0, 0x26, 0x93, 0x0C, 0x3E, 0x60, 0x39,
      0xA3, 0x3C, 0xE4, 0x59, 0x64, 0xFF, 0x21, 0x67,
      0xF6, 0xEC, 0xED, 0xD4, 0x19, 0xDB, 0x06, 0xC1 },
    { 0xCD, 0xC7, 0x6E, 0x5C, 0x99, 0x14, 0xFB, 0x92,
      0x81, 0xA1, 0xC7, 0xE2, 0x84, 0xD7, 0x3E, 0x67,
      0xF1, 0x80, 0x9A, 0x48, 0xA4, 0x97, 0x20, 0x0E,
      0x04, 0x6D, 0x39, 0xCC, 0xC7, 0x11, 0x2C, 0xD0 }
};

/*
 * RFC 4231 test vectors
 */
static byte sha2_hmac_test_key[7][26] =
{
    { "\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B"
      "\x0B\x0B\x0B\x0B" },
    { "Jefe" },
    { "\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"
      "\xAA\xAA\xAA\xAA" },
    { "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10"
      "\x11\x12\x13\x14\x15\x16\x17\x18\x19" },
    { "\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C"
      "\x0C\x0C\x0C\x0C" },
    { "" }, /* 0xAA 131 times */
    { "" }
};

static const int sha2_hmac_test_keylen[7] =
{
    20, 4, 20, 25, 20, 131, 131
};

static byte sha2_hmac_test_buf[7][153] =
{
    { "Hi There" },
    { "what do ya want for nothing?" },
    { "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD" },
    { "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD" },
    { "Test With Truncation" },
    { "Test Using Larger Than Block-Size Key - Hash Key First" },
    { "This is a test using a larger than block-size key "
      "and a larger than block-size data. The key needs to "
      "be hashed before being used by the HMAC algorithm." }
};

static const int sha2_hmac_test_buflen[7] =
{
    8, 28, 50, 50, 20, 54, 152
};

static const byte sha2_hmac_test_sum[14][32] =
{
    /*
     * HMAC-SHA-224 test vectors
     */
    { 0x89, 0x6F, 0xB1, 0x12, 0x8A, 0xBB, 0xDF, 0x19,
      0x68, 0x32, 0x10, 0x7C, 0xD4, 0x9D, 0xF3, 0x3F,
      0x47, 0xB4, 0xB1, 0x16, 0x99, 0x12, 0xBA, 0x4F,
      0x53, 0x68, 0x4B, 0x22 },
    { 0xA3, 0x0E, 0x01, 0x09, 0x8B, 0xC6, 0xDB, 0xBF,
      0x45, 0x69, 0x0F, 0x3A, 0x7E, 0x9E, 0x6D, 0x0F,
      0x8B, 0xBE, 0xA2, 0xA3, 0x9E, 0x61, 0x48, 0x00,
      0x8F, 0xD0, 0x5E, 0x44 },
    { 0x7F, 0xB3, 0xCB, 0x35, 0x88, 0xC6, 0xC1, 0xF6,
      0xFF, 0xA9, 0x69, 0x4D, 0x7D, 0x6A, 0xD2, 0x64,
      0x93, 0x65, 0xB0, 0xC1, 0xF6, 0x5D, 0x69, 0xD1,
      0xEC, 0x83, 0x33, 0xEA },
    { 0x6C, 0x11, 0x50, 0x68, 0x74, 0x01, 0x3C, 0xAC,
      0x6A, 0x2A, 0xBC, 0x1B, 0xB3, 0x82, 0x62, 0x7C,
      0xEC, 0x6A, 0x90, 0xD8, 0x6E, 0xFC, 0x01, 0x2D,
      0xE7, 0xAF, 0xEC, 0x5A },
    { 0x0E, 0x2A, 0xEA, 0x68, 0xA9, 0x0C, 0x8D, 0x37,
      0xC9, 0x88, 0xBC, 0xDB, 0x9F, 0xCA, 0x6F, 0xA8 },
    { 0x95, 0xE9, 0xA0, 0xDB, 0x96, 0x20, 0x95, 0xAD,
      0xAE, 0xBE, 0x9B, 0x2D, 0x6F, 0x0D, 0xBC, 0xE2,
      0xD4, 0x99, 0xF1, 0x12, 0xF2, 0xD2, 0xB7, 0x27,
      0x3F, 0xA6, 0x87, 0x0E },
    { 0x3A, 0x85, 0x41, 0x66, 0xAC, 0x5D, 0x9F, 0x02,
      0x3F, 0x54, 0xD5, 0x17, 0xD0, 0xB3, 0x9D, 0xBD,
      0x94, 0x67, 0x70, 0xDB, 0x9C, 0x2B, 0x95, 0xC9,
      0xF6, 0xF5, 0x65, 0xD1 },

    /*
     * HMAC-SHA-256 test vectors
     */
    { 0xB0, 0x34, 0x4C, 0x61, 0xD8, 0xDB, 0x38, 0x53,
      0x5C, 0xA8, 0xAF, 0xCE, 0xAF, 0x0B, 0xF1, 0x2B,
      0x88, 0x1D, 0xC2, 0x00, 0xC9, 0x83, 0x3D, 0xA7,
      0x26, 0xE9, 0x37, 0x6C, 0x2E, 0x32, 0xCF, 0xF7 },
    { 0x5B, 0xDC, 0xC1, 0x46, 0xBF, 0x60, 0x75, 0x4E,
      0x6A, 0x04, 0x24, 0x26, 0x08, 0x95, 0x75, 0xC7,
      0x5A, 0x00, 0x3F, 0x08, 0x9D, 0x27, 0x39, 0x83,
      0x9D, 0xEC, 0x58, 0xB9, 0x64, 0xEC, 0x38, 0x43 },
    { 0x77, 0x3E, 0xA9, 0x1E, 0x36, 0x80, 0x0E, 0x46,
      0x85, 0x4D, 0xB8, 0xEB, 0xD0, 0x91, 0x81, 0xA7,
      0x29, 0x59, 0x09, 0x8B, 0x3E, 0xF8, 0xC1, 0x22,
      0xD9, 0x63, 0x55, 0x14, 0xCE, 0xD5, 0x65, 0xFE },
    { 0x82, 0x55, 0x8A, 0x38, 0x9A, 0x44, 0x3C, 0x0E,
      0xA4, 0xCC, 0x81, 0x98, 0x99, 0xF2, 0x08, 0x3A,
      0x85, 0xF0, 0xFA, 0xA3, 0xE5, 0x78, 0xF8, 0x07,
      0x7A, 0x2E, 0x3F, 0xF4, 0x67, 0x29, 0x66, 0x5B },
    { 0xA3, 0xB6, 0x16, 0x74, 0x73, 0x10, 0x0E, 0xE0,
      0x6E, 0x0C, 0x79, 0x6C, 0x29, 0x55, 0x55, 0x2B },
    { 0x60, 0xE4, 0x31, 0x59, 0x1E, 0xE0, 0xB6, 0x7F,
      0x0D, 0x8A, 0x26, 0xAA, 0xCB, 0xF5, 0xB7, 0x7F,
      0x8E, 0x0B, 0xC6, 0x21, 0x37, 0x28, 0xC5, 0x14,
      0x05, 0x46, 0x04, 0x0F, 0x0E, 0xE3, 0x7F, 0x54 },
    { 0x9B, 0x09, 0xFF, 0xA7, 0x1B, 0x94, 0x2F, 0xCB,
      0x27, 0x63, 0x5F, 0xBC, 0xD5, 0xB0, 0xE9, 0x44,
      0xBF, 0xDC, 0x63, 0x64, 0x4F, 0x07, 0x13, 0x93,
      0x8A, 0x7F, 0x51, 0x53, 0x5C, 0x3A, 0x35, 0xE2 }
};

Z_GROUP_EXPORT(sha2)
{
    Z_TEST(hash, "") {
        byte buf[1024];
        byte sha2sum[32];
        sha2_ctx ctx;
        int len;

        for (int i = 0; i < 6; i++) {
            int j = i % 3;
            int k = i < 3;

            sha2_starts( &ctx, k );

            if (j == 2) {
                memset(buf, 'a', 1000);
                for (int l = 0; l < 1000; l++)
                    sha2_update(&ctx, buf, 1000);
            } else {
                sha2_update(&ctx, sha2_test_buf[j], sha2_test_buflen[j]);
            }

            sha2_finish(&ctx, sha2sum);

            if (j == 4) {
                len = 16;
            } else {
                len = 32 - k * 4;
            }
            Z_ASSERT_EQUAL(sha2sum, len, sha2_test_sum[i], len);
        }
    } Z_TEST_END;

    Z_TEST(hmac, "") {
        byte buf[1024];
        byte sha2sum[32];
        sha2_ctx ctx;
        int len;

        for (int i = 0; i < 14; i++) {
            int j = i % 7;
            int k = i < 7;

            if (j == 5 || j == 6) {
                memset( buf, '\xAA', 131);
                sha2_hmac_starts(&ctx, buf, 131, k);
            } else {
                sha2_hmac_starts(&ctx, sha2_hmac_test_key[j],
                                 sha2_hmac_test_keylen[j], k);
            }
            sha2_hmac_update(&ctx, sha2_hmac_test_buf[j],
                                    sha2_hmac_test_buflen[j]);

            sha2_hmac_finish(&ctx, sha2sum);
            if (j == 4) {
                len = 16;
            } else {
                len = 32 - k * 4;
            }
            Z_ASSERT_EQUAL(sha2sum, len, sha2_hmac_test_sum[i], len);
        }
    } Z_TEST_END;

    Z_TEST(crypt, "") {

        /* Those are extracted from Ulrich Drepper's
         * "Unix crypt using SHA-256" specifications v0.4 2008-4-3
         */
        static const struct {
            const char *input;
            const int   rounds;
            const char *salt;
            const int   expected_rounds;
            const char *expected_salt;
            const char *expected_hash;
        } tests_crypt[] =
        {
            {"Hello world!", 10000, "saltstringsaltstring", 10000,
             "saltstringsaltst",
             "3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA"},
            {"This is just a test", 5000, "toolongsaltstring",
             5000, "toolongsaltstrin",
             "Un/5jzAHMgOGZ5.mWJpuVolil07guHPvOW8mGRcvxa5"},
            {"a very much longer text to encrypt.  This one even stretche"
             "s over morethan one line.", 1400, "anotherlongsaltstring",
             1400, "anotherlongsalts",
             "Rx.j8H.h8HjEDGomFU8bDkXm3XIUnzyxf12oP84Bnq1"},
            {"we have a short salt string but not a short password", 77777,
             "short", 77777, "short",
             "JiO1O3ZpDAxGJeaDIuqCoEFysAe1mZNJRs3pw0KQRd/"},
            {"a short string", 123456, "asaltof16chars..",
             123456, "asaltof16chars..",
             "gP3VQ/6X7UUEW3HkBn2w1/Ptq2jxPyzV/cZKmF/wJvD"},
            {"the minimum number is still observed", 10, "roundstoolow",
             1000, "roundstoolow",
             "yfvwcWrQ8l/K0DAWyuPMDNHpIVlTQebY9l/gL972bIC"},
        };

        SB_1k(crypt_buf);

        for (int i = 0; i < countof(tests_crypt); ++i) {
            t_scope;
            lstr_t expected;
            int rounds;
            pstream_t salt;
            pstream_t hash;

            sha2_crypt(tests_crypt[i].input, strlen(tests_crypt[i].input),
                       tests_crypt[i].salt, strlen(tests_crypt[i].salt),
                       tests_crypt[i].rounds, &crypt_buf);

            expected = t_lstr_fmt("$5$rounds=%d$%s$%s",
                                  tests_crypt[i].expected_rounds,
                                  tests_crypt[i].expected_salt,
                                  tests_crypt[i].expected_hash);
            Z_ASSERT_LSTREQUAL(LSTR_SB_V(&crypt_buf),
                               expected);

            Z_ASSERT_N(sha2_crypt_parse(LSTR_SB_V(&crypt_buf),
                                             &rounds, &salt, &hash));
            Z_ASSERT_EQ(rounds, tests_crypt[i].expected_rounds);
            Z_ASSERT_LSTREQUAL(LSTR_PS_V(&salt),
                               LSTR(tests_crypt[i].expected_salt));
            Z_ASSERT_LSTREQUAL(LSTR_PS_V(&hash),
                               LSTR(tests_crypt[i].expected_hash));

        }

        /* Check the parse function on bad cases */

#define CHECK_FAIL(str)                \
    Z_ASSERT_NEG(sha2_crypt_parse(LSTR(str), NULL, NULL, NULL))

        /* Wrong algorithm code */
        CHECK_FAIL("$6$rounds=10000$salt"
                   "$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA");
        /* Wrong rounds format */
        CHECK_FAIL("$5$rounds=a10000$salt"
                   "$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA");
        /* Rounds count too low */
        CHECK_FAIL("$5$rounds=999$salt"
                   "$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA");
        /* Rounds count too high */
        CHECK_FAIL("$5$rounds=1000000000$salt"
                   "$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA");
        /* Wrong rounds format */
        CHECK_FAIL("$5$rounds=10000a$salt"
                   "$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA");
        /* No separator between salt and hash */
        CHECK_FAIL("$5$rounds=10000$salt"
                   "3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA");
        /* Empty salt */
        CHECK_FAIL("$5$rounds=10000$"
                   "$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA");
        /* Salt string too long */
        CHECK_FAIL("$5$rounds=10000$toolongsaltstring"
                   "$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA");
        /* Bad character in hash */
        CHECK_FAIL("$5$rounds=10000$salt"
                   "$3xv.=bSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcA");
        /* Hash too long */
        CHECK_FAIL("$5$rounds=10000$salt"
                   "$3xv.VbSHBb41AL9AvLeujZkZRBAwqFMz2.opqey6IcAa");

#undef CHECK_FAIL

    } Z_TEST_END;
} Z_GROUP_END

/* }}} */
/* {{{ sha4 */

/*
 * FIPS-180-2 test vectors
 */
static byte sha4_test_buf[3][113] =
{
    { "abc" },
    { "abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmn"
      "hijklmnoijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu" },
    { "" }
};

static const int sha4_test_buflen[3] =
{
    3, 112, 1000
};

static const byte sha4_test_sum[6][64] =
{
    /*
     * SHA-384 test vectors
     */
    { 0xCB, 0x00, 0x75, 0x3F, 0x45, 0xA3, 0x5E, 0x8B,
      0xB5, 0xA0, 0x3D, 0x69, 0x9A, 0xC6, 0x50, 0x07,
      0x27, 0x2C, 0x32, 0xAB, 0x0E, 0xDE, 0xD1, 0x63,
      0x1A, 0x8B, 0x60, 0x5A, 0x43, 0xFF, 0x5B, 0xED,
      0x80, 0x86, 0x07, 0x2B, 0xA1, 0xE7, 0xCC, 0x23,
      0x58, 0xBA, 0xEC, 0xA1, 0x34, 0xC8, 0x25, 0xA7 },
    { 0x09, 0x33, 0x0C, 0x33, 0xF7, 0x11, 0x47, 0xE8,
      0x3D, 0x19, 0x2F, 0xC7, 0x82, 0xCD, 0x1B, 0x47,
      0x53, 0x11, 0x1B, 0x17, 0x3B, 0x3B, 0x05, 0xD2,
      0x2F, 0xA0, 0x80, 0x86, 0xE3, 0xB0, 0xF7, 0x12,
      0xFC, 0xC7, 0xC7, 0x1A, 0x55, 0x7E, 0x2D, 0xB9,
      0x66, 0xC3, 0xE9, 0xFA, 0x91, 0x74, 0x60, 0x39 },
    { 0x9D, 0x0E, 0x18, 0x09, 0x71, 0x64, 0x74, 0xCB,
      0x08, 0x6E, 0x83, 0x4E, 0x31, 0x0A, 0x4A, 0x1C,
      0xED, 0x14, 0x9E, 0x9C, 0x00, 0xF2, 0x48, 0x52,
      0x79, 0x72, 0xCE, 0xC5, 0x70, 0x4C, 0x2A, 0x5B,
      0x07, 0xB8, 0xB3, 0xDC, 0x38, 0xEC, 0xC4, 0xEB,
      0xAE, 0x97, 0xDD, 0xD8, 0x7F, 0x3D, 0x89, 0x85 },

    /*
     * SHA-512 test vectors
     */
    { 0xDD, 0xAF, 0x35, 0xA1, 0x93, 0x61, 0x7A, 0xBA,
      0xCC, 0x41, 0x73, 0x49, 0xAE, 0x20, 0x41, 0x31,
      0x12, 0xE6, 0xFA, 0x4E, 0x89, 0xA9, 0x7E, 0xA2,
      0x0A, 0x9E, 0xEE, 0xE6, 0x4B, 0x55, 0xD3, 0x9A,
      0x21, 0x92, 0x99, 0x2A, 0x27, 0x4F, 0xC1, 0xA8,
      0x36, 0xBA, 0x3C, 0x23, 0xA3, 0xFE, 0xEB, 0xBD,
      0x45, 0x4D, 0x44, 0x23, 0x64, 0x3C, 0xE8, 0x0E,
      0x2A, 0x9A, 0xC9, 0x4F, 0xA5, 0x4C, 0xA4, 0x9F },
    { 0x8E, 0x95, 0x9B, 0x75, 0xDA, 0xE3, 0x13, 0xDA,
      0x8C, 0xF4, 0xF7, 0x28, 0x14, 0xFC, 0x14, 0x3F,
      0x8F, 0x77, 0x79, 0xC6, 0xEB, 0x9F, 0x7F, 0xA1,
      0x72, 0x99, 0xAE, 0xAD, 0xB6, 0x88, 0x90, 0x18,
      0x50, 0x1D, 0x28, 0x9E, 0x49, 0x00, 0xF7, 0xE4,
      0x33, 0x1B, 0x99, 0xDE, 0xC4, 0xB5, 0x43, 0x3A,
      0xC7, 0xD3, 0x29, 0xEE, 0xB6, 0xDD, 0x26, 0x54,
      0x5E, 0x96, 0xE5, 0x5B, 0x87, 0x4B, 0xE9, 0x09 },
    { 0xE7, 0x18, 0x48, 0x3D, 0x0C, 0xE7, 0x69, 0x64,
      0x4E, 0x2E, 0x42, 0xC7, 0xBC, 0x15, 0xB4, 0x63,
      0x8E, 0x1F, 0x98, 0xB1, 0x3B, 0x20, 0x44, 0x28,
      0x56, 0x32, 0xA8, 0x03, 0xAF, 0xA9, 0x73, 0xEB,
      0xDE, 0x0F, 0xF2, 0x44, 0x87, 0x7E, 0xA6, 0x0A,
      0x4C, 0xB0, 0x43, 0x2C, 0xE5, 0x77, 0xC3, 0x1B,
      0xEB, 0x00, 0x9C, 0x5C, 0x2C, 0x49, 0xAA, 0x2E,
      0x4E, 0xAD, 0xB2, 0x17, 0xAD, 0x8C, 0xC0, 0x9B }
};

/*
 * RFC 4231 test vectors
 */
static byte sha4_hmac_test_key[7][26] =
{
    { "\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B"
      "\x0B\x0B\x0B\x0B" },
    { "Jefe" },
    { "\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA"
      "\xAA\xAA\xAA\xAA" },
    { "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10"
      "\x11\x12\x13\x14\x15\x16\x17\x18\x19" },
    { "\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C"
      "\x0C\x0C\x0C\x0C" },
    { "" }, /* 0xAA 131 times */
    { "" }
};

static const int sha4_hmac_test_keylen[7] =
{
    20, 4, 20, 25, 20, 131, 131
};

static byte sha4_hmac_test_buf[7][153] =
{
    { "Hi There" },
    { "what do ya want for nothing?" },
    { "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD" },
    { "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD" },
    { "Test With Truncation" },
    { "Test Using Larger Than Block-Size Key - Hash Key First" },
    { "This is a test using a larger than block-size key "
      "and a larger than block-size data. The key needs to "
      "be hashed before being used by the HMAC algorithm." }
};

static const int sha4_hmac_test_buflen[7] =
{
    8, 28, 50, 50, 20, 54, 152
};

static const byte sha4_hmac_test_sum[14][64] =
{
    /*
     * HMAC-SHA-384 test vectors
     */
    { 0xAF, 0xD0, 0x39, 0x44, 0xD8, 0x48, 0x95, 0x62,
      0x6B, 0x08, 0x25, 0xF4, 0xAB, 0x46, 0x90, 0x7F,
      0x15, 0xF9, 0xDA, 0xDB, 0xE4, 0x10, 0x1E, 0xC6,
      0x82, 0xAA, 0x03, 0x4C, 0x7C, 0xEB, 0xC5, 0x9C,
      0xFA, 0xEA, 0x9E, 0xA9, 0x07, 0x6E, 0xDE, 0x7F,
      0x4A, 0xF1, 0x52, 0xE8, 0xB2, 0xFA, 0x9C, 0xB6 },
    { 0xAF, 0x45, 0xD2, 0xE3, 0x76, 0x48, 0x40, 0x31,
      0x61, 0x7F, 0x78, 0xD2, 0xB5, 0x8A, 0x6B, 0x1B,
      0x9C, 0x7E, 0xF4, 0x64, 0xF5, 0xA0, 0x1B, 0x47,
      0xE4, 0x2E, 0xC3, 0x73, 0x63, 0x22, 0x44, 0x5E,
      0x8E, 0x22, 0x40, 0xCA, 0x5E, 0x69, 0xE2, 0xC7,
      0x8B, 0x32, 0x39, 0xEC, 0xFA, 0xB2, 0x16, 0x49 },
    { 0x88, 0x06, 0x26, 0x08, 0xD3, 0xE6, 0xAD, 0x8A,
      0x0A, 0xA2, 0xAC, 0xE0, 0x14, 0xC8, 0xA8, 0x6F,
      0x0A, 0xA6, 0x35, 0xD9, 0x47, 0xAC, 0x9F, 0xEB,
      0xE8, 0x3E, 0xF4, 0xE5, 0x59, 0x66, 0x14, 0x4B,
      0x2A, 0x5A, 0xB3, 0x9D, 0xC1, 0x38, 0x14, 0xB9,
      0x4E, 0x3A, 0xB6, 0xE1, 0x01, 0xA3, 0x4F, 0x27 },
    { 0x3E, 0x8A, 0x69, 0xB7, 0x78, 0x3C, 0x25, 0x85,
      0x19, 0x33, 0xAB, 0x62, 0x90, 0xAF, 0x6C, 0xA7,
      0x7A, 0x99, 0x81, 0x48, 0x08, 0x50, 0x00, 0x9C,
      0xC5, 0x57, 0x7C, 0x6E, 0x1F, 0x57, 0x3B, 0x4E,
      0x68, 0x01, 0xDD, 0x23, 0xC4, 0xA7, 0xD6, 0x79,
      0xCC, 0xF8, 0xA3, 0x86, 0xC6, 0x74, 0xCF, 0xFB },
    { 0x3A, 0xBF, 0x34, 0xC3, 0x50, 0x3B, 0x2A, 0x23,
      0xA4, 0x6E, 0xFC, 0x61, 0x9B, 0xAE, 0xF8, 0x97 },
    { 0x4E, 0xCE, 0x08, 0x44, 0x85, 0x81, 0x3E, 0x90,
      0x88, 0xD2, 0xC6, 0x3A, 0x04, 0x1B, 0xC5, 0xB4,
      0x4F, 0x9E, 0xF1, 0x01, 0x2A, 0x2B, 0x58, 0x8F,
      0x3C, 0xD1, 0x1F, 0x05, 0x03, 0x3A, 0xC4, 0xC6,
      0x0C, 0x2E, 0xF6, 0xAB, 0x40, 0x30, 0xFE, 0x82,
      0x96, 0x24, 0x8D, 0xF1, 0x63, 0xF4, 0x49, 0x52 },
    { 0x66, 0x17, 0x17, 0x8E, 0x94, 0x1F, 0x02, 0x0D,
      0x35, 0x1E, 0x2F, 0x25, 0x4E, 0x8F, 0xD3, 0x2C,
      0x60, 0x24, 0x20, 0xFE, 0xB0, 0xB8, 0xFB, 0x9A,
      0xDC, 0xCE, 0xBB, 0x82, 0x46, 0x1E, 0x99, 0xC5,
      0xA6, 0x78, 0xCC, 0x31, 0xE7, 0x99, 0x17, 0x6D,
      0x38, 0x60, 0xE6, 0x11, 0x0C, 0x46, 0x52, 0x3E },

    /*
     * HMAC-SHA-512 test vectors
     */
    { 0x87, 0xAA, 0x7C, 0xDE, 0xA5, 0xEF, 0x61, 0x9D,
      0x4F, 0xF0, 0xB4, 0x24, 0x1A, 0x1D, 0x6C, 0xB0,
      0x23, 0x79, 0xF4, 0xE2, 0xCE, 0x4E, 0xC2, 0x78,
      0x7A, 0xD0, 0xB3, 0x05, 0x45, 0xE1, 0x7C, 0xDE,
      0xDA, 0xA8, 0x33, 0xB7, 0xD6, 0xB8, 0xA7, 0x02,
      0x03, 0x8B, 0x27, 0x4E, 0xAE, 0xA3, 0xF4, 0xE4,
      0xBE, 0x9D, 0x91, 0x4E, 0xEB, 0x61, 0xF1, 0x70,
      0x2E, 0x69, 0x6C, 0x20, 0x3A, 0x12, 0x68, 0x54 },
    { 0x16, 0x4B, 0x7A, 0x7B, 0xFC, 0xF8, 0x19, 0xE2,
      0xE3, 0x95, 0xFB, 0xE7, 0x3B, 0x56, 0xE0, 0xA3,
      0x87, 0xBD, 0x64, 0x22, 0x2E, 0x83, 0x1F, 0xD6,
      0x10, 0x27, 0x0C, 0xD7, 0xEA, 0x25, 0x05, 0x54,
      0x97, 0x58, 0xBF, 0x75, 0xC0, 0x5A, 0x99, 0x4A,
      0x6D, 0x03, 0x4F, 0x65, 0xF8, 0xF0, 0xE6, 0xFD,
      0xCA, 0xEA, 0xB1, 0xA3, 0x4D, 0x4A, 0x6B, 0x4B,
      0x63, 0x6E, 0x07, 0x0A, 0x38, 0xBC, 0xE7, 0x37 },
    { 0xFA, 0x73, 0xB0, 0x08, 0x9D, 0x56, 0xA2, 0x84,
      0xEF, 0xB0, 0xF0, 0x75, 0x6C, 0x89, 0x0B, 0xE9,
      0xB1, 0xB5, 0xDB, 0xDD, 0x8E, 0xE8, 0x1A, 0x36,
      0x55, 0xF8, 0x3E, 0x33, 0xB2, 0x27, 0x9D, 0x39,
      0xBF, 0x3E, 0x84, 0x82, 0x79, 0xA7, 0x22, 0xC8,
      0x06, 0xB4, 0x85, 0xA4, 0x7E, 0x67, 0xC8, 0x07,
      0xB9, 0x46, 0xA3, 0x37, 0xBE, 0xE8, 0x94, 0x26,
      0x74, 0x27, 0x88, 0x59, 0xE1, 0x32, 0x92, 0xFB },
    { 0xB0, 0xBA, 0x46, 0x56, 0x37, 0x45, 0x8C, 0x69,
      0x90, 0xE5, 0xA8, 0xC5, 0xF6, 0x1D, 0x4A, 0xF7,
      0xE5, 0x76, 0xD9, 0x7F, 0xF9, 0x4B, 0x87, 0x2D,
      0xE7, 0x6F, 0x80, 0x50, 0x36, 0x1E, 0xE3, 0xDB,
      0xA9, 0x1C, 0xA5, 0xC1, 0x1A, 0xA2, 0x5E, 0xB4,
      0xD6, 0x79, 0x27, 0x5C, 0xC5, 0x78, 0x80, 0x63,
      0xA5, 0xF1, 0x97, 0x41, 0x12, 0x0C, 0x4F, 0x2D,
      0xE2, 0xAD, 0xEB, 0xEB, 0x10, 0xA2, 0x98, 0xDD },
    { 0x41, 0x5F, 0xAD, 0x62, 0x71, 0x58, 0x0A, 0x53,
      0x1D, 0x41, 0x79, 0xBC, 0x89, 0x1D, 0x87, 0xA6 },
    { 0x80, 0xB2, 0x42, 0x63, 0xC7, 0xC1, 0xA3, 0xEB,
      0xB7, 0x14, 0x93, 0xC1, 0xDD, 0x7B, 0xE8, 0xB4,
      0x9B, 0x46, 0xD1, 0xF4, 0x1B, 0x4A, 0xEE, 0xC1,
      0x12, 0x1B, 0x01, 0x37, 0x83, 0xF8, 0xF3, 0x52,
      0x6B, 0x56, 0xD0, 0x37, 0xE0, 0x5F, 0x25, 0x98,
      0xBD, 0x0F, 0xD2, 0x21, 0x5D, 0x6A, 0x1E, 0x52,
      0x95, 0xE6, 0x4F, 0x73, 0xF6, 0x3F, 0x0A, 0xEC,
      0x8B, 0x91, 0x5A, 0x98, 0x5D, 0x78, 0x65, 0x98 },
    { 0xE3, 0x7B, 0x6A, 0x77, 0x5D, 0xC8, 0x7D, 0xBA,
      0xA4, 0xDF, 0xA9, 0xF9, 0x6E, 0x5E, 0x3F, 0xFD,
      0xDE, 0xBD, 0x71, 0xF8, 0x86, 0x72, 0x89, 0x86,
      0x5D, 0xF5, 0xA3, 0x2D, 0x20, 0xCD, 0xC9, 0x44,
      0xB6, 0x02, 0x2C, 0xAC, 0x3C, 0x49, 0x82, 0xB1,
      0x0D, 0x5E, 0xEB, 0x55, 0xC3, 0xE4, 0xDE, 0x15,
      0x13, 0x46, 0x76, 0xFB, 0x6D, 0xE0, 0x44, 0x60,
      0x65, 0xC9, 0x74, 0x40, 0xFA, 0x8C, 0x6A, 0x58 }
};

Z_GROUP_EXPORT(sha4)
{
    Z_TEST(hash, "") {
        byte buf[1024];
        byte sha4sum[64];
        sha4_ctx ctx;
        int len;

        for (int i = 0; i < 6; i++) {
            int j = i % 3;
            int k = i < 3;

            sha4_starts( &ctx, k );
            if(j == 2) {
                memset(buf, 'a', 1000);

                for (int l = 0; l < 1000; l++)
                    sha4_update( &ctx, buf, 1000);
            } else {
                sha4_update(&ctx, sha4_test_buf[j],
                            sha4_test_buflen[j]);
            }
            sha4_finish(&ctx, sha4sum);

            len = 64 - k * 16;
            Z_ASSERT_EQUAL(sha4sum, len, sha4_test_sum[i], len);
        }
    } Z_TEST_END;

    Z_TEST(hmac, "") {
        byte buf[1024];
        byte sha4sum[64];
        sha4_ctx ctx;
        int len;

        for (int i = 0; i < 14; i++) {
            int j = i % 7;
            int k = i < 7;

            if (j == 5 || j == 6) {
                memset(buf, '\xAA', 131);
                sha4_hmac_starts(&ctx, buf, 131, k);
            } else {
                sha4_hmac_starts(&ctx, sha4_hmac_test_key[j],
                                 sha4_hmac_test_keylen[j], k);
            }
            sha4_hmac_update(&ctx, sha4_hmac_test_buf[j],
                             sha4_hmac_test_buflen[j]);
            sha4_hmac_finish(&ctx, sha4sum);

            len = (j == 4) ? 16 : 64 - k * 16;
            Z_ASSERT_EQUAL(sha4sum, len, sha4_hmac_test_sum[i], len);
        }
    } Z_TEST_END;
} Z_GROUP_END

/* }}} */
/* {{{ aes */

/*
 * AES test vectors from:
 *
 * http://csrc.nist.gov/archive/aes/rijndael/rijndael-vals.zip
 */
static const byte aes_test_ecb_dec[3][16] =
{
    { 0x44, 0x41, 0x6A, 0xC2, 0xD1, 0xF5, 0x3C, 0x58,
      0x33, 0x03, 0x91, 0x7E, 0x6B, 0xE9, 0xEB, 0xE0 },
    { 0x48, 0xE3, 0x1E, 0x9E, 0x25, 0x67, 0x18, 0xF2,
      0x92, 0x29, 0x31, 0x9C, 0x19, 0xF1, 0x5B, 0xA4 },
    { 0x05, 0x8C, 0xCF, 0xFD, 0xBB, 0xCB, 0x38, 0x2D,
      0x1F, 0x6F, 0x56, 0x58, 0x5D, 0x8A, 0x4A, 0xDE }
};

static const byte aes_test_ecb_enc[3][16] =
{
    { 0xC3, 0x4C, 0x05, 0x2C, 0xC0, 0xDA, 0x8D, 0x73,
      0x45, 0x1A, 0xFE, 0x5F, 0x03, 0xBE, 0x29, 0x7F },
    { 0xF3, 0xF6, 0x75, 0x2A, 0xE8, 0xD7, 0x83, 0x11,
      0x38, 0xF0, 0x41, 0x56, 0x06, 0x31, 0xB1, 0x14 },
    { 0x8B, 0x79, 0xEE, 0xCC, 0x93, 0xA0, 0xEE, 0x5D,
      0xFF, 0x30, 0xB4, 0xEA, 0x21, 0x63, 0x6D, 0xA4 }
};

static const byte aes_test_cbc_dec[3][16] =
{
    { 0xFA, 0xCA, 0x37, 0xE0, 0xB0, 0xC8, 0x53, 0x73,
      0xDF, 0x70, 0x6E, 0x73, 0xF7, 0xC9, 0xAF, 0x86 },
    { 0x5D, 0xF6, 0x78, 0xDD, 0x17, 0xBA, 0x4E, 0x75,
      0xB6, 0x17, 0x68, 0xC6, 0xAD, 0xEF, 0x7C, 0x7B },
    { 0x48, 0x04, 0xE1, 0x81, 0x8F, 0xE6, 0x29, 0x75,
      0x19, 0xA3, 0xE8, 0x8C, 0x57, 0x31, 0x04, 0x13 }
};

static const byte aes_test_cbc_enc[3][16] =
{
    { 0x8A, 0x05, 0xFC, 0x5E, 0x09, 0x5A, 0xF4, 0x84,
      0x8A, 0x08, 0xD3, 0x28, 0xD3, 0x68, 0x8E, 0x3D },
    { 0x7B, 0xD9, 0x66, 0xD5, 0x3A, 0xD8, 0xC1, 0xBB,
      0x85, 0xD2, 0xAD, 0xFA, 0xE8, 0x7B, 0xB1, 0x04 },
    { 0xFE, 0x3C, 0x53, 0x65, 0x3E, 0x2F, 0x45, 0xB5,
      0x6F, 0xCD, 0x88, 0xB2, 0xCC, 0x89, 0x8F, 0xF0 }
};

/*
 * AES-CFB test vectors (generated on 2008-02-12)
 */
static const byte aes_test_cfb_dec[3][16] =
{
    { 0xBA, 0x75, 0x0C, 0xC9, 0x77, 0xF8, 0xD4, 0xE1,
      0x3E, 0x0F, 0xB5, 0x46, 0x2E, 0xA6, 0x33, 0xF6 },
    { 0xDB, 0x40, 0x4A, 0x98, 0x7B, 0xAA, 0xA3, 0xF3,
      0x92, 0x35, 0xAD, 0x58, 0x09, 0x9B, 0xFF, 0x6E },
    { 0xA8, 0x17, 0x41, 0x0E, 0x76, 0x71, 0x60, 0xE5,
      0xFD, 0x37, 0xC5, 0x43, 0xCC, 0xC8, 0xD6, 0xDA }
};

static const byte aes_test_cfb_enc[3][16] =
{
    { 0x45, 0x62, 0xC5, 0xA1, 0xF9, 0x10, 0x8F, 0xE0,
      0x87, 0x24, 0x25, 0x68, 0xB5, 0x12, 0xF3, 0x8B },
    { 0xB8, 0xD4, 0xD5, 0x09, 0xF5, 0xEE, 0x08, 0x38,
      0x48, 0x9B, 0x9D, 0xAD, 0x11, 0xB4, 0x2E, 0xD2 },
    { 0xE9, 0x10, 0x80, 0xDA, 0xEE, 0x2D, 0x81, 0xD9,
      0x41, 0x78, 0x91, 0xD5, 0x98, 0x78, 0xE1, 0xFA }
};

Z_GROUP_EXPORT(aes)
{
    Z_TEST(ECB, "ECB mode") {
        byte key[32];
        byte buf[16];
        aes_ctx ctx;

        memset(key, 0, 32);

        for (int i = 0; i < 6; i++) {
            int u = i >> 1;
            int v = i  & 1;

            memset(buf, 0, 16);
            if (v == AES_DECRYPT) {
                aes_setkey_dec(&ctx, key, 128 + u * 64);

                for (int j = 0; j < 10000; j++)
                    aes_crypt_ecb(&ctx, v, buf, buf);

                Z_ASSERT_EQUAL(buf, 16, aes_test_ecb_dec[u], 16);
            } else {
                aes_setkey_enc(&ctx, key, 128 + u * 64);

                for (int j = 0; j < 10000; j++)
                    aes_crypt_ecb(&ctx, v, buf, buf);

                Z_ASSERT_EQUAL(buf, 16, aes_test_ecb_enc[u], 16);
            }
        }
    } Z_TEST_END;

    Z_TEST(CBC, "CBC mode") {
        byte key[32];
        byte buf[16];
        byte prv[16];
        byte iv[16];
        aes_ctx ctx;

        memset(key, 0, 32);

        for (int i = 0; i < 6; i++) {
            int u = i >> 1;
            int v = i  & 1;

            memset(iv , 0, 16);
            memset(prv, 0, 16);
            memset(buf, 0, 16);

            if (v == AES_DECRYPT) {
                aes_setkey_dec(&ctx, key, 128 + u * 64);

                for (int j = 0; j < 10000; j++)
                    aes_crypt_cbc(&ctx, v, 16, iv, buf, buf);

                Z_ASSERT_EQUAL(buf, 16, aes_test_cbc_dec[u], 16);
            } else {
                aes_setkey_enc(&ctx, key, 128 + u * 64);

                for (int j = 0; j < 10000; j++) {
                    byte tmp[16];

                    aes_crypt_cbc(&ctx, v, 16, iv, buf, buf);

                    memcpy(tmp, prv, 16);
                    memcpy(prv, buf, 16);
                    memcpy(buf, tmp, 16);
                }

                Z_ASSERT_EQUAL(prv, 16, aes_test_cbc_enc[u], 16);
            }
        }
    } Z_TEST_END;

    Z_TEST(CFB, "CFB mode") {
        byte key[32];
        byte buf[16];
        byte iv[16];
        aes_ctx ctx;

        memset(key, 0, 32);

        for (int i = 0; i < 6; i++) {
            int u = i >> 1;
            int v = i  & 1;
            int offset = 0;

            memset(iv , 0, 16);
            memset(buf, 0, 16);

            if (v == AES_DECRYPT) {
                aes_setkey_dec(&ctx, key, 128 + u * 64);

                for (int j = 0; j < 10000; j++)
                    aes_crypt_cfb(&ctx, v, 16, &offset, iv, buf, buf);

                Z_ASSERT_EQUAL(buf, 16, aes_test_cfb_dec[u], 16);
            } else {
                aes_setkey_enc(&ctx, key, 128 + u * 64);

                for (int j = 0; j < 10000; j++)
                    aes_crypt_cfb(&ctx, v, 16, &offset, iv, buf, buf);

                Z_ASSERT_EQUAL(buf, 16, aes_test_cfb_enc[u], 16);
            }
        }
    } Z_TEST_END;
} Z_GROUP_END

/* }}} */
/* {{{ des */

/*
 * DES and 3DES test vectors from:
 *
 * http://csrc.nist.gov/groups/STM/cavp/documents/des/tripledes-vectors.zip
 */
static const byte des3_test_keys[24] =
{
    0x01, 0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF,
    0x23, 0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01,
    0x45, 0x67, 0x89, 0xAB, 0xCD, 0xEF, 0x01, 0x23
};

static const byte des3_test_iv[8] =
{
    0x12, 0x34, 0x56, 0x78, 0x90, 0xAB, 0xCD, 0xEF,
};

static const byte des3_test_buf[8] =
{
    0x4E, 0x6F, 0x77, 0x20, 0x69, 0x73, 0x20, 0x74
};

static const byte des3_test_ecb_dec[3][8] =
{
    { 0xCD, 0xD6, 0x4F, 0x2F, 0x94, 0x27, 0xC1, 0x5D },
    { 0x69, 0x96, 0xC8, 0xFA, 0x47, 0xA2, 0xAB, 0xEB },
    { 0x83, 0x25, 0x39, 0x76, 0x44, 0x09, 0x1A, 0x0A }
};

static const byte des3_test_ecb_enc[3][8] =
{
    { 0x6A, 0x2A, 0x19, 0xF4, 0x1E, 0xCA, 0x85, 0x4B },
    { 0x03, 0xE6, 0x9F, 0x5B, 0xFA, 0x58, 0xEB, 0x42 },
    { 0xDD, 0x17, 0xE8, 0xB8, 0xB4, 0x37, 0xD2, 0x32 }
};

static const byte des3_test_cbc_dec[3][8] =
{
    { 0x12, 0x9F, 0x40, 0xB9, 0xD2, 0x00, 0x56, 0xB3 },
    { 0x47, 0x0E, 0xFC, 0x9A, 0x6B, 0x8E, 0xE3, 0x93 },
    { 0xC5, 0xCE, 0xCF, 0x63, 0xEC, 0xEC, 0x51, 0x4C }
};

static const byte des3_test_cbc_enc[3][8] =
{
    { 0x54, 0xF1, 0x5A, 0xF6, 0xEB, 0xE3, 0xA4, 0xB4 },
    { 0x35, 0x76, 0x11, 0x56, 0x5F, 0xA1, 0x8E, 0x4D },
    { 0xCB, 0x19, 0x1F, 0x85, 0xD1, 0xED, 0x84, 0x39 }
};

Z_GROUP_EXPORT(des)
{
    Z_TEST(ECB, "") {
        des_ctx ctx;
        des3_ctx ctx3;
        byte key[24];
        byte buf[8];

        memset(key, 0, 24);

        for (int i = 0; i < 6; i++) {
            int u = i >> 1;
            int v = i  & 1;

            memcpy(buf, des3_test_buf, 8);

            switch (i)
            {
              case 0:
                des_setkey_dec(&ctx, (byte *) des3_test_keys);
                break;
              case 1:
                des_setkey_enc(&ctx, (byte *) des3_test_keys);
                break;
              case 2:
                des3_set2key_dec(&ctx3, (byte *) des3_test_keys);
                break;
              case 3:
                des3_set2key_enc(&ctx3, (byte *) des3_test_keys);
                break;
              case 4:
                des3_set3key_dec(&ctx3, (byte *) des3_test_keys);
                break;
              case 5:
                des3_set3key_enc(&ctx3, (byte *) des3_test_keys);
                break;
              default:
                Z_ASSERT(false);
            }

            for (int j = 0; j < 10000; j++) {
                if (u == 0) {
                    des_crypt_ecb(&ctx, buf, buf);
                } else {
                    des3_crypt_ecb(&ctx3, buf, buf);
                }
            }

            if (v == DES_DECRYPT) {
                Z_ASSERT_EQUAL(buf, 8, des3_test_ecb_dec[u], 8);
            } else {
                Z_ASSERT_EQUAL(buf, 8, des3_test_ecb_enc[u], 8);
            }
        }
    } Z_TEST_END;

    Z_TEST(CBC, "") {
        des_ctx ctx;
        des3_ctx ctx3;
        byte key[24];
        byte buf[8];
        byte prv[8];
        byte iv[8];

        memset(key, 0, 24);

        for (int i = 0; i < 6; i++) {
            int u = i >> 1;
            int v = i  & 1;

            memcpy(iv,  des3_test_iv,  8);
            memcpy(prv, des3_test_iv,  8);
            memcpy(buf, des3_test_buf, 8);

            switch (i)
            {
              case 0:
                des_setkey_dec(&ctx, (byte *) des3_test_keys);
                break;
              case 1:
                des_setkey_enc(&ctx, (byte *) des3_test_keys);
                break;
              case 2:
                des3_set2key_dec(&ctx3, (byte *) des3_test_keys);
                break;
              case 3:
                des3_set2key_enc(&ctx3, (byte *) des3_test_keys);
                break;
              case 4:
                des3_set3key_dec(&ctx3, (byte *) des3_test_keys);
                break;
              case 5:
                des3_set3key_enc(&ctx3, (byte *) des3_test_keys);
                break;
              default:
                Z_ASSERT(false);
            }

            if (v == DES_DECRYPT) {
                for (int j = 0; j < 10000; j++) {
                    if (u == 0) {
                        des_crypt_cbc(&ctx, v, 8, iv, buf, buf);
                    } else {
                        des3_crypt_cbc(&ctx3, v, 8, iv, buf, buf);
                    }
                }
            } else {
                for (int j = 0; j < 10000; j++) {
                    byte tmp[8];

                    if (u == 0) {
                        des_crypt_cbc(&ctx, v, 8, iv, buf, buf);
                    } else {
                        des3_crypt_cbc(&ctx3, v, 8, iv, buf, buf);
                    }

                    memcpy(tmp, prv, 8);
                    memcpy(prv, buf, 8);
                    memcpy(buf, tmp, 8);
                }

                memcpy(buf, prv, 8);
            }

            if (v == DES_DECRYPT) {
                Z_ASSERT_EQUAL(buf, 8, des3_test_cbc_dec[u], 8);
            } else {
                Z_ASSERT_EQUAL(buf, 8, des3_test_cbc_enc[u], 8);
            }
        }
    } Z_TEST_END;
} Z_GROUP_END

/* }}} */
/* {{{ md5 */

/*
 * RFC 1321 test vectors
 */
static byte md5_test_buf[7][81] =
{
    { "" },
    { "a" },
    { "abc" },
    { "message digest" },
    { "abcdefghijklmnopqrstuvwxyz" },
    { "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789" },
    { "12345678901234567890123456789012345678901234567890123456789012" \
      "345678901234567890" }
};

static const int md5_test_buflen[7] =
{
    0, 1, 3, 14, 26, 62, 80
};

static const byte md5_test_sum[7][16] =
{
    { 0xD4, 0x1D, 0x8C, 0xD9, 0x8F, 0x00, 0xB2, 0x04,
      0xE9, 0x80, 0x09, 0x98, 0xEC, 0xF8, 0x42, 0x7E },
    { 0x0C, 0xC1, 0x75, 0xB9, 0xC0, 0xF1, 0xB6, 0xA8,
      0x31, 0xC3, 0x99, 0xE2, 0x69, 0x77, 0x26, 0x61 },
    { 0x90, 0x01, 0x50, 0x98, 0x3C, 0xD2, 0x4F, 0xB0,
      0xD6, 0x96, 0x3F, 0x7D, 0x28, 0xE1, 0x7F, 0x72 },
    { 0xF9, 0x6B, 0x69, 0x7D, 0x7C, 0xB7, 0x93, 0x8D,
      0x52, 0x5A, 0x2F, 0x31, 0xAA, 0xF1, 0x61, 0xD0 },
    { 0xC3, 0xFC, 0xD3, 0xD7, 0x61, 0x92, 0xE4, 0x00,
      0x7D, 0xFB, 0x49, 0x6C, 0xCA, 0x67, 0xE1, 0x3B },
    { 0xD1, 0x74, 0xAB, 0x98, 0xD2, 0x77, 0xD9, 0xF5,
      0xA5, 0x61, 0x1C, 0x2C, 0x9F, 0x41, 0x9D, 0x9F },
    { 0x57, 0xED, 0xF4, 0xA2, 0x2B, 0xE3, 0xC9, 0x55,
      0xAC, 0x49, 0xDA, 0x2E, 0x21, 0x07, 0xB6, 0x7A }
};

/*
 * RFC 2202 test vectors
 */
static byte md5_hmac_test_key[7][26] =
{
    { "\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B\x0B" },
    { "Jefe" },
    { "\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA\xAA" },
    { "\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F\x10"
      "\x11\x12\x13\x14\x15\x16\x17\x18\x19" },
    { "\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C\x0C" },
    { "" }, /* 0xAA 80 times */
    { "" }
};

static const int md5_hmac_test_keylen[7] =
{
    16, 4, 16, 25, 16, 80, 80
};

static byte md5_hmac_test_buf[7][74] =
{
    { "Hi There" },
    { "what do ya want for nothing?" },
    { "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD"
      "\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD\xDD" },
    { "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD"
      "\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD\xCD" },
    { "Test With Truncation" },
    { "Test Using Larger Than Block-Size Key - Hash Key First" },
    { "Test Using Larger Than Block-Size Key and Larger"
      " Than One Block-Size Data" }
};

static const int md5_hmac_test_buflen[7] =
{
    8, 28, 50, 50, 20, 54, 73
};

static const byte md5_hmac_test_sum[7][16] =
{
    { 0x92, 0x94, 0x72, 0x7A, 0x36, 0x38, 0xBB, 0x1C,
      0x13, 0xF4, 0x8E, 0xF8, 0x15, 0x8B, 0xFC, 0x9D },
    { 0x75, 0x0C, 0x78, 0x3E, 0x6A, 0xB0, 0xB5, 0x03,
      0xEA, 0xA8, 0x6E, 0x31, 0x0A, 0x5D, 0xB7, 0x38 },
    { 0x56, 0xBE, 0x34, 0x52, 0x1D, 0x14, 0x4C, 0x88,
      0xDB, 0xB8, 0xC7, 0x33, 0xF0, 0xE8, 0xB3, 0xF6 },
    { 0x69, 0x7E, 0xAF, 0x0A, 0xCA, 0x3A, 0x3A, 0xEA,
      0x3A, 0x75, 0x16, 0x47, 0x46, 0xFF, 0xAA, 0x79 },
    { 0x56, 0x46, 0x1E, 0xF2, 0x34, 0x2E, 0xDC, 0x00,
      0xF9, 0xBA, 0xB9, 0x95 },
    { 0x6B, 0x1A, 0xB7, 0xFE, 0x4B, 0xD7, 0xBF, 0x8F,
      0x0B, 0x62, 0xE6, 0xCE, 0x61, 0xB9, 0xD0, 0xCD },
    { 0x6F, 0x63, 0x0F, 0xAD, 0x67, 0xCD, 0xA0, 0xEE,
      0x1F, 0xB1, 0xF5, 0x62, 0xDB, 0x3A, 0xA5, 0x3E }
};

Z_GROUP_EXPORT(md5)
{
    Z_TEST(hash, "") {
        byte md5sum[16];

        for (int i = 0; i < 7; i++) {
            md5(md5_test_buf[i], md5_test_buflen[i], md5sum);
            Z_ASSERT_EQUAL(md5sum, 16, md5_test_sum[i], 16);
        }
    } Z_TEST_END;

    Z_TEST(hmac, "") {
        byte buf[1024];
        byte md5sum[16];
        md5_ctx ctx;

        for (int i = 0; i < 7; i++) {
            if (i == 5 || i == 6) {
                memset(buf, '\xAA', 80);
                md5_hmac_starts(&ctx, buf, 80);
            } else {
                md5_hmac_starts(&ctx, md5_hmac_test_key[i],
                                md5_hmac_test_keylen[i]);
            }

            md5_hmac_update(&ctx, md5_hmac_test_buf[i],
                            md5_hmac_test_buflen[i]);
            md5_hmac_finish(&ctx, md5sum);

            if (i == 4) {
                Z_ASSERT_EQUAL(md5sum, 12, md5_hmac_test_sum[i], 12);
            } else {
                Z_ASSERT_EQUAL(md5sum, 16, md5_hmac_test_sum[i], 16);
            }
        }
    } Z_TEST_END;
} Z_GROUP_END

/* }}} */

/* LCOV_EXCL_STOP */
