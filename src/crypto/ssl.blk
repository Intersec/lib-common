/***************************************************************************/
/*                                                                         */
/* Copyright 2022 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include <openssl/ssl.h>
#include <openssl/err.h>
#include <lib-common/z.h>
#include <lib-common/zchk-helpers.h>
#include <lib-common/ssl.h>
#include <lib-common/hash.h>

/* {{{ Module */

static int ssl_initialize(void *arg)
{
    /* interpreting internal errors is a nightmare, we want human readable
     * messages */
    SSL_load_error_strings();
    SSL_library_init();
#if OPENSSL_VERSION_IS(<,1,0,2)
    OpenSSL_add_all_algorithms();
#endif
    return 0;
}

static int ssl_shutdown(void)
{
    ERR_free_strings();
    EVP_cleanup();
    return 0;
}

MODULE_BEGIN(ssl)
MODULE_END()

/* }}} */
/* {{{ Initialize & wipe */

static __thread char openssl_errbuf_g[1024];

#define __ssl_set_error(msg, ...)                                            \
    ({ snprintf(openssl_errbuf_g, sizeof(openssl_errbuf_g),                  \
                msg, ##__VA_ARGS__);                                         \
       -1; })

#define ssl_set_error(msg) \
    __ssl_set_error(msg ": %s", ERR_error_string(ERR_get_error(), NULL))


static ssl_ctx_t *ssl_ctx_init(ssl_ctx_t *ctx)
{
    p_clear(ctx, 1);

    ctx->encrypt = EVP_CIPHER_CTX_new();
    ctx->decrypt = EVP_CIPHER_CTX_new();

    return ctx;
}
GENERIC_NEW(ssl_ctx_t, ssl_ctx);

void ssl_ctx_wipe(ssl_ctx_t *ctx)
{
#ifndef NDEBUG
    if (unlikely(ctx->encrypt_state == SSL_CTX_UPDATE))
        e_trace(0, "SSL context closed with inconsistent encrypt state");
    if (unlikely(ctx->decrypt_state == SSL_CTX_UPDATE))
        e_trace(0, "SSL context closed with inconsistent decrypt state");
#endif
    if (ctx->pkey_encrypt) {
        EVP_PKEY_CTX_free(ctx->pkey_encrypt);
        ctx->pkey_encrypt = NULL;
    }
    if (ctx->pkey_decrypt) {
        EVP_PKEY_CTX_free(ctx->pkey_decrypt);
        ctx->pkey_decrypt = NULL;
    }
    if (ctx->pkey) {
        EVP_PKEY_free(ctx->pkey);
        ctx->pkey = NULL;
    }

    EVP_CIPHER_CTX_free(ctx->encrypt);
    EVP_CIPHER_CTX_free(ctx->decrypt);
}

/** Generate the key and IV from the given password and salt. */
static void
t_ssl_get_aes_key(ssl_ctx_t *ctx, const EVP_CIPHER *type, const EVP_MD *md,
                  lstr_t password, uint64_t salt, int nb_rounds, lstr_t *key,
                  lstr_t *iv)
{
    int keylen = EVP_CIPHER_key_length(type);
    int ivlen = EVP_CIPHER_iv_length(type);
    unsigned char *keybuf = t_new_raw(unsigned char, keylen);
    unsigned char *ivbuf = t_new_raw(unsigned char, ivlen);

    EVP_BytesToKey(type, md, (const unsigned char *)&salt,
                   (const unsigned char *)password.s, password.len, nb_rounds,
                   keybuf, ivbuf);
    *key = LSTR_INIT_V((char *)keybuf, keylen);
    *iv = LSTR_INIT_V((char *)ivbuf, ivlen);
}

/** Setup (distinct) contexts for encryption and decryption. */
static int ssl_ctx_configure(ssl_ctx_t *ctx, const EVP_CIPHER *type,
                             lstr_t key, lstr_t iv)
{
    if (!EVP_EncryptInit_ex(ctx->encrypt, type, NULL, key.data, iv.data)
    ||  !EVP_DecryptInit_ex(ctx->decrypt, type, NULL, key.data, iv.data))
    {
        ssl_set_error("decrypt context initialization failure");
        return -1;
    }
    ctx->encrypt_state = SSL_CTX_INIT;
    ctx->decrypt_state = SSL_CTX_INIT;
    return 0;
}

ssl_ctx_t *ssl_ctx_init_aes256(ssl_ctx_t *ctx, lstr_t password, uint64_t salt,
                               int nb_rounds)
{
    t_scope;
    lstr_t key, iv;

    ssl_ctx_init(ctx);
    t_ssl_get_aes_key(ctx, EVP_aes_256_cbc(), EVP_sha256(), password, salt,
                      nb_rounds, &key, &iv);

    if (ssl_ctx_configure(ctx, EVP_aes_256_cbc(), key, iv) < 0) {
        ssl_ctx_wipe(ctx);
        return NULL;
    }

    return ctx;
}

ssl_ctx_t *ssl_ctx_init_aes256_by_key(ssl_ctx_t *ctx, lstr_t key, lstr_t iv)
{
    ssl_ctx_init(ctx);
    if (ssl_ctx_configure(ctx, EVP_aes_256_cbc(), key, iv) < 0) {
        ssl_ctx_wipe(ctx);
        return NULL;
    }

    return ctx;
}

ssl_ctx_t *
ssl_ctx_init_aes128_ecb_by_key(ssl_ctx_t *ctx, lstr_t key)
{
    ssl_ctx_init(ctx);
    if (ssl_ctx_configure(ctx, EVP_aes_128_ecb(), key, LSTR_NULL_V) < 0) {
        ssl_ctx_wipe(ctx);
        return NULL;
    }

    return ctx;
}

ssl_ctx_t *
ssl_ctx_init_3des_by_key(ssl_ctx_t *ctx, lstr_t key)
{
    ssl_ctx_init(ctx);
    if (ssl_ctx_configure(ctx, EVP_des_ede3(), key, LSTR_NULL_V) < 0) {
        ssl_ctx_wipe(ctx);
        return NULL;
    }

    return ctx;
}

ssl_ctx_t *ssl_ctx_init_pkey(ssl_ctx_t *ctx,
                             lstr_t priv_key, lstr_t pub_key, lstr_t pass)
{
    t_scope;
    lstr_t key = priv_key.len ? priv_key : pub_key;
    void *u = pass.len ? t_dupz(pass.data, pass.len) : NULL;
    BIO *bio = NULL;

    ssl_ctx_init(ctx);

    if (!key.len) {
        __ssl_set_error("invalid key");
        goto error;
    }

    bio = BIO_new_mem_buf(key.v, key.len);
    if (!bio) {
        ssl_set_error("allocation failure");
        goto error;
    }

    if (priv_key.len) {
        ctx->pkey = PEM_read_bio_PrivateKey(bio, NULL, NULL, u);
    } else {
        ctx->pkey = PEM_read_bio_PUBKEY(bio, NULL, NULL, u);
    }
    if (!ctx->pkey) {
        ssl_set_error("read key failure");
        goto error;
    }
    BIO_free(bio);
    bio = NULL;

    /* whatever key we have, we can alyas encrypt data */
    ctx->pkey_encrypt = EVP_PKEY_CTX_new(ctx->pkey, NULL);
    if (!ctx->pkey_encrypt) {
        ssl_set_error("allocation failure");
        goto error;
    }

    if (priv_key.len) {
        /* private key allows us to decrypt data */
        ctx->pkey_decrypt = EVP_PKEY_CTX_dup(ctx->pkey_encrypt);
        if (!ctx->pkey_decrypt) {
            ssl_set_error("allocation failure");
            goto error;
        }
        if (EVP_PKEY_decrypt_init(ctx->pkey_decrypt) <= 0) {
            ssl_set_error("decrypt context initialization failure");
            goto error;
        }
        ctx->decrypt_state = SSL_CTX_INIT;
    }

    if (EVP_PKEY_encrypt_init(ctx->pkey_encrypt) <= 0) {
        ssl_set_error("encrypt context initialization failure");
        goto error;
    }
    ctx->encrypt_state = SSL_CTX_INIT;

    return ctx;

  error:
    if (bio) {
        BIO_free(bio);
    }
    ssl_ctx_wipe(ctx);
    return NULL;
}

int ssl_ctx_reset(ssl_ctx_t *ctx, lstr_t password, uint64_t salt,
                  int nb_rounds)
{
    t_scope;
    lstr_t key, iv;

    assert (ctx->encrypt_state == SSL_CTX_NONE
        ||  ctx->encrypt_state == SSL_CTX_INIT
        ||  ctx->encrypt_state == SSL_CTX_FINISH);
    assert (ctx->decrypt_state == SSL_CTX_NONE
        ||  ctx->decrypt_state == SSL_CTX_INIT
        ||  ctx->decrypt_state == SSL_CTX_FINISH);

    t_ssl_get_aes_key(ctx, EVP_aes_256_cbc(), EVP_sha256(), password, salt,
                      nb_rounds, &key, &iv);
    return ssl_ctx_configure(ctx, EVP_aes_256_cbc(), key, iv);
}

const char *ssl_get_error(void)
{
    return openssl_errbuf_g;
}

/* }}} */
/* {{{ CYPHER */
/* {{{ Encrypt */

int ssl_encrypt_update(ssl_ctx_t *ctx, lstr_t data, sb_t *out)
{
    int clen = data.len + EVP_CIPHER_CTX_block_size(ctx->encrypt);
    unsigned char *cbuf;

    assert (ctx->encrypt_state == SSL_CTX_INIT
        ||  ctx->encrypt_state == SSL_CTX_UPDATE);

    cbuf = (unsigned char *)sb_grow(out, clen);

    if (unlikely(data.len <= 0)) {
        /* XXX with openssl < 1.0, EVP_EncryptUpdate will abort() with empty
         * data. */
        ctx->encrypt_state = SSL_CTX_UPDATE;
        return 0;
    }

    if (unlikely(!EVP_EncryptUpdate(ctx->encrypt, cbuf, &clen,
                                    (unsigned char *)data.s, data.len)))
    {
        ctx->encrypt_state = SSL_CTX_NONE;
        return ssl_set_error("encrypt error");
    }

    assert (sb_avail(out) >= clen);
    sb_growlen(out, clen);
    ctx->encrypt_state = SSL_CTX_UPDATE;

    return 0;
}

int ssl_encrypt_finish(ssl_ctx_t *ctx, sb_t *out)
{
    int outlen = 0;

    assert (ctx->encrypt_state == SSL_CTX_UPDATE);
    assert (sb_avail(out) >= EVP_CIPHER_CTX_block_size(ctx->encrypt));
    if (unlikely(!EVP_EncryptFinal_ex(ctx->encrypt,
                                      (unsigned char *)sb_end(out), &outlen)))
    {
        ctx->encrypt_state = SSL_CTX_NONE;
        return ssl_set_error("encrypt finalization error");
    }

    assert (sb_avail(out) >= outlen);
    sb_growlen(out, outlen);
    ctx->encrypt_state = SSL_CTX_FINISH;

    return 0;
}

int ssl_encrypt_reset(ssl_ctx_t *ctx, sb_t *out)
{
    assert (ctx->encrypt_state != SSL_CTX_NONE);

    if (ctx->encrypt_state == SSL_CTX_UPDATE) {
        assert (out);
        RETHROW(ssl_encrypt_finish(ctx, out));
    }

    if (ctx->encrypt_state == SSL_CTX_FINISH) {
        if (unlikely(!EVP_EncryptInit_ex(ctx->encrypt, NULL, NULL, NULL,
                                         NULL)))
        {
            ctx->encrypt_state = SSL_CTX_NONE;
            return ssl_set_error("encrypt reset error");
        }
        ctx->encrypt_state = SSL_CTX_INIT;
    }
    assert (ctx->encrypt_state == SSL_CTX_INIT);

    return 0;
}

/* }}} */
/* {{{ Decrypt */

int ssl_decrypt_update(ssl_ctx_t *ctx, lstr_t data, sb_t *out)
{
    int clen = data.len + EVP_CIPHER_CTX_block_size(ctx->decrypt);

    assert (ctx->decrypt_state == SSL_CTX_INIT
        ||  ctx->decrypt_state == SSL_CTX_UPDATE);

    if (unlikely(!EVP_DecryptUpdate(ctx->decrypt,
                                    (unsigned char *)sb_grow(out, clen),
                                    &clen, (unsigned char *)data.s,
                                    data.len)))
    {
        ctx->decrypt_state = SSL_CTX_NONE;
        return ssl_set_error("decrypt error");
    }

    assert (sb_avail(out) >= clen);
    sb_growlen(out, clen);
    ctx->decrypt_state = SSL_CTX_UPDATE;

    return 0;
}

int ssl_decrypt_finish(ssl_ctx_t *ctx, sb_t *out)
{
    int outlen = 0;

    assert (ctx->decrypt_state == SSL_CTX_UPDATE);

    if (unlikely(!EVP_DecryptFinal_ex(ctx->decrypt,
                                      (unsigned char *)sb_end(out), &outlen)))
    {
        ctx->decrypt_state = SSL_CTX_NONE;
        return ssl_set_error("decrypt finalization error");
    }

    assert (sb_avail(out) >= outlen);
    sb_growlen(out, outlen);
    ctx->decrypt_state = SSL_CTX_FINISH;

    return 0;
}

int ssl_decrypt_reset(ssl_ctx_t *ctx, sb_t *out)
{
    assert (ctx->decrypt_state != SSL_CTX_NONE);

    if (ctx->decrypt_state == SSL_CTX_UPDATE) {
        assert (out);
        RETHROW(ssl_decrypt_finish(ctx, out));
    }

    if (ctx->decrypt_state == SSL_CTX_FINISH) {
        if (unlikely(!EVP_DecryptInit_ex(ctx->decrypt, NULL, NULL, NULL,
                                         NULL)))
        {
            ctx->decrypt_state = SSL_CTX_NONE;
            return ssl_set_error("decrypt reset error");
        }
        ctx->decrypt_state = SSL_CTX_INIT;
    }
    assert (ctx->decrypt_state == SSL_CTX_INIT);

    return 0;
}

/* }}} */
/* }}} */
/* {{{ PKEY */

/** Return the size of the key.
 *
 * The length of the key determine both the maximum amount of encryptable data
 * and the length of the resulted encrypted string. For example, if you have a
 * 2048 bits length RSA key, then you can only encrypt up to 256 bytes and the
 * resulting string will (always) be 256 bytes long.
 */
static int ssl_pkey_size(ssl_ctx_t *ctx) {
#if OPENSSL_VERSION_IS(<,1,1,0)
    RSA *tmp = EVP_PKEY_get1_RSA(ctx->pkey);
    int size;

    size = RSA_size(tmp);
    RSA_free(tmp);
    return size;
#elif OPENSSL_VERSION_IS(<,3,0,0)
    return RSA_size(EVP_PKEY_get0_RSA(ctx->pkey));
#else /* OPENSSL_VERSION_IS(>=,3,0,0) */
    return EVP_PKEY_get_size(ctx->pkey);
#endif
}

/* {{{ Encrypt */

static int ssl_encrypt_pkey(ssl_ctx_t *ctx, lstr_t data, sb_t *out)
{
    size_t outlen;
    size_t inlen = data.len;
    const unsigned char *in = data.data;

    if (!ctx->pkey
    ||  !ctx->pkey_encrypt
    ||  ctx->encrypt_state != SSL_CTX_INIT)
    {
        __ssl_set_error("invalid encrypt context state");
        return -1;
    }

    if (EVP_PKEY_encrypt(ctx->pkey_encrypt, NULL, &outlen, in, inlen) <= 0)
    {
        ssl_set_error("encryption failure (size computation)");
        return -1;
    }
    if (EVP_PKEY_encrypt(ctx->pkey_encrypt,
                         (unsigned char *)sb_grow(out, outlen),
                         &outlen, in, inlen) <= 0)
    {
        ssl_set_error("encryption failure");
        return -1;
    }
    sb_growlen(out, outlen);
    return 0;
}

/**
 * RSA keys can only encrypt data as long as the size of the key. A 2048 bit
 * key can only encrypt 256 bytes. Plus, the encryption should (to increase
 * security) add a random padding. While the most common padding weight 11
 * bytes, the new recommanded one is about 41 bytes, which reduces again the
 * available space for encryption.
 *
 * Plus, it is NOT RECOMMANDED to split a string and encode each part with the
 * RSA key (especially for performance purposes). Instead, we generate a
 * symmetric AES key and a random initialisation vector, and we put them
 * together with all data that can fit in the RSA header. The rest of the data
 * are encrypted with the AES key.
 *
 *   [ -------- RSA encrypted data --------- ][ AES encrypted data ]
 *   [ AES key | AES IV | Data | RSA padding ||    rest of data    ]
 *
 * However, for small strings (ligher than rsa_size - rsa_padding bytes), all
 * data can fit in one RSA header. Thus we continue to use only this header.
 *
 *   [ -------- RSA encrypted data --------- ]
 *   [          Data           | RSA padding ]
 */
int ssl_encrypt_pkey_sb(ssl_ctx_t *ctx, lstr_t data, sb_t *out)
{
    ssl_ctx_t actx;
    char key_buf[32];
    char iv_buf[16];
    lstr_t key = LSTR_INIT(key_buf, 32);
    lstr_t iv = LSTR_INIT(iv_buf, 16);
    int key_size = ssl_pkey_size(ctx);
    int rsa_buf_size = key_size - RSA_OAEP_PADDING_SIZE;
    int free_space = rsa_buf_size - key.len - iv.len;
    SB_1k(rsa_buf);

    /* If the data are small enough, let's encrypt them directly. */
    if (data.len <= rsa_buf_size) {
        return ssl_encrypt_pkey(ctx, data, out);
    }

    /* Otherwise, generate AES-256 key and initialisation vector. */
    THROW_IF(RAND_bytes(key.data, 32) != 1, -1);
    THROW_IF(RAND_bytes(iv.data, 16) != 1, -1);

    /* Append the encrypted AES key, its IV, and the first data. */
    sb_add_lstr(&rsa_buf, key);
    sb_add_lstr(&rsa_buf, iv);
    sb_add(&rsa_buf, data.s, free_space);
    data = LSTR_INIT_V(data.s + free_space, data.len - free_space);

    RETHROW(ssl_encrypt_pkey(ctx, LSTR_SB_V(&rsa_buf), out));

    /* Encrypt the rest of the data with the AES algorithm. */
    RETHROW_PN(ssl_ctx_init_aes256_by_key(&actx, key, iv));
    if (ssl_encrypt_update(&actx, data, out) < 0) {
        goto error;
    }
    if (ssl_encrypt_reset(&actx, out) < 0) {
        goto error;
    }

    ssl_ctx_wipe(&actx);
    return 0;

  error:
    ssl_ctx_wipe(&actx);
    return -1;
}

/* }}} */
/* {{{ Decrypt */

static int ssl_decrypt_pkey(ssl_ctx_t *ctx, lstr_t data, sb_t *out)
{
    size_t outlen;
    size_t inlen = data.len;
    const unsigned char *in = data.data;

    if (!ctx->pkey
    ||  !ctx->pkey_decrypt
    ||  ctx->decrypt_state != SSL_CTX_INIT)
    {
        __ssl_set_error("invalid decrypt context state");
        return -1;
    }

    if (EVP_PKEY_decrypt(ctx->pkey_decrypt, NULL, &outlen, in, inlen) <= 0)
    {
        ssl_set_error("decryption failure (size computation)");
        return -1;
    }
    if (EVP_PKEY_decrypt(ctx->pkey_decrypt,
                         (unsigned char *)sb_grow(out, outlen),
                         &outlen, in, inlen) <= 0)
    {
        ssl_set_error("decryption failure");
        return -1;
    }
    sb_growlen(out, outlen);
    return 0;
}

/* See t_ssl_encrypt_pkey_lstr for encoding informations. */
int ssl_decrypt_pkey_sb(ssl_ctx_t *ctx, lstr_t data, sb_t *out)
{
    ssl_ctx_t actx;
    lstr_t rsa_enc;
    lstr_t key;
    lstr_t iv;
    lstr_t aes_enc;
    int key_size = ssl_pkey_size(ctx);
    SB_1k(rsa_buf);

    /* If the data are small enough, decrypt them directly. */
    if (data.len == key_size) {
        return ssl_decrypt_pkey(ctx, data, out);
    }

    if (data.len < key_size) {
        __ssl_set_error("invalid encrypted content (invalid size)");
        return -1;
    }

    /* Separate the RSA header and the AES encrypted data. */
    rsa_enc = LSTR_INIT_V(data.s, key_size);
    aes_enc = LSTR_INIT_V(data.s + key_size, data.len - key_size);

    /* Extract RSA header (get the AES key and IV, and the first data). */
    RETHROW(ssl_decrypt_pkey(ctx, rsa_enc, &rsa_buf));
    if (rsa_buf.len < 32 + 16) {
        __ssl_set_error("invalid AES key or IV in the rsa header");
        return -1;
    }
    key = LSTR_INIT_V(rsa_buf.data, 32);
    iv = LSTR_INIT_V(rsa_buf.data + 32, 16);
    sb_add(out, rsa_buf.data + 32 + 16, rsa_buf.len - 32 - 16);

    /* Decrypt the data with the AES algorithm. */
    RETHROW_PN(ssl_ctx_init_aes256_by_key(&actx, key, iv));
    if (ssl_decrypt_update(&actx, aes_enc, out) < 0) {
        goto error;
    }
    if (ssl_decrypt_reset(&actx, out) < 0) {
        goto error;
    }

    ssl_ctx_wipe(&actx);
    return 0;

  error:
    ssl_ctx_wipe(&actx);
    return -1;
}

/* }}} */
/* }}} */
/* {{{ Signature */

typedef struct rsa_ctx_t {
    BIO *keybio;
    EVP_PKEY *key;
    EVP_MD_CTX *digest;
} rsa_ctx_t;

static void rsa_ctx_wipe(rsa_ctx_t *sg)
{
    if (sg->digest) {
        EVP_MD_CTX_destroy(sg->digest);
    }
    if (sg->key) {
        EVP_PKEY_free(sg->key);
    }
    if (sg->keybio) {
        BIO_free(sg->keybio);
    }
}

static const EVP_MD *from_rsa_algo(rsa_hash_algo_t algo)
{
    switch (algo) {
      case RSA_HASH_SHA256:
        return EVP_sha256();

      default:
        e_panic("unsupported algorithm");
    }
}

static int pem_password_blk_cb(char *buf, int size, int rwflags, void *u)
{
    pem_password_b blk = u;

    return blk(buf, size, rwflags);
}

/* {{{ Signature */

struct rsa_sign_t {
    rsa_ctx_t ctx;
};

static void rsa_sign_wipe(rsa_sign_t *sg)
{
    rsa_ctx_wipe(&sg->ctx);
}

GENERIC_DELETE(rsa_sign_t, rsa_sign);

rsa_sign_t *rsa_sign_new(lstr_t priv_key, rsa_hash_algo_t algo,
                         pem_password_b pass_cb)
{
    rsa_sign_t *sg;

    sg = p_new(rsa_sign_t, 1);
    sg->ctx.keybio = BIO_new_mem_buf(priv_key.v, priv_key.len);
    if (!sg->ctx.keybio) {
        goto error;
    }

    /* TODO add callback to read passphrase */
    sg->ctx.key = PEM_read_bio_PrivateKey(sg->ctx.keybio, NULL,
                                          pass_cb ? &pem_password_blk_cb : NULL,
                                          pass_cb);
    if (!sg->ctx.key) {
        goto error;
    }

    sg->ctx.digest = EVP_MD_CTX_create();
    if (!sg->ctx.digest) {
        goto error;
    }

    if (EVP_DigestSignInit(sg->ctx.digest, NULL, from_rsa_algo(algo),
                           NULL, sg->ctx.key) <= 0)
    {
        goto error;
    }

    return sg;

  error:
    rsa_sign_delete(&sg);
    return NULL;
}

void rsa_sign_update(rsa_sign_t *ctx, const void *input, ssize_t ilen)
{
    if (EVP_DigestSignUpdate(ctx->ctx.digest, input, ilen) <= 0) {
        e_error("failed to update signature");
    }
}

int rsa_sign_finish(rsa_sign_t **pctx, sb_t *out)
{
    size_t len;
    rsa_sign_t *ctx = *pctx;

    if (EVP_DigestSignFinal(ctx->ctx.digest, NULL, &len) <= 0) {
        rsa_sign_delete(pctx);
        return -1;
    }

    sb_grow(out, len);
    if (EVP_DigestSignFinal(ctx->ctx.digest, (byte *)sb_end(out), &len) <= 0) {
        rsa_sign_delete(pctx);
        return -1;
    }

    __sb_fixlen(out, out->len + len);
    rsa_sign_delete(pctx);
    return 0;
}

int rsa_sign_finish_hex(rsa_sign_t **pctx, sb_t *out)
{
    SB_1k(bin);

    RETHROW(rsa_sign_finish(pctx, &bin));
    sb_add_hex(out, bin.data, bin.len);
    return 0;
}

/* }}} */
/* {{{ Verification */

struct rsa_verif_t {
    rsa_ctx_t ctx;
    lstr_t sig;
};

static void rsa_verif_wipe(rsa_verif_t *sg)
{
    rsa_ctx_wipe(&sg->ctx);
    lstr_wipe(&sg->sig);
}

GENERIC_DELETE(rsa_verif_t, rsa_verif);

rsa_verif_t *rsa_verif_new(lstr_t pub_key, rsa_hash_algo_t algo,
                           lstr_t bin_sig, pem_password_b pass_cb)
{
    rsa_verif_t *sg;

    sg = p_new(rsa_verif_t, 1);
    sg->ctx.keybio = BIO_new_mem_buf(pub_key.v, pub_key.len);
    if (!sg->ctx.keybio) {
        goto error;
    }

    /* TODO add callback to read passphrase */
    sg->ctx.key = PEM_read_bio_PUBKEY(sg->ctx.keybio, NULL,
                                      pass_cb ? pem_password_blk_cb : NULL,
                                      pass_cb);
    if (!sg->ctx.key) {
        goto error;
    }

    sg->ctx.digest = EVP_MD_CTX_create();
    if (!sg->ctx.digest) {
        goto error;
    }

    if (EVP_DigestVerifyInit(sg->ctx.digest, NULL, from_rsa_algo(algo),
                             NULL, sg->ctx.key) <= 0)
    {
        goto error;
    }

    sg->sig = lstr_dup(bin_sig);
    return sg;

  error:
    rsa_verif_delete(&sg);
    return NULL;
}

rsa_verif_t *rsa_verif_hex_new(lstr_t pub_key, rsa_hash_algo_t algo,
                               lstr_t hex_sig, pem_password_b pass_cb)
{
    SB_1k(bin);

    RETHROW_NP(sb_add_lstr_unhex(&bin, hex_sig));
    return rsa_verif_new(pub_key, algo, LSTR_SB_V(&bin), pass_cb);
}

void rsa_verif_update(rsa_verif_t *ctx, const void *input, ssize_t ilen)
{
    if (EVP_DigestVerifyUpdate(ctx->ctx.digest, input, ilen) <= 0) {
        e_error("failed to verify signature");
    }
}

int rsa_verif_finish(rsa_verif_t **pctx)
{
    int res;
    rsa_verif_t *ctx = *pctx;

    res = EVP_DigestVerifyFinal(ctx->ctx.digest, ctx->sig.data, ctx->sig.len);
    rsa_verif_delete(pctx);

    if (res > 0) {
        return 1;
    }
    return -1;
}

/* }}} */

/* }}} */
/* {{{ TLS */

X509 *ssl_ctx_convert_certificate_lstr(lstr_t cert)
{
    BIO *bio;
    X509 *x;

    bio = RETHROW_P(BIO_new_mem_buf(cert.v, cert.len));
    x = PEM_read_bio_X509(bio, NULL, 0, NULL);

    BIO_free(bio);
    return x;
}

static int ssl_ctx_use_certificate_lstr(SSL_CTX *ctx, lstr_t cert)
{
    X509 *x = ssl_ctx_convert_certificate_lstr(cert);
    int ret;

    ret = SSL_CTX_use_certificate(ctx, x);

    X509_free(x);
    return ret == 1 ? 0 : -1;
}

static int ssl_ctx_use_privatekey_lstr(SSL_CTX *ctx, lstr_t key)
{
    BIO *bio;
    EVP_PKEY *evp;
    int ret;

    bio = RETHROW_PN(BIO_new_mem_buf(key.v, key.len));
    evp = PEM_read_bio_PrivateKey(bio, NULL, 0, NULL);
    if (unlikely(!evp)) {
        BIO_free(bio);
        return -1;
    }
    ret = SSL_CTX_use_PrivateKey(ctx, evp);

    EVP_PKEY_free(evp);
    BIO_free(bio);
    return ret == 1 ? 0 : -1;
}

SSL_CTX *ssl_ctx_new_tls(const SSL_METHOD *method, lstr_t key, lstr_t cert,
                         int verify_mode, SSL_verify_cb verify_callback,
                         sb_t *err)
{
    SSL_CTX *ctx;
    long     mode;

    assert ((cert.s && key.s) || (!cert.s && !key.s));

    /* Create TLS context -- the ssl module must be loaded. */
    ctx = SSL_CTX_new(method);
    if (ctx == NULL) {
        sb_adds(err, "failed to create SSL context");
        return NULL;
    }

    /* Configure TLS context. */
    SSL_CTX_set_ecdh_auto(ctx, 1);

    /* Ignore unexpected EOF for OpenSSL >= 3.
     * See https://www.openssl.org/docs/man3.0/man3/SSL_CTX_set_options.html#SSL_OP_IGNORE_UNEXPECTED_EOF
     */
#if OPENSSL_VERSION_IS(>=,3,0,0)
    SSL_CTX_set_options(ctx, SSL_OP_IGNORE_UNEXPECTED_EOF);
#endif /* OpenSSL >= 3 */

    if (cert.s && key.s) {
        if (ssl_ctx_use_certificate_lstr(ctx, cert) < 0) {
            sb_adds(err, "failed to load certificate");
            goto error;
        }
        if (ssl_ctx_use_privatekey_lstr(ctx, key) < 0) {
            sb_adds(err, "failed to load private key");
            goto error;
        }

        if (SSL_CTX_check_private_key(ctx) != 1) {
            sb_adds(err, "consistency of certificate / key is wrong");
            goto error;
        }
    }

    if (verify_mode != SSL_VERIFY_NONE) {
        SSL_CTX_set_verify(ctx, verify_mode, verify_callback);
    }

    mode = SSL_MODE_ENABLE_PARTIAL_WRITE
         | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;
    if (!(SSL_CTX_set_mode(ctx, mode) & mode)) {
        sb_adds(err, "failed to set partial write mode");
        goto error;
    }

    return ctx;

  error:
    SSL_CTX_free(ctx);
    return NULL;
}

static inline int ssl_error_conv(int ssl_error)
{
    switch (ssl_error) {
      case SSL_ERROR_ZERO_RETURN:
        /* Graceful exit. */
        return 0;
      case SSL_ERROR_WANT_READ:
      case SSL_ERROR_WANT_WRITE:
        errno = EAGAIN;
        return -1;
      case SSL_ERROR_SSL:
        break;
      case SSL_ERROR_SYSCALL:
        return -1;
      default:
        assert(false);
        break;
    }

    e_error("unexpected ssl error: %s",
            ERR_error_string(ERR_peek_error(), NULL));
    errno = EIO;
    return -1;
}

/** Helper to convert openssl errors to classical system errors.
 *
 * \param[in]  ssl  The ssl context on which the operation has been called.
 * \param[in]  ret  The return code of the operation.
 * \return ret if ret > 0, 0 on graceful exit, and -1 on error, with errno set
 *         to an appropriate value.
 */
static int ssl_get_error_conv(SSL *ssl, int ret)
{
    return ret > 0 ? ret : ssl_error_conv(SSL_get_error(ssl, ret));
}

static void ssl_change_rbio(SSL *ssl, int fd, sb_t *rbuf)
{
    BIO *rbio_null = SSL_get_rbio(ssl);
    BIO *rbio_next = BIO_next(rbio_null);

    /* The previous read was done in our read buffer and trailing
     * data were the beginning of the TLS handshake. Now that SSL
     * has read these data, fall back on directly reading from the
     * socket. */
    if (BIO_method_type(rbio_null) == BIO_TYPE_NULL_FILTER
    &&  BIO_method_type(rbio_next) == BIO_TYPE_MEM)
    {
        BIO *rbio_fd = BIO_new_fd(fd, BIO_NOCLOSE);

        BIO_free(BIO_pop(rbio_null));
        BIO_push(rbio_null, rbio_fd);
        sb_reset(rbuf);
    }
}

ssl_handshake_status_t
ssl_do_handshake(SSL *ssl, el_t ev, int fd, sb_t *rbuf)
{
    int ret;
    int ssl_error;

    ret = SSL_do_handshake(ssl);
    if (ret > 0) {
        /* Handshake completed. */
        return SSL_HANDSHAKE_SUCCESS;
    }
    if (ret == 0) {
        /* Cleanly closed with respect to the TLS protocol. */
        return SSL_HANDSHAKE_CLOSED;
    }

    errno = 0;
    ssl_error = SSL_get_error(ssl, ret);
    switch (ssl_error) {
      case SSL_ERROR_WANT_READ:
        if (unlikely(!ev)) {
            /* This may happen if we add a timeout on the socket. */
            errno = ETIMEDOUT;
            return SSL_HANDSHAKE_ERROR;
        }
        if (rbuf) {
            ssl_change_rbio(ssl, fd, rbuf);
        }
        el_fd_set_mask(ev, POLLIN);
        return SSL_HANDSHAKE_PENDING;
      case SSL_ERROR_WANT_WRITE:
        el_fd_set_mask(ev, POLLOUT);
        return SSL_HANDSHAKE_PENDING;
      default:
        ssl_error_conv(ssl_error);
        break;
    }

    return SSL_HANDSHAKE_ERROR;
}

ssize_t ssl_read(SSL *ssl, void *buf, size_t len)
{
    if (!expect(len > 0)) {
        return 0;
    }

    return ssl_get_error_conv(ssl, SSL_read(ssl, buf, len));
}

ssize_t ssl_write(SSL *ssl, const void *buf, size_t len)
{
    long expected_mode;

    if (!expect(len > 0)) {
        /* SSL_write with 0 length is undefined. */
        return 0;
    }

    expected_mode = SSL_MODE_ENABLE_PARTIAL_WRITE
                  | SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER;
    if (!expect((SSL_get_mode(ssl) & expected_mode) == expected_mode)) {
        errno = EINVAL;
        return -1;
    }

    return ssl_get_error_conv(ssl, SSL_write(ssl, buf, len));
}

/* This function sends `len` data from `buf` through the `ssl` connection. It
 * returns 0 if all data have been sent, and -1 in all other cases. If all or
 * some (partial write) data are sent, `total_wr` is increased by the number
 * of bytes sent.
 *
 * This function assumes that `ssl` is configured to allow partial write.
 */
static int ssl_write_chunk(SSL *ssl, const char *buf, int len, int *total_wr)
{
    int wr;

    wr = ssl_write(ssl, buf, len);
    if (wr <= 0) {
        return -1;
    }
    *total_wr += wr;
    if (wr != len) {
        /* Its unlikely that the system could absorb more data for now. */
        errno = EAGAIN;
        return -1;
    }
    return 0;
}

ssize_t ssl_writev(int fd, const struct iovec *iov, int iovcnt, void *priv)
{
    SSL *ssl = priv;
    char buf[BUFSIZ];
    int buflen = 0;
    int bufrest = BUFSIZ;
    int total_wr = 0;

    for (int i = 0; i < iovcnt; i++) {
        const char *base = iov[i].iov_base;
        int len = iov[i].iov_len;

        while (len > 0) {
            if (buflen == 0 && len > BUFSIZ) {
                /* The iov buffer is large enougth to be directly written. */
                if (ssl_write_chunk(ssl, base, len, &total_wr) < 0) {
                    goto end;
                }
                break;
            }
            if (len <= bufrest) {
                /* The iov fits entirely in buf. */
                memcpy(buf + buflen, base, len);
                buflen += len;
                bufrest -= len;
                break;
            }
            /* Append as many data as we can in buf and send everything. */
            memcpy(buf + buflen, base, bufrest);
            base += bufrest;
            len -= bufrest;

            if (ssl_write_chunk(ssl, buf, BUFSIZ, &total_wr) < 0) {
                goto end;
            }
            buflen = 0;
            bufrest = BUFSIZ;
        }
    }

    /* Send the rest. */
    if (buflen > 0) {
        ssl_write_chunk(ssl, buf, buflen, &total_wr);
    }
  end:
    return total_wr > 0 ? total_wr : -1;
}

static ssize_t __ssl_sb_read(sb_t *sb, const sb_t *orig, SSL *ssl, int len)
{
    char *buf;
    ssize_t res;

    buf = sb_grow(sb, len);
    res = ssl_read(ssl, buf, len);

    if (res < 0) {
        return __sb_rewind_adds(sb, orig);
    }

    __sb_fixlen(sb, sb->len + res);
    return res;
}

ssize_t ssl_sb_read(sb_t *sb, SSL *ssl, int hint)
{
    sb_t orig = *sb;
    int nb_pending;

    /* First read the wanted size. */
    RETHROW(__ssl_sb_read(sb, &orig, ssl, hint <= 0 ? BUFSIZ : hint));

    /* Then check if there are bufferized data in the SSL context; if so then
     * we MUST read them now because the socket might have been entirely read
     * by openssl, and otherwise we could end-up in the deadlock described in
     * the documentation of ssl_read.
     */
    while ((nb_pending = SSL_pending(ssl)) > 0) {
        ssize_t res = RETHROW(__ssl_sb_read(sb, &orig, ssl, nb_pending));

        if (res == 0) {
            break;
        }
    }

    return sb->len - orig.len;
}

/* }}} */
/* {{{ Tests */

Z_GROUP_EXPORT(ssl)
{
    MODULE_REQUIRE(ssl);

/* {{{ AES */

    Z_TEST(aes, "aes") {
        ssl_ctx_t ctx;
        const lstr_t text = LSTR("Encrypt me");
        const lstr_t res  = LSTR("\x12\x29\xB4\x7E\x75\xE1\x33\x64"
                                  "\x49\x09\x77\xF8\xE8\x08\x2C\x58");
        const lstr_t text2 = LSTR("abcdefghijklmnopqrstuvwxyz0123456789");
        sb_t sb, sb_dec;

        Z_ASSERT_P(ssl_ctx_init_aes256(&ctx, LSTR("plop"), 42, 1024));

        sb_init(&sb);
        Z_ASSERT_N(ssl_encrypt(&ctx, text, &sb));
        Z_ASSERT_LSTREQUAL(res, LSTR_SB_V(&sb));

        sb_init(&sb_dec);
        Z_ASSERT_N(ssl_decrypt(&ctx, res, &sb_dec));
        Z_ASSERT_LSTREQUAL(text, LSTR_SB_V(&sb_dec));

        Z_ASSERT_EQ(EVP_CIPHER_CTX_block_size(ctx.encrypt), 16);
        Z_ASSERT_EQ(EVP_CIPHER_CTX_block_size(ctx.decrypt), 16);
        Z_ASSERT_EQ(text2.len, 36);
        /* Non regression of #11267: check that encrypt with empty content do
         * not abort with openssl < v1.0 with i=0 */
        for (int i = 0; i < text2.len; i++) {
            lstr_t t = LSTR_INIT_V(text2.data, i);

            sb_wipe(&sb);
            Z_ASSERT_N(ssl_encrypt(&ctx, t, &sb));
            Z_ASSERT_EQ(sb.len, ROUND_UP(i + 1, 16));

            sb_wipe(&sb_dec);
            Z_ASSERT_N(ssl_decrypt(&ctx, LSTR_SB_V(&sb), &sb_dec));
            Z_ASSERT_LSTREQUAL(LSTR_SB_V(&sb_dec), t);
        }

        sb_wipe(&sb);
        sb_wipe(&sb_dec);
        ssl_ctx_wipe(&ctx);
    } Z_TEST_END;

    Z_TEST(decrypt_aes, "decrypt_aes") {
        ssl_ctx_t ctx;
        const lstr_t text = LSTR_IMMED("\x12\x29\xB4\x7E\x75\xE1\x33\x64"
                                       "\x49\x09\x77\xF8\xE8\x08\x2C\x58");
        SB_1k(sb);

        Z_ASSERT_P(ssl_ctx_init_aes256(&ctx, LSTR("plop"), 42, 1024));

        Z_ASSERT_N(ssl_decrypt(&ctx, text, &sb));

        Z_ASSERT_LSTREQUAL(LSTR("Encrypt me"), LSTR_SB_V(&sb));

        ssl_ctx_wipe(&ctx);
    } Z_TEST_END;

/* }}} */
/* {{{ PKEY */

    {
        /* To generate such test data, you can:
         * $ openssl genpkey -algorithm RSA -out priv.pem -pkeyopt
         *   rsa_keygen_bits:2048
         * $ openssl pkey -in priv.pem -pubout -out pub.pem
         * $ echo 'secret pioupiou23' > a
         * $ openssl pkeyutl -encrypt -pubin -inkey pub.pem -in a -hexdump
         */
        t_scope;
        SB_1k(priv);
        SB_1k(priv_encrypted);
        SB_1k(pub);
        SB_1k(text_rand);
        const lstr_t text = LSTR_IMMED("secret pioupiou23\n");
        const lstr_t text_garbage = LSTR_IMMED("bonjour openssl!\n");

        z_load_keys(t_lstr_fmt("%pL/..", &z_cmddir_g), &priv,
                    &priv_encrypted, &pub);
        strrand(sb_growlen(&text_rand, 1024), 1024, LSTR_NULL_V);

/* {{{ PKEY */

    Z_TEST(pkey, "pkey") {
        ssl_ctx_t ctx;
        const lstr_t text_encrypted = LSTR_IMMED(
          "\x00\xee\x73\x51\xe4\xf7\x7d\x47\xd8\xd4\xbd\x4d\xfa\x61\xd9\xad"
          "\x71\xcc\x6e\x9f\x18\x99\xfe\xed\xfa\x8e\x68\x1a\xa2\x8b\xac\x54"
          "\xa4\xa0\x8a\x0c\x37\x3e\xfe\x6f\x49\xf3\xf5\xb0\x4f\x56\x14\xa1"
          "\x99\xb0\x7b\x6d\x29\x59\xd0\x43\x1b\x04\xef\x02\x7f\xea\x56\xe3"
          "\xb0\xf1\x36\x9b\x79\x9b\x44\x92\x39\xe9\x3c\xc6\xd5\x26\xb8\x39"
          "\x38\xd9\x7d\xaa\xa9\xa9\xda\xe6\x2b\x28\xa7\x0c\xa5\xf6\x70\x73"
          "\x10\x6c\x03\x5e\xc6\x6a\x84\x4d\x29\x76\x27\x2e\xc4\x0c\x8f\xae"
          "\x82\x2c\xd5\x41\x81\x3e\xf1\xc4\xcf\x1f\x3c\x04\x9f\x07\xd5\xed"
          "\xf9\x43\xe9\x42\x15\x0c\xa2\x63\xc9\x95\x7e\x78\xd4\x7b\x1b\x5f"
          "\xc2\xa1\xdd\xeb\xad\x1c\x1e\xf7\xeb\xee\xd8\x5b\xa8\x26\x7e\x8d"
          "\x72\x0c\x54\x83\xb1\xa3\xc8\x7e\xb9\x67\x61\x43\x40\xd0\x44\x30"
          "\x0e\x8e\xc3\x7e\xd0\x55\x11\x08\x44\x59\xac\x2a\x47\xa6\x45\xf0"
          "\x45\x43\xc5\x1e\xc9\xb6\xac\x25\xf7\x70\x76\x26\x70\x05\x6a\x5c"
          "\x55\xf5\x9a\x87\x51\xd2\xd2\x99\x4f\x73\x21\xe5\xf5\xad\x33\xa0"
          "\x26\xc9\x9f\xf2\xbc\x07\x8c\x5c\xe9\x45\x6c\x44\x7e\xc2\xa5\xa1"
          "\x15\x1a\x9c\x43\x04\x6e\x98\xaa\x34\xf5\x9c\x08\x83\x13\x82\x05");
        SB_1k(sb_encrypted);
        SB_1k(sb_clear);

        Z_ASSERT_NULL(ssl_ctx_init_pkey_pub(&ctx, LSTR_EMPTY_V));
        Z_ASSERT_NULL(ssl_ctx_init_pkey_priv(&ctx, LSTR_EMPTY_V,
                                             LSTR_EMPTY_V));

        /* Use a public key: we can encrypt but we cannot decrypt. */
        Z_ASSERT_P(ssl_ctx_init_pkey_pub(&ctx, LSTR_SB_V(&pub)));
        Z_ASSERT_N(ssl_encrypt(&ctx, text, &sb_encrypted));
        Z_ASSERT_NEG(ssl_decrypt(&ctx, LSTR_SB_V(&sb_encrypted), &sb_clear));
        ssl_ctx_wipe(&ctx);

        /* The corresponding private key can decrypt. */
        Z_ASSERT_P(ssl_ctx_init_pkey_priv(&ctx, LSTR_SB_V(&priv),
                                          LSTR_EMPTY_V));
        Z_ASSERT_N(ssl_decrypt(&ctx, LSTR_SB_V(&sb_encrypted), &sb_clear));
        Z_ASSERT_LSTREQUAL(text, LSTR_SB_V(&sb_clear));
        sb_reset(&sb_clear);

        Z_ASSERT_N(ssl_decrypt(&ctx, text_encrypted, &sb_clear));
        Z_ASSERT_LSTREQUAL(text, LSTR_SB_V(&sb_clear));
        sb_reset(&sb_clear);

        Z_ASSERT_NEG(ssl_decrypt(&ctx, text_garbage, &sb_clear));
        ssl_ctx_wipe(&ctx);

        /* It's also possible to encrypt with the private key. */
        sb_reset(&sb_encrypted);
        sb_reset(&sb_clear);
        Z_ASSERT_P(ssl_ctx_init_pkey_priv(&ctx, LSTR_SB_V(&priv),
                                          LSTR_EMPTY_V));
        Z_ASSERT_N(ssl_encrypt(&ctx, text, &sb_encrypted));
        Z_ASSERT_N(ssl_decrypt(&ctx, LSTR_SB_V(&sb_encrypted), &sb_clear));
        Z_ASSERT_LSTREQUAL(text, LSTR_SB_V(&sb_clear));
        ssl_ctx_wipe(&ctx);

        /* Test lstr encryption / decryption of long strings. */
        Z_ASSERT_P(ssl_ctx_init_pkey_priv(&ctx, LSTR_SB_V(&priv),
                                          LSTR_EMPTY_V));
        {
            t_scope;
            lstr_t clear;
            lstr_t encrypted;
            int msg_len = 256 - RSA_OAEP_PADDING_SIZE + 1;
            lstr_t init = LSTR_INIT(text_rand.data, msg_len);

            encrypted = t_ssl_encrypt_pkey_lstr(&ctx, init);
            Z_ASSERT(encrypted.len > 256);
            clear = t_ssl_decrypt_pkey_lstr(&ctx, encrypted);
            Z_ASSERT_LSTREQUAL(init, clear);
        }

        /* With small strings, it should behave just as ssl_encrypt_pkey. */
        {
            t_scope;
            lstr_t clear;
            lstr_t encrypted;
            int msg_len = 256 - RSA_OAEP_PADDING_SIZE;
            lstr_t init = LSTR_INIT(text_rand.data, msg_len);

            sb_reset(&sb_encrypted);
            sb_reset(&sb_clear);
            /* Encryption */
            encrypted = t_ssl_encrypt_pkey_lstr(&ctx, init);
            Z_ASSERT_EQ(encrypted.len, 256);
            Z_ASSERT_N(ssl_encrypt_pkey(&ctx, init, &sb_encrypted));
            Z_ASSERT_EQ(sb_encrypted.len, 256);
            /* Decryption */
            clear = t_ssl_decrypt_pkey_lstr(&ctx, LSTR_SB_V(&sb_encrypted));
            Z_ASSERT_LSTREQUAL(init, clear);
            Z_ASSERT_N(ssl_decrypt_pkey(&ctx, encrypted, &sb_clear));
            Z_ASSERT_LSTREQUAL(init, LSTR_SB_V(&sb_clear));
        }
        ssl_ctx_wipe(&ctx);
    } Z_TEST_END;

/* }}} */
/* {{{ PKEY for RSA with OAEP */

    Z_TEST(pkey_rsa_with_oaep, "pkey_rsa_with_oaep") {
        ssl_ctx_t ctx;
        /* same but encrypt with -pkeyopt rsa_padding_mode:oaep */
        const lstr_t text_encrypted = LSTR_IMMED(
          "\x18\x55\xef\x38\xf8\x54\x18\x13\x2e\xc1\x10\x43\xbf\xeb\x53\xb7"
          "\xeb\x6a\x6a\x8c\x26\xe8\xac\x1f\x09\xc5\x26\xfc\x6c\x15\x8d\x39"
          "\xc4\xd8\xc4\xf5\x55\x83\x02\xdb\xf7\x05\xe1\x3e\x0b\x9e\x44\xc8"
          "\x95\x9e\x4b\x86\x27\xfc\x3f\x8e\x2d\x6d\x6d\xed\x94\x51\x47\x56"
          "\x48\xff\x35\x3e\x11\x91\xf7\x57\x0d\xef\xce\xb4\x3e\x2d\xf7\x6f"
          "\x08\x44\x92\xa3\xcd\x13\xc4\xb7\x09\x9b\x07\x95\x69\xf6\x3a\x0c"
          "\x2b\x5b\x78\x9a\xe4\x3e\xe4\x52\x66\xd5\x71\xe2\xd9\x70\xdb\x78"
          "\x21\xa0\xfe\x18\xce\x7b\x74\x34\x71\xc0\x46\x73\xcd\x27\x8d\xe7"
          "\x5d\xd0\xee\x9c\xc0\x50\x39\x2c\x50\x3b\x67\x14\x56\xdd\x73\xa5"
          "\x12\xd5\x47\x59\x00\x94\x34\xcf\xb3\x6a\x45\x27\x19\x0e\x4c\x06"
          "\x37\xd1\xcc\xf0\x2c\x4c\x4d\x54\x8a\x88\x57\xe7\x9a\xcd\x06\x3a"
          "\x26\x31\xc7\xc9\x24\x4c\x68\x80\xd7\xaf\x69\xcf\x03\x4b\x46\xa9"
          "\x53\x0f\x70\x6b\xd5\x9d\x0e\x3b\x70\xa8\x45\xb8\x37\x8c\x2a\x6f"
          "\x6e\xb7\xc5\x5d\xf0\x4a\x79\xf4\x67\x66\x0e\x4f\xf7\x56\xb0\x71"
          "\x89\xbc\x31\x38\xa2\xa2\x18\x66\xd5\xc8\x52\x21\xb2\xca\x73\x0b"
          "\xa8\x4c\xab\xe6\x16\x4d\x2d\xd7\x83\xa5\xd3\x07\x83\xa2\x0c\x38");
        SB_1k(sb_encrypted);
        SB_1k(sb_clear);

        Z_ASSERT_P(ssl_ctx_init_pkey_pub(&ctx, LSTR_SB_V(&pub)));
        Z_ASSERT_GT(EVP_PKEY_CTX_set_rsa_padding(ctx.pkey_encrypt,
                                                 RSA_PKCS1_OAEP_PADDING), 0);
        Z_ASSERT_N(ssl_encrypt(&ctx, text, &sb_encrypted));
        ssl_ctx_wipe(&ctx);

        Z_ASSERT_P(ssl_ctx_init_pkey_priv(&ctx, LSTR_SB_V(&priv),
                                          LSTR_EMPTY_V));
        Z_ASSERT_GT(EVP_PKEY_CTX_set_rsa_padding(ctx.pkey_decrypt,
                                                 RSA_PKCS1_OAEP_PADDING), 0);
        Z_ASSERT_N(ssl_decrypt(&ctx, LSTR_SB_V(&sb_encrypted), &sb_clear));
        Z_ASSERT_LSTREQUAL(text, LSTR_SB_V(&sb_clear));
        sb_reset(&sb_clear);

        Z_ASSERT_N(ssl_decrypt(&ctx, text_encrypted, &sb_clear));
        Z_ASSERT_LSTREQUAL(text, LSTR_SB_V(&sb_clear));
        ssl_ctx_wipe(&ctx);
    } Z_TEST_END;

/* }}} */
/* {{{ PKEY with passphrase */

    Z_TEST(pkey_with_passphrase, "pkey_with_passphrase") {
        ssl_ctx_t ctx;
        /* same but genpkey with -pass:this-is-a-complicated-pass-phrase */
        const lstr_t priv_with_pass  = LSTR_IMMED(
          "-----BEGIN PRIVATE KEY-----\n"
          "MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQCjamGL98i7M/WD\n"
          "Bvbr7wXoQYyjoCV/cTnbNKZNlJBMZ5qzYzSa5ZIdznzgfxjytXNPZ0egcqotDPye\n"
          "QAB9f3URJ0cz9yuUwxxg2y0yQWJQcPlkyTAC5stxuMfHHMVforyry47LtYlGYnCk\n"
          "X+1R8h5gqylb9vcVoTgO9195sEM6jrPniG1myFeWnpTaIxb1Of4z1HntRCNlfKb6\n"
          "z0FKOAYM7iDhFx0DeH6plrngRihGLxWxWH7RxuLDEJtrv0fVb54pJCKeSnSmoz5W\n"
          "W264jrKwuPRMdAE5rBbGFUc339XIcO2aL9P+dE9tqjxD2Oqq+48n+8P0Y+ikM2WW\n"
          "J40L1xcnAgMBAAECggEBAIec+fTBHckVVpJ1Dic/xgQ3mbIUben0GdJrP/Oz7Ygq\n"
          "lnx2QKqnB3pK6OEZOKf6owXrLMrfPZCDbYUakg2T35/rm7BpV7ZtsLhES56gGimt\n"
          "h5n3SCuwQndOpCP+IWG7WJ2tIQS204Qgn2AZ54WQy1rn0DvsmKJPl4j8CzSebTxC\n"
          "6uNOr8djWoAtyfN1M0R5d5nGF1qNRlsbd8fSduUn+3knvmPyLWzP2SVeQv/9M8eP\n"
          "Q4+3jR3mYucrIhLgAHQVhNzHhzgKc0o0XpMjTBXq20k4+sfVrU/npDBuYHgWribT\n"
          "ytG7dJ5cW/ggCkFgY4m8kRVOhswQQZRIww8ZF69XVAkCgYEA13h5E63QF35RWCUe\n"
          "1PNSeM+3x2HoQXehZ7jlpYzEj/xi8jWYGDI4ObotCyYtb73c0vuXYP8Mx2bGQTyQ\n"
          "pI0pvHG/QtMi4LaoMekXpi62ArSExdJvlC+8G2jbQlPfRBrtGoSXZ2SSysINV4Un\n"
          "Bq0gU8+QWdoCqK/F4ex6/A8joC0CgYEAwidO7+FjX3qPInbg863+amP6H7YBkwdK\n"
          "ComhzeZSkgOhn2xK4dvGTmP8EZd8KE5kWVsAsxSJuXddbu/9gSkrUMuvIcdHD74k\n"
          "+/ucKAdMQL+xqmdRo5S0dhqPAmEt/sipF3JLPeTyyWUk62dCWo+ABmWYqZVruX8g\n"
          "qBwcMa12lSMCgYEAifssDd4Qk/rgPIII7HWlKphaJ+Qax1HEmpdc+FbcyRfmhRSt\n"
          "AVGnj9AZaDpafmQnNTTIC+VIWakG7F/MgJOlVnfA8xoiC6TssImEC3d+Nt1C6SuJ\n"
          "KGwpGaRcRG1RXFuh2oluK1fMaOs7gABUrYHQYdtZpTBm438sSTEW0LMhLUECgYAg\n"
          "pxfBhDiAQE5+T1v535NgNTxFxQhyv9EWAJuz0z6jy/SMqVvWrG2nlW05UC7TYIvD\n"
          "82gkthmLlaWjGL2b0V61kev8VFWBMktqDaDvonqSkSrCK+oxBrtq+YB/t/RSW1EE\n"
          "3nYFDNJASMByzsT8EhJIASIxsy2Q3u6RF1kuiavd3QKBgGz1vuYpA3XhRyJx1yso\n"
          "P90D4aUZ4ohf16QvO6dKZgKqiwZouaBpv1tRhT0eDlxwCQM8K2g88V/xryXkXtfC\n"
          "E17Do7mq0S4BMCCCBoY5RqA/OuBeI+zNDdpA9ALjUS/YktIwbRa4JznsijDNq/Fa\n"
          "9T68azojUwhORQWsfP+KKqfv\n"
          "-----END PRIVATE KEY-----\n");
        const lstr_t pub_with_pass  = LSTR_IMMED(
          "-----BEGIN PUBLIC KEY-----\n"
          "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAo2phi/fIuzP1gwb26+8F\n"
          "6EGMo6Alf3E52zSmTZSQTGeas2M0muWSHc584H8Y8rVzT2dHoHKqLQz8nkAAfX91\n"
          "ESdHM/crlMMcYNstMkFiUHD5ZMkwAubLcbjHxxzFX6K8q8uOy7WJRmJwpF/tUfIe\n"
          "YKspW/b3FaE4DvdfebBDOo6z54htZshXlp6U2iMW9Tn+M9R57UQjZXym+s9BSjgG\n"
          "DO4g4RcdA3h+qZa54EYoRi8VsVh+0cbiwxCba79H1W+eKSQinkp0pqM+VltuuI6y\n"
          "sLj0THQBOawWxhVHN9/VyHDtmi/T/nRPbao8Q9jqqvuPJ/vD9GPopDNllieNC9cX\n"
          "JwIDAQAB\n"
          "-----END PUBLIC KEY-----\n");
        const lstr_t pass = LSTR_IMMED("this-is-a-complicated-pass-phrase");
        const lstr_t text_encrypted = LSTR_IMMED(
          "\x87\xf9\xa5\x86\x33\xc8\x04\x87\xbb\xc2\x82\x91\x29\x30\x98\x8e"
          "\x8e\x44\x06\x2a\xa4\x43\x2c\x7e\x63\x80\x3d\x78\x6b\xa6\x21\x7e"
          "\x57\xe2\xe7\x4d\xe5\x5f\x11\x1e\xa5\x4b\x33\x5d\xb3\x97\x42\x57"
          "\xcb\xdb\x4b\x45\x1a\xcc\x3f\x95\xf3\x56\xa3\xb6\x2a\x06\xce\x5b"
          "\x25\xd2\xae\xaf\xdc\xa6\xe6\xba\x81\x49\xf0\x9c\x13\x5e\x10\x6d"
          "\x54\xfe\xbc\x75\xae\x8b\x82\x45\x7a\x8f\x4e\x4d\x08\x30\x12\x17"
          "\xb9\x17\x55\xc8\x88\x65\x29\x35\x02\x40\x64\x35\x48\xdb\x12\x88"
          "\x2a\xda\x80\x68\x9d\x95\x61\xc6\x7f\x0c\x78\xe2\x2a\xf7\x12\x98"
          "\x7d\x25\x4e\xa2\xcb\x3d\x3a\xf6\x4e\x30\xfd\xb3\x81\x5a\xec\xf7"
          "\x4c\x9e\x76\xe2\xa6\x16\x22\x9e\x16\xb8\x1e\xb0\xa1\xd9\x91\x76"
          "\xfb\x4d\xf8\x9a\xbc\xc4\xaa\xfd\x3d\x15\xaf\xb5\x64\x4e\x69\x9b"
          "\x14\x7c\x18\xbe\xe7\xb5\x14\xca\xad\x4c\xbc\xb7\xac\x02\x30\xff"
          "\x71\xd6\x51\xff\x79\xdd\x6e\xca\x59\xac\x72\x34\x37\x49\x5e\x5e"
          "\x47\x56\xe4\xb5\x8c\xb6\x8b\xdc\x78\xc0\x71\xe7\xf6\x13\xf0\x02"
          "\xff\x18\x62\xdb\x24\x0e\xbe\xd4\xdf\x27\xfb\xa7\x85\x1b\xfc\xbc"
          "\x67\xe8\xc7\xd7\xa0\xf8\xfb\x51\x75\x29\x8d\x56\x2d\xaa\xb0\x60");
        SB_1k(sb_encrypted);
        SB_1k(sb_clear);

        Z_ASSERT_P(ssl_ctx_init_pkey_pub(&ctx, pub_with_pass));
        Z_ASSERT_N(ssl_encrypt(&ctx, text, &sb_encrypted));
        ssl_ctx_wipe(&ctx);

        Z_ASSERT_P(ssl_ctx_init_pkey_priv(&ctx, priv_with_pass, pass));
        Z_ASSERT_N(ssl_decrypt(&ctx, LSTR_SB_V(&sb_encrypted), &sb_clear));
        Z_ASSERT_LSTREQUAL(text, LSTR_SB_V(&sb_clear));
        sb_reset(&sb_clear);

        Z_ASSERT_N(ssl_decrypt(&ctx, text_encrypted, &sb_clear));
        Z_ASSERT_LSTREQUAL(text, LSTR_SB_V(&sb_clear));
        ssl_ctx_wipe(&ctx);
    } Z_TEST_END;

/* }}} */

    }

/* }}} */

    MODULE_RELEASE(ssl);

} Z_GROUP_END

/* }}} */
