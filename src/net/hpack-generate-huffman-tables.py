#!/usr/bin/env python3
###########################################################################
#                                                                         #
# Copyright 2022 INTERSEC SA                                              #
#                                                                         #
# Licensed under the Apache License, Version 2.0 (the "License");         #
# you may not use this file except in compliance with the License.        #
# You may obtain a copy of the License at                                 #
#                                                                         #
#     http://www.apache.org/licenses/LICENSE-2.0                          #
#                                                                         #
# Unless required by applicable law or agreed to in writing, software     #
# distributed under the License is distributed on an "AS IS" BASIS,       #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.#
# See the License for the specific language governing permissions and     #
# limitations under the License.                                          #
#                                                                         #
###########################################################################

""" This script generates the static Huffman encoding/decoding tables for the
HPACK algorithm (of RFC-7541) as c arrays in autogenerated c files. The script
accepts as parameter the text of RFC-7541 which can be shortened to the
appendix section. For encoding, it generates the char-to-huffman-string
mapping. For decoding, it generates the decoder's state-transition table
based on input chunks of 1 or 2 or 4 bits at a time. This script is meant to
generate the '.c' files during the build step and accepts as parameter
a preamble text that '#include's a common '.h' file. For example:

file: hpack-priv.h
=========================================================================

// Type definition of the encoder's table:
// The name of this type is passed as parameter to the script.
// Respect the definition order, and use a compatible type.
// For example:
typedef struct hpack_huffcode_t {
    uint32_t codeword;
    unsigned bitlen;
} hpack_huffcode_t;


// Type definition of the decoder's state-transition table.
// The name of this type is passed as parameter to the script.
// Respect definition order, and use a compatible type.
// For example:
typedef struct hpack_huffdec_trans_t {
    uint8_t state;
    uint8_t sym;
    unsigned emitter : 1;
    unsigned final : 1;
    unsigned error : 1;
} hpack_huffdec_trans_t;

// The declaration of tables
extern const hpack_huffcode_t hpack_huffcode_tab_g[256 + 1];

// 16 is compatible with input chunks of 4 bits.
extern const hpack_huffdec_trans_t hpack_huffdec_trans_tab_g[256][16];
========================================================================

See 'options' for further details on command line paramters.

Note: default paramters are the ones used in building lib-common.
"""

import re
import sys
import inspect
import argparse
import platform
from itertools import product

HUFFMAN_EOS = 256
HDR_AUTOGENERATED = ("/*****        THIS FILE IS AUTOGENERATED DO NOT MODIFY "
                     "DIRECTLY !      *****/")

# default options used in lib-common
DEF_HDR_LINES = "#include <lib-common/net/hpack-priv.h>"
DEF_ENCODE_ELEM_T = 'const hpack_huffcode_t'
DEF_ENCODE_TABLE_NAME = 'hpack_huffcode_tab_g'
DEF_DECODE_ELEM_T = 'const hpack_huffdec_trans_t'
DEF_DECODE_TABLE_NAME = 'hpack_huffdec_trans_tab_g'
DEF_CHUNKBITS = 4

def get_license_as_c_comment():
    license_comment = str(inspect.getcomments(sys.modules[__name__]))
    license_comment = '\n' + license_comment + '\n'
    license_comment = license_comment.replace(
        "\n#", "\n/*").replace("#\n", "*/\n").replace('#', '*')
    return license_comment.strip()


def get_huffman_code_table_from(rfc_fn):
    def extract_huffman_code_table_text(rfc_fn):
        with open(rfc_fn, mode="r") as f:
            lines = ''.join(f.readlines())

        regex = r"\n(Appendix B\.  Huffman Code.+)\nAppendix"
        match = next(re.finditer(regex, lines, re.IGNORECASE | re.DOTALL))

        return match.group(1)

    huff_code_txt = extract_huffman_code_table_text(rfc_fn)
    regex = (r"\s*.*\(\s*(\d+)\s*\)\s*(\|[01\|]+)\s*([\da-fA-f]+)"
             r"\s*\[\s*(\d+)\s*\]")
    matches = re.finditer(regex, huff_code_txt)

    code_table = dict()

    for match in matches:
        sym = int(match.group(1))
        code_str = str(match.group(2)).replace("|", "")
        code = int(match.group(3), 16)
        bitlen = int(match.group(4))
        code_table[sym] = [sym, code, bitlen, code_str]

    for i in range(257):
        assert(len(code_table[i]) == 4)

    return [code_table[i] for i in range(257)]


def get_huffman_encoding_table_as_c_array(rfc_fn, tbl_elem_t, tbl_name):
    code_tab = get_huffman_code_table_from(rfc_fn)
    lines = list(
        f"/* sym ({sym:3d}) */ {{{hex(code):10s}, {bitlen:2d}}}"
        for sym, code, bitlen, _ in code_tab)
    content = "{\n  " + ",\n  ".join(lines) + "\n}"
    array_dec = "{} {}[{} + 1] = {};".format(
        tbl_elem_t, tbl_name, len(code_tab) - 1, content)
    return array_dec


def gen_table_for_encoding(rfc_fn, out_fn, hdr_lines, tbl_elem_t, tbl_name):
    head = HDR_AUTOGENERATED
    license_comment = get_license_as_c_comment()
    c_array_dec = get_huffman_encoding_table_as_c_array(
        rfc_fn, tbl_elem_t, tbl_name)
    content = '\n'.join(
        [head, license_comment, '', hdr_lines, '', c_array_dec, ''])
    if out_fn:
        with open(out_fn, 'w') as f:
            f.write(content)
    else:
        print(content, end='')


class Tree(dict):
    nodes, sealed = [], False

    def __missing__(self, key):
        assert(not self.sealed)
        if key not in ('*', 0, 1):
            raise KeyError
        value = self[key] = type(self)()
        value['sym'] = None
        value['prefix'] = '' if key == '*' else self['prefix'] + str(key)
        value['final'] = ('1' * 7).startswith(value['prefix'])
        self.nodes.append(value)
        return value

    @classmethod
    def seal(cls):
        cls.sealed = True


def get_huffman_tree(code_table):
    root = Tree()['*']
    for sym in range(257):
        code_str = code_table[sym][3]

        node = root
        for c in (int(ch) for ch in code_str):
            node = node[c]
        node['sym'] = sym
        assert(code_str == node['prefix'])

    root.seal()
    return root


def walk_from(root, node, code_str):
    sym, error, final, current = [], False, False, node
    for bit in (int(ch) for ch in code_str):
        # non leaf node that has two children [0] [1]
        assert(current['sym'] is None and bit in current)
        current = current[bit]
        if current['sym'] is not None:
            # reached a leaf node : emit sym and continue from the root
            if current['sym'] != HUFFMAN_EOS:  # EOS
                sym.append(current['sym'])
            else:
                error = True
            current = root

    final = not error and current['final']
    n_next = current
    return (sym, final, error, n_next)


def gen_huffman_st_table(tree, chunk_bits):
    def new_state(node):
        node['IDX'] = len(st_tab)
        st_tab.append(
            [{'next': None, 'sym': [], 'final': False, 'error': False}
             for _ in range(inputs)])

    assert(chunk_bits in [1, 2, 4])
    inputs = 2 ** chunk_bits
    root = tree
    st_tab = []
    total = errors = finals = 0

    node_q = []
    new_state(root)
    node_q.append(root)
    while node_q:
        n, idx, node_q = node_q[0], node_q[0]['IDX'], node_q[1:]

        for chunk_vec in product('01', repeat=chunk_bits):
            chunk_str = ''.join(chunk_vec)
            chunk_code = int(chunk_str, 2)
            total += 1

            sym, final, error, n_next = walk_from(root, n, chunk_str)
            if 'IDX' not in n_next:  # un-visited node/state
                new_state(n_next)
                node_q.append(n_next)
            st_tab[idx][chunk_code]['sym'].extend(sym)
            st_tab[idx][chunk_code]['final'] = final
            st_tab[idx][chunk_code]['error'] = error
            st_tab[idx][chunk_code]['next'] = n_next
            finals, errors = finals + int(final), errors + int(error)

    return st_tab


def compact_prefix(prefix):
    if prefix == '':
        return 'START'

    le = len(prefix)
    if le < 4:
        label = prefix
    else:
        nibbles = le // 4
        val = int(prefix[0:nibbles * 4], 2)
        label = f"{val:0{nibbles}X}:{prefix[nibbles * 4:]:s}"

    return label


def get_huffman_st_table_as_c_array(rfc_fn, tbl_elem_t, tbl_name, chunk_bits):
    def get_state_transitions_row(idx, state):
        cols = []
        for chunk_vec in product('01', repeat=chunk_bits):
            chunk_str = ''.join(chunk_vec)
            chunk_code = int(chunk_str, 2)

            trans = state[chunk_code]
            assert(len(trans['sym']) < 2)

            next_idx, emitter, = trans['next']['IDX'], len(trans['sym']) > 0
            final, error = trans['final'], trans['error']

            sym = trans['sym'][0] if emitter else 0
            prefix = compact_prefix(trans['next']['prefix'])

            cols.append("/* %s */ {/* %-10s */ %3d, %3d, %d, %d, %d}" %
                        (chunk_str, prefix, next_idx, sym, emitter,
                         final, error))

        return "  {\n    " + ",\n    ".join(cols) + "\n  }"

    tree = get_huffman_tree(get_huffman_code_table_from(rfc_fn))
    st_tab = gen_huffman_st_table(tree, chunk_bits)

    idx2n = {n['IDX']: n for n in tree.__class__.nodes if n['sym'] is None}

    rows = []
    for idx, state in enumerate(st_tab):
        prefix = compact_prefix(idx2n[idx]['prefix'])
        rows.append("/* node/state: [ %-10s ] %3d */\n" %
                    (prefix, idx) + get_state_transitions_row(idx, state))

    content = "{\n  " + ",\n  ".join(rows) + "\n}"
    array_dec = "{} {}[{}][{}] = {};".format(
        tbl_elem_t, tbl_name, len(st_tab), len(st_tab[0]), content)
    return array_dec


def gen_table_for_decoding(rfc_fn, out_fn, hdr_lines, tbl_elem_t,
                           tbl_name, chunk_bits):
    head = HDR_AUTOGENERATED
    license_comment = get_license_as_c_comment()
    c_array_dec = get_huffman_st_table_as_c_array(rfc_fn, tbl_elem_t,
                                                  tbl_name, chunk_bits)
    content = '\n'.join(
        [head, license_comment, '', hdr_lines, '', c_array_dec, ''])
    if out_fn:
        with open(out_fn, 'w') as f:
            f.write(content)
    else:
        print(content, end='')


def options(args):
    op = argparse.ArgumentParser(
        description=("Generate static Huffman encoding and decoding tables of"
                     " the HPACK algorithm"))
    subparsers = op.add_subparsers(dest='action')
    sp = subparsers.add_parser('for-encoding', help='Generate encoding table')
    sp.add_argument('-r', '--rfc', help="rfc 7541 file",
                    required=True, dest='rfc_fn')
    sp.add_argument('-o', '--out', help="output file", dest='out_fn',
                    default=None)
    sp.add_argument('-H', '--header', help="header lines", dest='hdr_lines',
                    default=DEF_HDR_LINES)
    sp.add_argument('-t', '--elem-type', help="type of table element",
                    dest='elem_t', default=DEF_ENCODE_ELEM_T)
    sp.add_argument('-n', '--name', help="name of table variable",
                    dest='name', default=DEF_ENCODE_TABLE_NAME)
    sp = subparsers.add_parser('for-decoding', help='Generate decoding table')
    sp.add_argument('-r', '--rfc', help="rfc 7541 file",
                    required=True, dest='rfc_fn')
    sp.add_argument('-o', '--out', help="output file", dest='out_fn',
                    default=None)
    sp.add_argument('-H', '--header', help="header lines", dest='hdr_lines',
                    default=DEF_HDR_LINES)
    sp.add_argument('-t', '--elem-type', help="type of table element",
                    dest='elem_t', default=DEF_DECODE_ELEM_T)
    sp.add_argument('-n', '--name', help="name of table variable",
                    dest='name', default=DEF_DECODE_TABLE_NAME)
    sp.add_argument('-c', '--chunkbits', type=int, choices=[1, 2, 4],
                    default=DEF_CHUNKBITS)
    return op.parse_args(args)


def main(args):
    def none_if_minus(fn):
        return fn if fn != '-' else None

    opts = options(args)
    if opts.action == 'for-encoding':
        gen_table_for_encoding(
            opts.rfc_fn, none_if_minus(opts.out_fn), opts.hdr_lines,
            opts.elem_t, opts.name)
    elif opts.action == 'for-decoding':
        gen_table_for_decoding(
            opts.rfc_fn, none_if_minus(opts.out_fn), opts.hdr_lines,
            opts.elem_t, opts.name, opts.chunkbits)


if __name__ == '__main__':
    if platform.system() == 'Linux':
        main(sys.argv[1:])
