/***************************************************************************/
/*                                                                         */
/* Copyright 2020 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include <float.h>
#include <math.h>
#include <lib-common/container-htlist.h>
#include <lib-common/arith.h>
#include <lib-common/core.h>
#include <lib-common/thr.h>
#include <lib-common/sort.h>

#include "priv.h"
#include "helpers.in.c"


static struct {
    iop_env_t env;
    size_t threaded_pack_threshold;
} iop_g = {
#define _G  iop_g
    .threaded_pack_threshold = 300,
};

/* {{{ Various helpers */

static inline int
__iop_field_find_by_name2(const iop_struct_t *desc, const lstr_t name)
{
    const iop_field_t *field = desc->fields;

    for (int i = 0; i < desc->fields_len; i++) {
        if (lstr_equal(field->name, name)) {
            return i;
        }
        field++;
    }
    return -1;
}

static inline const iop_field_t *
__iop_field_find_by_name(const iop_struct_t *desc, const lstr_t name)
{
    int pos = RETHROW_NP(__iop_field_find_by_name2(desc, name));

    return &desc->fields[pos];
}

int iop_field_find_by_name(const iop_struct_t *st, const lstr_t name,
                           const iop_struct_t **found_st,
                           const iop_field_t  **found_fdesc)
{
    int acc = 0;
    bool is_class = iop_struct_is_class(st);

    do {
        int pos = __iop_field_find_by_name2(st, name);

        if (pos >= 0) {
            if (found_st) {
                *found_st = st;
            }
            if (found_fdesc) {
                *found_fdesc = st->fields + pos;
            }
            return acc + pos;
        }
        acc += st->fields_len;
    } while (is_class && (st = st->class_attrs->parent));

    return -1;
}

/* Parses a field from an input field path with or without index.
 *
 * Examples:
 *
 *    'foo[42]' -> field_name == 'foo'
 *                 index == 42
 *
 *    'foo'     -> field_name == 'foo'
 *                 index == NONE
 */
static int
parse_field_from_path(pstream_t *field_path_ps, pstream_t *field_name,
                      opt_i32_t *index, bool *wildcard, sb_t *err)
{
    pstream_t field_ps;

    if (ps_get_ps_chr_and_skip(field_path_ps, '.', &field_ps) < 0) {
        /* We reached the end of the path: this field is the last field. */
        field_ps = *field_path_ps;
        __ps_skip_upto(field_path_ps, ps_end(field_path_ps));
    }
    if (wildcard) {
        *wildcard = false;
    }

    if (ps_get_ps_chr_and_skip(&field_ps, '[', field_name) >= 0) {
        errno = 0;
        if (wildcard && ps_skipc(&field_ps, '*') >= 0) {
            *wildcard = true;
            *index = (opt_i32_t)OPT_NONE;
        } else {
            *index = (opt_i32_t)OPT(ps_geti(&field_ps));
        }
        if (errno || ps_skipc(&field_ps, ']') < 0 || !ps_done(&field_ps)) {
            if (err) {
                sb_setf(err, "cannot read index for field `%*pM': "
                        "syntax error", PS_FMT_ARG(field_name));
            }

            return -1;
        }
    } else {
        *field_name = field_ps;
        *index = (opt_i32_t)OPT_NONE;
    }

    if (ps_done(field_name)) {
        if (err) {
            sb_sets(err, "empty field name");
        }
        return -1;
    }

    return 0;
}

const iop_field_t *
iop_get_field_const(const void *ptr, const iop_struct_t *st, lstr_t path,
                    const void ** nullable out_ptr,
                    const iop_struct_t ** nullable out_st)
{
    pstream_t ps = ps_initlstr(&path);
    const iop_field_t *iop_field = NULL;

    while (!ps_done(&ps)) {
        pstream_t s;
        opt_i32_t array_index;

        RETHROW_P(ptr);

        RETHROW_NP(parse_field_from_path(&ps, &s, &array_index, NULL, NULL));

        if (iop_struct_is_class(st)) {
            st = *(const iop_struct_t **)ptr;
        }
        RETHROW_NP(iop_field_find_by_name(st, LSTR_PS_V(&s), out_st,
                                          &iop_field));
        if (st->is_union && *(int16_t *)ptr != iop_field->tag) {
            return NULL;
        }
        ptr = (const byte *)ptr + iop_field->data_offs;

        if (OPT_ISSET(array_index)) {
            const IOP_ARRAY_OF(byte) *array_ptr = ptr;

            THROW_NULL_IF(iop_field->repeat != IOP_R_REPEATED);
            if (OPT_VAL(array_index) < 0) {
                /* Negative index means we read the array backward. */
                array_index.v = array_ptr->len + OPT_VAL(array_index);
                THROW_NULL_IF(array_index.v < 0);
            }

            THROW_NULL_IF(OPT_VAL(array_index) >= array_ptr->len);
            ptr = array_ptr->tab + iop_field->size * OPT_VAL(array_index);
        } else
        if (iop_field->repeat == IOP_R_REPEATED) {
            THROW_NULL_IF(!ps_done(&ps));
        }

        switch (iop_field->type) {
          case IOP_T_UNION:
          case IOP_T_STRUCT:
            if (!ps_done(&ps) && iop_field_is_pointed(iop_field)) {
                ptr = *(const void **)ptr;
            }
            st = iop_field->u1.st_desc;
            break;
          default:
            THROW_NULL_IF(!ps_done(&ps));
            break;
        }
    }
    if (out_ptr) {
        *out_ptr = ptr;
    }
    return iop_field;
}

iop_value_from_field_res_t
iop_value_from_field(const void *ptr, const iop_field_t *field,
                     iop_value_t *value)
{
    THROW_ERR_IF(field->repeat == IOP_R_REPEATED);

    ptr = (byte *)ptr + field->data_offs;

#define GET_SCALAR(type, opt, f)                                             \
        if (field->repeat == IOP_R_OPTIONAL) {                               \
            const opt *o = ptr;                                              \
                                                                             \
            if (OPT_ISSET(*o)) {                                             \
                value->f = OPT_VAL(*o);                                      \
            } else {                                                         \
                return IOP_FIELD_NOT_SET;                                    \
            }                                                                \
        } else {                                                             \
            value->f = *(const type *)ptr;                                   \
        }

    switch (field->type) {
      case IOP_T_I8:
        GET_SCALAR(int8_t, opt_i8_t, i);
        return 0;

      case IOP_T_U8:
        GET_SCALAR(uint8_t, opt_u8_t, u);
        return 0;

      case IOP_T_I16:
        GET_SCALAR(int16_t, opt_i16_t, i);
        return 0;

      case IOP_T_U16:
        GET_SCALAR(uint16_t, opt_u16_t, u);
        return 0;

      case IOP_T_ENUM:
      case IOP_T_I32:
        GET_SCALAR(int32_t, opt_i32_t, i);
        return 0;

      case IOP_T_U32:
        GET_SCALAR(uint32_t, opt_u32_t, u);
        return 0;

      case IOP_T_I64:
        GET_SCALAR(int64_t, opt_i64_t, i);
        return 0;

      case IOP_T_U64:
        GET_SCALAR(uint64_t, opt_u64_t, u);
        return 0;

      case IOP_T_BOOL:
        GET_SCALAR(bool, opt_bool_t, b);
        return 0;

      case IOP_T_DOUBLE:
        GET_SCALAR(double, opt_double_t, d);
        return 0;

#undef GET_SCALAR

      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA: {
        const lstr_t *str = ptr;

        if (field->repeat == IOP_R_OPTIONAL && !str->s) {
            return IOP_FIELD_NOT_SET;
        } else {
            value->s = lstr_dupc(*str);
        }
        return 0;
      }
      case IOP_T_STRUCT:
      case IOP_T_UNION: {
        if (iop_field_is_pointed(field)) {
            ptr = *(const void **)ptr;
        }

        if (!ptr) {
            return IOP_FIELD_NOT_SET;
        }
        value->p = (void *)ptr;
        return 0;
      }
      case IOP_T_VOID:
        return IOP_FIELD_NOT_SET;
    }
    return IOP_FIELD_ERROR;
}

static void iop_value_to_ptr(void *ptr, const iop_field_t *field,
                             const iop_value_t *value)
{
#define SET_SCALAR(type, opt, f)                                             \
        if (field->repeat == IOP_R_OPTIONAL) {                               \
            opt *o = ptr;                                                    \
                                                                             \
            OPT_SET(*o, value->f);                                           \
        } else {                                                             \
            *(type *)ptr = value->f;                                         \
        }

    switch (field->type) {
      case IOP_T_I8:
        SET_SCALAR(int8_t, opt_i8_t, i);
        break;

      case IOP_T_U8:
        SET_SCALAR(uint8_t, opt_u8_t, u);
        break;

      case IOP_T_I16:
        SET_SCALAR(int16_t, opt_i16_t, i);
        break;

      case IOP_T_U16:
        SET_SCALAR(uint16_t, opt_u16_t, u);
        break;

      case IOP_T_ENUM:
      case IOP_T_I32:
        SET_SCALAR(int32_t, opt_i32_t, i);
        break;

      case IOP_T_U32:
        SET_SCALAR(uint32_t, opt_u32_t, u);
        break;

      case IOP_T_I64:
        SET_SCALAR(int64_t, opt_i64_t, i);
        break;

      case IOP_T_U64:
        SET_SCALAR(uint64_t, opt_u64_t, u);
        break;

      case IOP_T_BOOL:
        SET_SCALAR(bool, opt_bool_t, b);
        break;

      case IOP_T_DOUBLE:
        SET_SCALAR(double, opt_double_t, d);
        break;
#undef SET_SCALAR

      case IOP_T_VOID:
        if (field->repeat == IOP_R_OPTIONAL) {
            *(bool *)ptr = true;
        }
        e_trace(3, "ignored value_t for void field (field %d:%*pM)",
                field->tag, LSTR_FMT_ARG(field->name));
        break;

      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA: {
        lstr_t *str = ptr;

        *str = lstr_dupc(value->s);
        break;
      }
      case IOP_T_STRUCT:
      case IOP_T_UNION: {
        if (iop_field_is_pointed(field)) {
            *(void **)ptr = (void *)value->p;
        } else
        if (value->p != ptr) {
            memcpy(ptr, value->p, field->size);
        }
        break;
      }
    }
}

size_t iop_value_get_bpack_size(const iop_value_t * nonnull value,
                                iop_type_t type,
                                const iop_struct_t * nullable st_desc)
{
    switch (type) {
      case IOP_T_I8:
      case IOP_T_BOOL:
        return 1;

      case IOP_T_U8:
        return 1 + (((uint8_t)value->u32) >> 7);

      case IOP_T_I16:
      case IOP_T_U16:
      case IOP_T_I32:
      case IOP_T_ENUM:
        return get_vint32_len(value->i32);

      case IOP_T_U32:
      case IOP_T_I64:
      case IOP_T_U64:
        return get_vint64_len(value->i64);

      case IOP_T_VOID:
        return 0;

      case IOP_T_DOUBLE:
        return 8;

      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        return get_len_len(value->s.len + 1) + value->s.len + 1;

      case IOP_T_UNION:
      case IOP_T_STRUCT:
      {
        qv_t(i32) szs;
        size_t sz;

        qv_inita(&szs, 1024);
        sz = iop_bpack_size(st_desc, value->p, &szs);
        qv_wipe(&szs);

        return get_len_len(sz) + sz;
      }
    }

    assert (false);
    return 0;
}

size_t iop_get_len_bpack_size(uint32_t length)
{
    return get_len_len(length);
}

int iop_value_to_repeated_field(void *ptr, const iop_field_t *field,
                                uint32_t pos, const iop_value_t *value)
{
    lstr_t data_s;
    void *data_p;

    if (!expect(field->repeat == IOP_R_REPEATED)) {
        return -1;
    }

    data_s = *(lstr_t *)((byte *)ptr + field->data_offs);
    data_p = (byte *)data_s.data + pos * field->size;

    iop_value_to_ptr(data_p, field, value);
    return 0;
}

void iop_value_to_field(void *ptr, const iop_field_t *field,
                        const iop_value_t *value)
{
    ptr = iop_field_get_ptr(field, ptr);
    iop_value_to_ptr(ptr, field, value);
}

void iop_set_opt_field(void *ptr, const iop_field_t *field)
{
    if (field->repeat != IOP_R_OPTIONAL) {
        e_panic("non-optional fields are not supported in iop_set_opt_field");
    }

    ptr = (byte *)ptr + field->data_offs;

    switch ((iop_type_t)field->type) {
      case IOP_T_U8: case IOP_T_I8: case IOP_T_BOOL:
        ((opt_i8_t *)ptr)->has_field = true;
        break;

      case IOP_T_U16: case IOP_T_I16:
        ((opt_i16_t *)ptr)->has_field = true;
        break;

      case IOP_T_U32: case IOP_T_I32: case IOP_T_ENUM:
        ((opt_i32_t *)ptr)->has_field = true;
        break;

      case IOP_T_U64: case IOP_T_I64: case IOP_T_DOUBLE:
        ((opt_i64_t *)ptr)->has_field = true;
        break;

      case IOP_T_STRING: case IOP_T_DATA: case IOP_T_XML: {
        lstr_t *s = ptr;

        if (!s->s) {
            assert (!s->len);
            s->s = "";
        }
      } break;

      case IOP_T_UNION: case IOP_T_STRUCT:
        e_panic("unions/structs are not supported in iop_set_opt_field");
        break;

      case IOP_T_VOID:
        *(bool *)ptr = true;
        break;
    }
}

static int
iop_field_set_defval(const iop_field_t *fdesc, void *ptr)
{
    assert (fdesc->repeat == IOP_R_DEFVAL);
    switch (fdesc->type) {
      case IOP_T_I8: case IOP_T_U8:
        *(uint8_t *)ptr  = fdesc->u1.defval_u64;
        break;
      case IOP_T_I16: case IOP_T_U16:
        *(uint16_t *)ptr = fdesc->u1.defval_u64;
        break;
      case IOP_T_ENUM:
        *(uint32_t *)ptr = fdesc->u0.defval_enum;
        break;
      case IOP_T_I32: case IOP_T_U32:
        *(uint32_t *)ptr = fdesc->u1.defval_u64;
        break;
      case IOP_T_I64: case IOP_T_U64:
        *(uint64_t *)ptr = fdesc->u1.defval_u64;
        break;
      case IOP_T_BOOL:
        *(bool *)ptr     = !!fdesc->u1.defval_u64; /* Map to 0/1 */
        break;
      case IOP_T_DOUBLE:
        *(double *)ptr   = fdesc->u1.defval_d;
        break;
      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA:
        *(lstr_t *)ptr = LSTR_INIT_V(fdesc->u1.defval_data,
                                     fdesc->u0.defval_len);
        break;
      case IOP_T_UNION:
      case IOP_T_STRUCT:
        return -1;

      case IOP_T_VOID:
        assert (false);
        return -1;
    }

    return 0;
}

lstr_t t_camelcase_to_c(lstr_t s)
{
    t_SB(buf, 64);

    for (int i = 0; i < s.len; i++) {
        if (i && isupper(s.s[i])) {
            sb_addc(&buf, '_');
        }
        sb_addc(&buf, tolower(s.s[i]));
    }

    return lstr_init_(buf.data, buf.len, MEM_STACK);
}

lstr_t t_iop_type_to_c(lstr_t name)
{
    t_SB(buf, 64);
    qv_t(lstr) parts;
    pstream_t ps = ps_initlstr(&name);
    ctype_desc_t dot;

    t_qv_init(&parts, 3);
    ctype_desc_build(&dot, ".");
    ps_split(ps, &dot, 0, &parts);
    if (!parts.len) {
        return LSTR_EMPTY_V;
    }

    for (int i = 0; i < parts.len - 1; i++) {
        sb_add_lstr(&buf, parts.tab[i]);
        sb_adds(&buf, "__");
    }
    sb_add_lstr(&buf, t_camelcase_to_c(parts.tab[parts.len - 1]));

    return lstr_init_(buf.data, buf.len, MEM_STACK);
}

int c_to_camelcase(lstr_t s, bool is_first_upper, sb_t *out)
{
    pstream_t ps = ps_initlstr(&s);

    THROW_ERR_IF(lstr_endswithc(s, '_'));

    sb_reset(out);
    while (!ps_done(&ps)) {
        pstream_t token;
        pstream_t token2;

        if (ps_get_ps_chr_and_skip(&ps, '_', &token) < 0) {
            token = ps;
            ps = ps_init(NULL, 0);
        }

        /* Validate token */
        THROW_ERR_IF(ps_len(&token) == 0);

        token2 = ps_get_span(&token, &ctype_isalnum);
        THROW_ERR_IF(ps_len(&token) > 0);

        token = ps_get_cspan(&token2, &ctype_isupper);
        THROW_ERR_IF(ps_len(&token2) > 0);

        /* fast path if the string needs no modification */
        if (!is_first_upper && !out->len && ps_done(&ps)) {
            sb_set_lstr(out, s);
            return 0;
        }

        /* Transform token */
        if (is_first_upper || out->len) {
            sb_addc(out, toupper(ps_getc(&token)));
        }
        sb_add(out, token.s, ps_len(&token));
    }
    return 0;
}

lstr_t t_c_to_camelcase(lstr_t s, bool is_first_upper)
{
    t_SB(buf, s.len);

    if (c_to_camelcase(s, is_first_upper, &buf) < 0) {
        return LSTR_NULL_V;
    }

    return LSTR_SB_V(&buf);
}

bool iop_type_is_scalar(iop_type_t type)
{
    return !((1 << type) & IOP_STRUCTS_OK);
}

bool iop_field_is_pointed(const iop_field_t *fdesc)
{
    if (iop_type_is_scalar(fdesc->type)) {
        return false;
    }

    if (fdesc->repeat == IOP_R_OPTIONAL) {
        return true;
    }

    return iop_field_is_reference(fdesc) || iop_field_is_class(fdesc);
}

void *nullable iop_opt_field_getv(iop_type_t type, void *nonnull data)
{
    switch (type) {
      case IOP_T_I8:
      case IOP_T_U8:
        return OPT_GET((opt_u8_t *)data);

      case IOP_T_I16:
      case IOP_T_U16:
        return OPT_GET((opt_u16_t *)data);

      case IOP_T_ENUM:
      case IOP_T_I32:
      case IOP_T_U32:
        return OPT_GET((opt_u32_t *)data);

      case IOP_T_I64:
      case IOP_T_U64:
        return OPT_GET((opt_u64_t *)data);

      case IOP_T_BOOL:
        return OPT_GET((opt_bool_t *)data);

      case IOP_T_DOUBLE:
        return OPT_GET((opt_double_t *)data);

      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA:
        return ((lstr_t *)data)->s ? data : NULL;

      case IOP_T_STRUCT:
      case IOP_T_UNION:
        return *(void **)data;

      case IOP_T_VOID:
        /* XXX Return a slop pointer that means that the field is present. It
         * isn't expected to be indirected though. */
        return *(bool *)data ? data : NULL;
    }

    assert (false);
    return NULL;
}

static const void *iop_opt_field_getv_const(iop_type_t type, const void *data)
{
    return iop_opt_field_getv(type, (void *)data);
}

void iop_get_field_values(const iop_field_t *fdesc, void *st_ptr,
                          void **values, int *len,
                          bool * nullable is_array_of_pointers)
{
    void *fptr = (byte *)st_ptr + fdesc->data_offs;

    if (fdesc->repeat == IOP_R_REPEATED) {
        iop_array_i8_t *array = fptr;

        *values = array->tab;
        *len = array->len;
        if (is_array_of_pointers) {
            *is_array_of_pointers = iop_field_is_class(fdesc);
        }

        return;
    }

    if (is_array_of_pointers) {
        /* For non-repeated fields, we will always apply the indirection. */
        *is_array_of_pointers = false;
    }

    if (fdesc->repeat == IOP_R_OPTIONAL) {
        fptr = iop_opt_field_getv(fdesc->type, fptr);
        if (!fptr) {
            /* The optional field is absent. */
            *len = 0;
            *values = NULL;
            return;
        }
        if (fdesc->type == IOP_T_VOID) {
            *values = NULL;
        } else {
            *values = fptr;
        }
    } else
    if (fdesc->type == IOP_T_VOID) {
        *values = NULL;
        *len = 0;
        return;
    } else
    if (iop_field_is_pointed(fdesc)) {
        *values = *(void **)fptr;
    } else {
        *values = fptr;
    }

    *len = 1;
}

void iop_get_field_values_const(const iop_field_t *fdesc, const void *st_ptr,
                                const void **values, int *len,
                                bool * nullable is_array_of_pointers)
{
    iop_get_field_values(fdesc, (void *)st_ptr, (void **)values, len,
                         is_array_of_pointers);
}

/* }}} */
/* {{{ Iop type string description */

const char *iop_type_get_string_desc(iop_type_t type)
{
    switch (type) {
      case IOP_T_I8:
        return "byte";
      case IOP_T_I16:
        return "short";
      case IOP_T_I32:
        return "int";
      case IOP_T_I64:
        return "long";
      case IOP_T_U8:
        return "ubyte";
      case IOP_T_U16:
        return "ushort";
      case IOP_T_U32:
        return "uint";
      case IOP_T_U64:
        return "ulong";
      case IOP_T_BOOL:
        return "bool";
      case IOP_T_ENUM:
        return "enum";
      case IOP_T_DOUBLE:
        return "double";
      case IOP_T_STRING:
        return "string";
      case IOP_T_DATA:
        return "bytes";
      case IOP_T_UNION:
        return "union";
      case IOP_T_STRUCT:
        return "struct";
      case IOP_T_XML:
        return "xml";
      case IOP_T_VOID:
        return "void";
    }
    e_panic("iop_type unsupported");
}

iop_value_t iop_type_to_max(iop_type_t type)
{
    iop_value_t value;

    switch (type) {
      case IOP_T_BOOL:
        value.u64 = true;
        break;
      case IOP_T_DOUBLE:
        value.d = INFINITY;
        break;
      case IOP_T_I8:
        value.i64 = INT8_MAX;
        break;
      case IOP_T_I16:
        value.i64 = INT16_MAX;
        break;
      case IOP_T_ENUM:
      case IOP_T_I32:
        value.i64 = INT32_MAX;
        break;
      case IOP_T_I64:
        value.i64 = INT64_MAX;
        break;
      case IOP_T_U8:
        value.u64 = UINT8_MAX;
        break;
      case IOP_T_U16:
        value.u64 = UINT16_MAX;
        break;
      case IOP_T_U32:
        value.u64 = UINT32_MAX;
        break;
      case IOP_T_U64:
        value.u64 = UINT64_MAX;
        break;
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
      case IOP_T_STRUCT:
      case IOP_T_UNION:
      case IOP_T_VOID:
        e_panic("iop_type unsupported");
    }

    return value;
}

iop_value_t iop_type_to_min(iop_type_t type)
{
    iop_value_t value;

    switch (type) {
      case IOP_T_DOUBLE:
        value.d = -INFINITY;
        break;
      case IOP_T_I8:
        value.i64 = INT8_MIN;
        break;
      case IOP_T_I16:
        value.i64 = INT16_MIN;
        break;
      case IOP_T_ENUM:
      case IOP_T_I32:
        value.i64 = INT32_MIN;
        break;
      case IOP_T_I64:
        value.i64 = INT64_MIN;
        break;
      case IOP_T_BOOL:
      case IOP_T_U8:
      case IOP_T_U16:
      case IOP_T_U32:
      case IOP_T_U64:
        value.u64 = 0;
        break;
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
      case IOP_T_STRUCT:
      case IOP_T_UNION:
      case IOP_T_VOID:
        e_panic("iop_type unsupported");
    }

    return value;
}

/* }}} */
/* {{{ Generic attributes */

static int iop_convert_i64(int64_t i64, iop_type_t type, iop_value_t *value)
{
#define CHECK_RANGE(_min, _max)  THROW_ERR_IF(i64 < _min || i64 > _max)

    switch (type) {
      case IOP_T_I8:
        CHECK_RANGE(INT8_MIN, INT8_MAX);
        value->i = i64;
        break;
      case IOP_T_U8:
        CHECK_RANGE(0, UINT8_MAX);
        value->u = i64;
        break;
      case IOP_T_I16:
        CHECK_RANGE(INT16_MIN, INT16_MAX);
        value->i = i64;
        break;
      case IOP_T_U16:
        CHECK_RANGE(0, UINT16_MAX);
        value->u = i64;
        break;
      case IOP_T_I32:
        CHECK_RANGE(INT32_MIN, INT32_MAX);
        value->i = i64;
        break;
      case IOP_T_U32:
        CHECK_RANGE(0, UINT32_MAX);
        value->u = i64;
        break;
      case IOP_T_I64: case IOP_T_U64:
        value->i = i64;
        break;
      case IOP_T_BOOL:
        CHECK_RANGE(0, 1);
        value->b = i64;
        break;
      case IOP_T_DOUBLE:
        value->d = i64;
        break;
      case IOP_T_ENUM:
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
      case IOP_T_STRUCT:
      case IOP_T_UNION:
      case IOP_T_VOID:
        return -1;
    }

#undef CHECK_RANGE
    return 0;
}

#define ATTR_IS_GENERIC(_attr, _what)                                        \
    (_attr->type == IOP_##_what##_GEN_ATTR_S                                 \
  || _attr->type == IOP_##_what##_GEN_ATTR_O                                 \
  || _attr->type == IOP_##_what##_GEN_ATTR_I                                 \
  || _attr->type == IOP_##_what##_GEN_ATTR_D)

static int iop_convert_value(iop_type_t exp_type, iop_type_t val_type,
                             iop_value_t *value)
{
    switch (val_type) {
      case IOP_T_STRING:
        return iop_type_is_string(exp_type) ? 0 : -1;

      case IOP_T_I64:
        return iop_convert_i64(value->i64, exp_type, value);

      case IOP_T_DOUBLE:
        return exp_type == IOP_T_DOUBLE ? 0 : -1;

      case IOP_T_I8:
      case IOP_T_I16:
      case IOP_T_I32:
      case IOP_T_BOOL:
      case IOP_T_ENUM:
      case IOP_T_U8:
      case IOP_T_U16:
      case IOP_T_U32:
      case IOP_T_U64:
      case IOP_T_DATA:
      case IOP_T_XML:
      case IOP_T_STRUCT:
      case IOP_T_UNION:
      case IOP_T_VOID:
        e_panic("iop_type unsupported");
    }
    return -1;
}

#define __get_gen_attr_value(_attrs, _len, _key, _what, _what_l,           \
                             _exp_type, _val_type, _val)                   \
    ({                                                                     \
        int _res = -1;                                                     \
        iop_type_t _attr_type;                                             \
                                                                           \
        for (int _i = 0; _i < _len; _i++) {                                \
            const iop_##_what_l##_attr_t *_attr = _attrs + _i;             \
                                                                           \
            if (!ATTR_IS_GENERIC(_attr, _what)                             \
            ||  !lstr_equal(_key, _attr->args[0].v.s))                     \
            {                                                              \
                continue;                                                  \
            }                                                              \
                                                                           \
            _res = 0;                                                      \
            switch (_attr->type) {                                         \
              case IOP_##_what##_GEN_ATTR_O:                               \
              case IOP_##_what##_GEN_ATTR_S:                               \
                _val->s = _attr->args[1].v.s;                              \
                _attr_type = IOP_T_STRING;                                 \
                break;                                                     \
              case IOP_##_what##_GEN_ATTR_I:                               \
                _val->i64 = _attr->args[1].v.i64;                          \
                _attr_type = IOP_T_I64;                                    \
                break;                                                     \
              case IOP_##_what##_GEN_ATTR_D:                               \
                _val->d = _attr->args[1].v.d;                              \
                _attr_type = IOP_T_DOUBLE;                                 \
                break;                                                     \
              default:                                                     \
                e_panic("invalid generic attribute type");                 \
            }                                                              \
            break;                                                         \
        }                                                                  \
                                                                           \
        if (_res == 0) {                                                   \
            if ((int)_exp_type >= 0) {                                     \
                _res = iop_convert_value(_exp_type, _attr_type, _val);     \
            }                                                              \
            if (_val_type) {                                               \
                *_val_type = _attr_type;                                   \
            }                                                              \
        }                                                                  \
                                                                           \
        _res;                                                              \
    })

int iop_struct_get_gen_attr(const iop_struct_t *st, lstr_t key,
                            iop_type_t exp_type, iop_type_t *val_type,
                            iop_value_t *value)
{
    unsigned flags = st->flags;

    if (!TST_BIT(&flags, IOP_STRUCT_EXTENDED) || !st->st_attrs) {
        return -1;
    }
    return __get_gen_attr_value(st->st_attrs->attrs, st->st_attrs->attrs_len,
                                key, STRUCT, struct, exp_type, val_type,
                                value);
}

int iop_enum_get_gen_attr(const iop_enum_t *en, lstr_t key,
                          iop_type_t exp_type, iop_type_t *val_type,
                          iop_value_t *value)
{
    if (!TST_BIT(&en->flags, IOP_ENUM_EXTENDED) || !en->en_attrs) {
        return -1;
    }
    return __get_gen_attr_value(en->en_attrs->attrs, en->en_attrs->attrs_len,
                                key, ENUM, enum, exp_type, val_type, value);
}

static int iop_enum_pos_from_val(const iop_enum_t *e, int val);
static int iop_enum_pos_from_str(const iop_enum_t *e, const char *s, int len);

int iop_enum_get_gen_attr_from_val(const iop_enum_t *ed, int val, lstr_t key,
                                   iop_type_t exp_type, iop_type_t *val_type,
                                   iop_value_t *value)
{
    const iop_enum_value_attrs_t *va;
    int pos;

    if (!TST_BIT(&ed->flags, IOP_ENUM_EXTENDED) || !ed->values_attrs) {
        return -1;
    }
    pos = RETHROW(iop_enum_pos_from_val(ed, val));
    va = &ed->values_attrs[pos];
    return __get_gen_attr_value(va->attrs, va->attrs_len, key, ENUM_VALUE,
                                enum_value, exp_type, val_type, value);
}

int iop_enum_get_gen_attr_from_str(const iop_enum_t *ed, lstr_t val,
                                   lstr_t key, iop_type_t exp_type,
                                   iop_type_t *val_type, iop_value_t *value)
{
    const iop_enum_value_attrs_t *va;
    int pos;

    if (!TST_BIT(&ed->flags, IOP_ENUM_EXTENDED) || !ed->values_attrs) {
        return -1;
    }
    pos = RETHROW(iop_enum_pos_from_str(ed, val.s, val.len));
    va = &ed->values_attrs[pos];
    return __get_gen_attr_value(va->attrs, va->attrs_len, key, ENUM_VALUE,
                                enum_value, exp_type, val_type, value);
}

int iop_iface_get_gen_attr(const iop_iface_t *iface, lstr_t key,
                           iop_type_t exp_type, iop_type_t *val_type,
                           iop_value_t *value)
{
    if (!TST_BIT(&iface->flags, IOP_IFACE_HAS_ATTRS) || !iface->iface_attrs) {
        return -1;
    }
    return __get_gen_attr_value(iface->iface_attrs->attrs,
                                iface->iface_attrs->attrs_len, key, IFACE,
                                iface, exp_type, val_type, value);
}

int iop_rpc_get_gen_attr(const iop_iface_t *iface, const iop_rpc_t *rpc,
                         lstr_t key, iop_type_t exp_type,
                         iop_type_t *val_type, iop_value_t *value)
{
    const iop_rpc_attrs_t *attrs = RETHROW_PN(iop_rpc_get_attrs(iface, rpc));

    return __get_gen_attr_value(attrs->attrs, attrs->attrs_len, key, RPC,
                                rpc, exp_type, val_type, value);
}

int iop_field_get_gen_attr(const iop_struct_t *st, const iop_field_t *field,
                           lstr_t key, iop_type_t exp_type,
                           iop_type_t *val_type, iop_value_t *value)
{
    const iop_field_attrs_t *attrs = RETHROW_PN(iop_field_get_attrs(st,
                                                                    field));

    return __get_gen_attr_value(attrs->attrs, attrs->attrs_len, key, FIELD,
                                field, exp_type, val_type, value);
}

bool iop_field_get_bool_gen_attr(const iop_struct_t *st,
                                 const iop_field_t *field, lstr_t key,
                                 bool def)
{
    iop_value_t value;

    if (iop_field_get_gen_attr(st, field, key, IOP_T_BOOL, NULL, &value) < 0)
    {
        return def;
    }

    return value.b;
}

int iop_field_by_name_get_gen_attr(const iop_struct_t *st, lstr_t f_name,
                                   lstr_t key, iop_type_t exp_type,
                                   iop_type_t *val_type, iop_value_t *value)
{
    int pos = RETHROW(__iop_field_find_by_name2(st, f_name));
    const iop_field_t *field = st->fields + pos;

    return iop_field_get_gen_attr(st, field, key, exp_type, val_type, value);
}

/* }}} */
/* {{{ iop_init / iop_new */

static void
iop_init_fields(void *value, const iop_field_t *fdesc, const iop_field_t *end)
{
    for (; fdesc < end; fdesc++) {
        void *ptr = (char *)value + fdesc->data_offs;

        if (fdesc->repeat == IOP_R_REQUIRED && fdesc->type == IOP_T_STRUCT) {
            /* We can't handle the unions here since we don't know which field
             * has been selected */
            const iop_struct_t *desc = fdesc->u1.st_desc;

            if (iop_field_is_pointed(fdesc)) {
                /* Field should be initialized as an optional field: NULL
                 * pointer. */
                continue;
            }

            iop_init_fields(ptr, desc->fields, desc->fields +
                            desc->fields_len);
        } else
        if (fdesc->repeat == IOP_R_DEFVAL
        &&  iop_field_set_defval(fdesc, ptr) < 0)
        {
            e_panic("should not happen");
        }
    }
}

void iop_init_union_desc(const iop_struct_t *desc, void *value,
                         const iop_field_t *fdesc)
{
    memset(value, 0, desc->size);

    if (!expect(desc->is_union)) {
        return;
    }
    iop_union_set_tag(desc, fdesc->tag, value);
    iop_init_fields(value, fdesc, fdesc + 1);
}

void iop_init_desc(const iop_struct_t *desc, void *value)
{
    memset(value, 0, desc->size);

    if (desc->is_union) {
        return;
    }
    if (iop_struct_is_class(desc)) {
        const iop_struct_t **__vptr = value;
        const iop_struct_t *parent = desc;

        e_assert(panic, !desc->class_attrs->is_abstract,
                 "initialization of abstract class '%*pM' is forbidden",
                 LSTR_FMT_ARG(desc->fullname));

        *__vptr = desc;

        while ((parent = parent->class_attrs->parent)) {
            iop_init_fields(value, parent->fields,
                            parent->fields + parent->fields_len);
        }
    }

    iop_init_fields(value, desc->fields, desc->fields + desc->fields_len);
}

void *mp_iop_new_desc(mem_pool_t *mp, const iop_struct_t *st)
{
    void *res = mp_imalloc(mp, st->size, 8, MEM_RAW);

    iop_init_desc(st, res);

    return res;
}

/* }}} */
/* {{{ Duplicating values */

static size_t __iop_dup_class_size(const iop_struct_t *desc, const void *val);

static size_t __iop_dup_size(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    size_t len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = iop_field_get_cptr(fdesc, val);
        bool is_class = iop_field_is_class(fdesc);
        bool is_ref   = iop_field_is_reference(fdesc);
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n    = ((lstr_t *)ptr)->len;
            ptr  = ((lstr_t *)ptr)->data;
            len += ROUND_UP(n * fdesc->size, 8);
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) /* DATA,STRING,STRUCT,UNION */
            continue;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_opt_field_isset(fdesc->type, ptr)) {
                continue;
            }
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                ptr = *(void **)ptr;
                if (is_class) {
                    /* Do not take the field size, but the size of the
                     * actually instanciated class */
                    len += ROUND_UP((*(const iop_struct_t **)ptr)->size, 8);
                } else {
                    len += ROUND_UP(fdesc->size, 8);
                }
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional reference fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    v = *(void **)v;
                    if (is_class) {
                        len += ROUND_UP((*(const iop_struct_t **)v)->size, 8);
                    }
                }
                if (is_class) {
                    len += __iop_dup_class_size(fdesc->u1.st_desc, v);
                } else {
                    if (is_ref) {
                        len += ROUND_UP(fdesc->size, 8);
                    }
                    len += __iop_dup_size(fdesc->u1.st_desc, v);
                }
            }
        } else {
            for (int j = 0; j < n; j++) {
                len += ROUND_UP(IOP_FIELD(lstr_t, ptr, j).len + 1, 8);
            }
        }
    }

    return len;
}

static size_t __iop_dup_class_size(const iop_struct_t *desc, const void *val)
{
    size_t len = 0;

    desc = *(const iop_struct_t **)val;
    do {
        len += __iop_dup_size(desc, val);
    } while ((desc = desc->class_attrs->parent));

    return len;
}

static size_t iop_dup_size(const iop_struct_t *desc, const void *val)
{
    if (iop_struct_is_class(desc)) {
        return __iop_dup_class_size(desc, val);
    } else {
        return __iop_dup_size(desc, val);
    }
}

static uint8_t *realign(uint8_t *ptr)
{
    return (uint8_t *)ROUND_UP((uintptr_t)ptr, 8);
}

static uint8_t *
__iop_deep_copy_class(mem_pool_t *mp, const iop_struct_t *st,
                      uint8_t *dst, void *wval, const void *rval);

static uint8_t *__iop_deep_copy(mem_pool_t *mp, const iop_struct_t *st,
                                uint8_t *dst, void *wval, const void *rval)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        fdesc = get_union_field(st, rval);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *rp = (char *)rval + fdesc->data_offs;
        const void *wp = (char *)wval + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            n = ((lstr_t *)rp)->len;
            if (n) {
                if (mp) {
                    dst = mp_imalloc(mp, n * fdesc->size, 8, MEM_RAW);
                }
                rp  = ((lstr_t *)rp)->data;
                wp  = ((lstr_t *)wp)->data = dst;
                dst = realign(mempcpy(dst, rp, n * fdesc->size));
            } else {
                ((lstr_t *)wp)->data = NULL;
                dst = realign(dst);
                continue;
            }
        }

        if (!((1 << fdesc->type) & IOP_BLK_OK)) {
            /* The type is not DATA,STRING,STRUCT,UNION */
            continue;
        }

        if (fdesc->repeat == IOP_R_OPTIONAL
        &&  !iop_opt_field_isset(fdesc->type, rp))
        {
            continue;
        }

        if (!iop_type_is_scalar(fdesc->type)) {
            bool is_class = iop_field_is_class(fdesc);
            bool is_ref   = iop_field_is_reference(fdesc);
            const iop_struct_t *fst = fdesc->u1.st_desc;

            for (int j = 0; j < n; j++) {
                const void *rv = &IOP_FIELD(const char, rp, j * fdesc->size);
                void       *wv = &IOP_FIELD(char,       wp, j * fdesc->size);

                if (is_class || is_ref || fdesc->repeat == IOP_R_OPTIONAL) {
                    /* Non-optional referenced fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    rv = *(void **)rv;

                    if (is_class) {
                        fst = *(const iop_struct_t **)rv;
                    }
                    if (mp) {
                        dst = mp_imalloc(mp, fst->size, 8, MEM_RAW);
                    }

                    wv = *(void **)wv = dst;

                    if (!is_class) {
                        /* Will be done in __iop_copy_class for classes */
                        dst = realign(mempcpy(dst, rv, fdesc->size));
                    }
                }
                if (is_class) {
                    dst = __iop_deep_copy_class(mp, fst, dst, wv, rv);
                } else {
                    dst = __iop_deep_copy(mp, fst, dst, wv, rv);
                }
            }
        } else {
            assert (fdesc->type == IOP_T_STRING || fdesc->type == IOP_T_XML
                ||  fdesc->type == IOP_T_DATA);

            for (int j = 0; j < n; j++) {
                lstr_t *orig = &IOP_FIELD(lstr_t, rp, j);
                lstr_t *dest = &IOP_FIELD(lstr_t, wp, j);

                if (mp) {
                    dst = mp_imalloc(mp, orig->len + 1, alignof(char),
                                     MEM_RAW);
                }

                /* We have to fix the lstr_t mem_pool manually because
                 * some naughty programmers could have played with it */
                dest->data = dst;
                dest->mem_pool = MEM_STATIC;
                dst = realign(mempcpyz(dst, orig->s, orig->len));
            }
        }
    }

    return dst;
}

static uint8_t *
__iop_deep_copy_class_fields(mem_pool_t *mp, const iop_struct_t *st,
                             uint8_t *dst, void *wval, const void *rval)
{
    do {
        dst = __iop_deep_copy(mp, st, dst, wval, rval);
    } while ((st = st->class_attrs->parent));

    return dst;
}

static uint8_t *
__iop_deep_copy_class(mem_pool_t *mp, const iop_struct_t *st,
                      uint8_t *dst, void *wval, const void *rval)
{
    dst = realign(mempcpy(dst, rval, st->size));
    return __iop_deep_copy_class_fields(mp, st, dst, wval, rval);
}

static void *
__mp_iop_copy_desc_flags_sz(mem_pool_t *mp, const iop_struct_t *st,
                            void *nullable *outp, const void *v,
                            unsigned flags, size_t *nullable psz)
{
    bool is_class;
    size_t sz;
    uint8_t *dst, *res;

    if (!v) {
        if (outp) {
            mp_ifree(mp, *outp);
            *outp = NULL;
        }
        return NULL;
    }

    mp = mp_ipool(mp);
    if (flags & IOP_COPY_MULTIPLE_ALLOC) {
        e_assert(panic, mp->mem_pool & MEM_BY_FRAME,
                 "using IOP_COPY_MULTIPLE_ALLOC on non frame-based memory "
                 "pools is forbidden");
        if (!expect(!psz)) {
            /* Size can be set only in single allocation mode. */
            *psz = 0;
            psz = NULL;
        }
    }

    if ((is_class = iop_struct_is_class(st))) {
        st = *(const iop_struct_t **)v;
    }

    if (flags & IOP_COPY_NO_REALLOC) {
        size_t offset = 0;

        e_assert(panic, outp && *outp, "IOP_COPY_NO_REALLOC require outp to "
                 "point to an existing object");

        res = *outp;
        if (is_class) {
            e_assert(panic, iop_obj_is_a_desc(res, st),
                     "existing outp object is not a `%*pM`",
                     LSTR_FMT_ARG(st->fullname));
            /* Skip the __vptr field. */
            offset = sizeof(iop_struct_t *);
        }

        if (flags & (IOP_COPY_MULTIPLE_ALLOC | IOP_COPY_SHALLOW)) {
            sz = 0;
        } else {
            e_assert(panic, mp->mem_pool & MEM_BY_FRAME,
                     "using IOP_COPY_NO_REALLOC on non frame-based memory "
                     "pools without IOP_COPY_SHALLOW is forbidden");
            sz = iop_dup_size(st, v);
        }

        memcpy(res + offset, (const uint8_t *)v + offset, st->size - offset);
        dst = sz ? mp_imalloc(mp, sz, 8, MEM_RAW) : NULL;

        if (!expect(!psz)) {
            /* Size can be set only in realloc mode. */
            *psz = 0;
        }
    } else {
        if (flags & (IOP_COPY_MULTIPLE_ALLOC | IOP_COPY_SHALLOW)) {
            sz = st->size;
        } else {
            sz = ROUND_UP(st->size, 8) + iop_dup_size(st, v);
        }

        if (psz) {
            *psz = sz;
        }

        if (outp) {
            res = *outp;
            res = mp_irealloc(mp, res, 0, sz, 8, MEM_RAW);
            *outp = res;
        } else {
            res = mp_imalloc(mp, sz, 8, MEM_RAW);
        }

        dst = realign(mempcpy(res, v, st->size));
    }

    if (!(flags & IOP_COPY_SHALLOW)) {
        if (!(flags & IOP_COPY_MULTIPLE_ALLOC)) {
            /* XXX Everything's already allocated at this point. There is no
             * assumption that 'mp == NULL' means that we should use
             * mem_pool_libc in __iop_copy_class and __iop_copy.
             */
            mp = NULL;
        }

        if (is_class) {
            dst = __iop_deep_copy_class_fields(mp, st, dst, res, v);
        } else {
            dst = __iop_deep_copy(mp, st, dst, res, v);
        }
    }

    assert ((flags & (IOP_COPY_MULTIPLE_ALLOC | IOP_COPY_NO_REALLOC))
         || dst == res + sz);
    return res;
}

void *mp_iop_dup_desc_flags_sz(mem_pool_t *mp, const iop_struct_t *st,
                               const void *v, unsigned flags,
                               size_t *nullable psz)
{
    return __mp_iop_copy_desc_flags_sz(mp, st, NULL, v, flags, psz);
}

void mp_iop_copy_desc_flags_sz(mem_pool_t *mp, const iop_struct_t *st,
                               void **outp, const void *v, unsigned flags,
                               size_t *nullable psz)
{
    __mp_iop_copy_desc_flags_sz(mp, st, outp, v, flags, psz);
}

/* }}} */
/* {{{ Comparing values */

__cold static void
sb_prepend_field(sb_t *sb, const iop_field_t *fdesc, int j);

static int iop_first_diff(const iop_struct_t *st,
                          const void *v1, const void *v2,
                          sb_t *field_path, sb_t *diff_desc);

static inline void iop_value_print(iop_type_t type, const iop_enum_t *en_desc,
                                   const void *v, sb_t *buf)
{
    switch (type) {
      case IOP_T_BOOL:
        sb_adds(buf, *(const bool *)v ? "true" : "false");
        break;

#define CASE_NUMBER(type, fmt, type_t)                                       \
      case type:                                                             \
        sb_addf(buf, fmt, *(const type_t *)v);                               \
        break;

      CASE_NUMBER(IOP_T_U8, "%u", uint8_t);
      CASE_NUMBER(IOP_T_I8, "%d", int8_t);
      CASE_NUMBER(IOP_T_U16, "%u", uint16_t);
      CASE_NUMBER(IOP_T_I16, "%d", int16_t);
      CASE_NUMBER(IOP_T_U32, "%u", uint32_t);
      CASE_NUMBER(IOP_T_I32, "%d", int32_t);
      CASE_NUMBER(IOP_T_U64, "%ju", uint64_t);
      CASE_NUMBER(IOP_T_I64, "%jd", int64_t);
      CASE_NUMBER(IOP_T_DOUBLE, "%f", double);

#undef CASE_NUMBER

      case IOP_T_ENUM:
        sb_addf(buf, "%*pE", IOP_ENUM_DESC_FMT_ARG_FLAGS(en_desc,
                                                         *(const int32_t *)v,
                                                         IOP_ENUM_FMT_FULL));
        break;

      case IOP_T_STRING:
      case IOP_T_XML:
        sb_add_lstr(buf, *(const lstr_t *)v);
        break;

      case IOP_T_DATA: {
        lstr_t data = *(const lstr_t *)v;

        sb_add_hex(buf, data.data, data.len);
      } break;

      case IOP_T_VOID:
        sb_sets(buf, "void");
        break;

      case IOP_T_UNION:
      case IOP_T_STRUCT:
        e_panic("not supported");
    }
}

/* Returns -1 if no diff found, 0 otherwise. */
static int __iop_first_diff(const iop_struct_t *st,
                            const void *v1, const void *v2,
                            sb_t *field_path, sb_t *diff_desc)
{
    const iop_field_t *fdesc;
    int i = 0;
    const iop_field_t *end;

    if (st->is_union) {
        int tag_v1 = RETHROW(iop_union_get_tag(st, v1));
        int tag_v2 = RETHROW(iop_union_get_tag(st, v2));
        if (tag_v1 != tag_v2) {
            sb_setf(diff_desc, "union field differs (`%*pU` vs `%*pU`)",
                    (uint16_t)tag_v1, st, (uint16_t)tag_v2, st);
            return -1;
        }

        fdesc = get_union_field(st, v1);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *r1;
        const void *r2;
        int len1;
        int len2;
        bool is_array_of_pointers;

        iop_get_field_values_const(fdesc, v1, &r1, &len1,
                                   &is_array_of_pointers);
        iop_get_field_values_const(fdesc, v2, &r2, &len2, NULL);

        if (len1 != len2) {
            if (fdesc->repeat == IOP_R_REPEATED) {
                sb_setf(diff_desc, "array length differs (%d vs %d)",
                        len1, len2);
            } else {
                sb_setf(diff_desc,
                        "field presence differs (field absent on %s value)",
                        len1 ? "second" : "first");
            }
            goto print_field;
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            /* We need to recurse to compare structures & unions. */
            for (i = 0; i < len1; i++) {
                const void *t1, *t2;

                t1 = &IOP_FIELD(const uint8_t, r1, i * fdesc->size);
                t2 = &IOP_FIELD(const uint8_t, r2, i * fdesc->size);

                if (is_array_of_pointers) {
                    t1  = *(void **)t1;
                    t2  = *(void **)t2;
                }

                if (iop_first_diff(fdesc->u1.st_desc, t1, t2,
                                        field_path, diff_desc) >= 0)
                {
                    goto print_field;
                }
            }
        } else {
            for (i = 0; i < len1; i++) {
                const void *t1, *t2;

                t1 = &IOP_FIELD(const uint8_t, r1, i * fdesc->size);
                t2 = &IOP_FIELD(const uint8_t, r2, i * fdesc->size);

                if (!iop_value_equals(fdesc->type, t1, t2)) {
                    const iop_enum_t *en_desc = NULL;

                    if (fdesc->type == IOP_T_ENUM) {
                        en_desc = fdesc->u1.en_desc;
                    }

                    sb_sets(diff_desc, "value differs (`");
                    iop_value_print(fdesc->type, en_desc, t1, diff_desc);
                    sb_adds(diff_desc, "` vs `");
                    iop_value_print(fdesc->type, en_desc, t2, diff_desc);
                    sb_adds(diff_desc, "`)");

                    goto print_field;
                }
            }
        }
    }

    return -1;

  print_field:
    sb_prepend_field(field_path, fdesc, i);
    return 0;
}

static int iop_first_diff(const iop_struct_t *st,
                          const void *v1, const void *v2,
                          sb_t *field_path, sb_t *diff_desc)
{
    THROW_ERR_IF(v1 == v2);

    if (iop_struct_is_class(st)) {
        const iop_struct_t *st2 = *(const iop_struct_t **)v2;

        st = *(const iop_struct_t **)v1;
        if (st != st2) {
            sb_setf(diff_desc, "class type differs (%*pM vs %*pM)",
                    LSTR_FMT_ARG(st->fullname),
                    LSTR_FMT_ARG(st2->fullname));
            return 0;
        }

        do {
            if (__iop_first_diff(st, v1, v2, field_path, diff_desc) >= 0) {
                return 0;
            }
        } while ((st = st->class_attrs->parent));

        return -1;
    }

    return __iop_first_diff(st, v1, v2, field_path, diff_desc);
}

int iop_first_diff_desc(const iop_struct_t *st,
                        const void *v1, const void *v2, sb_t *diff_desc)
{
    SB_1k(field_path);

    sb_reset_reverse(&field_path);
    RETHROW(iop_first_diff(st, v1, v2, &field_path, diff_desc));

    if (field_path.len) {
        assert (field_path.data[0] == '.');
        sb_skip(&field_path, 1);
        sb_prependf(diff_desc, "field `%*pM`: ", SB_FMT_ARG(&field_path));
    }

    return 0;
}

static bool
__iop_equals(const iop_struct_t *st, const uint8_t *v1, const uint8_t *v2)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    if (st->is_union) {
        int tag_v1 = RETHROW(iop_union_get_tag(st, v1));
        int tag_v2 = RETHROW(iop_union_get_tag(st, v2));
        if (tag_v1 != tag_v2)
            return false;
        fdesc = get_union_field(st, v1);
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *r1 = v1 + fdesc->data_offs;
        const void *r2 = v2 + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_REPEATED) {
            /* Here we just check the length of the repeated field, then we
             * position our pointers on values to compare them later. */
            n   = ((lstr_t *)r1)->len;
            if (((lstr_t *)r2)->len != n)
                return false;
            r1  = ((lstr_t *)r1)->data;
            r2  = ((lstr_t *)r2)->data;
        }

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            /* Optional blocks types cannot be compared using a single memcmp
             * we need to handle absent values first. */
            bool has = iop_opt_field_isset(fdesc->type, r1);

            if (has != iop_opt_field_isset(fdesc->type, r2)) {
                return false;
            }
            if (!has) {
                continue;
            }
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                /* Structures & unions must be dereferenced */
                r1  = *(void **)r1;
                r2  = *(void **)r2;
            }
        }

        if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
            bool is_class = iop_field_is_class(fdesc);
            bool is_ref   = iop_field_is_reference(fdesc);

            /* We need to recurse to compare structures & unions. */
            for (int i = 0; i < n; i++) {
                const void *t1, *t2;

                t1 = &IOP_FIELD(const uint8_t, r1, i * fdesc->size);
                t2 = &IOP_FIELD(const uint8_t, r2, i * fdesc->size);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional class fields have to be dereferenced
                     * (dereferencing of optional fields was already done just
                     *  above).
                     */
                    t1  = *(void **)t1;
                    t2  = *(void **)t2;
                }
                if (is_class) {
                    THROW_IF(!iop_equals_desc(fdesc->u1.st_desc, t1, t2),
                             false);
                } else {
                    THROW_IF(!__iop_equals(fdesc->u1.st_desc, t1, t2), false);
                }
            }
        } else
        if (fdesc->type == IOP_T_VOID) {
            /* Two void fields are always equal if present. */
            continue;
        } else
        if ((1 << fdesc->type) & IOP_BLK_OK) {
            /* Blocks (string & co) must be compared one by one */
            for (int i = 0; i < n; i++) {
                const lstr_t *t1 = &IOP_FIELD(const lstr_t, r1, i);
                const lstr_t *t2 = &IOP_FIELD(const lstr_t, r2, i);

                if (t1->len != t2->len || memcmp(t1->data, t2->data, t1->len))
                    return false;
            }
        } else {
            assert (fdesc->size > 0 && "IOPC is probably outdated");
            if (!iop_scalar_equals(fdesc, r1, r2, n))
                return false;
        }
    }

    return true;
}

bool iop_equals_desc(const iop_struct_t *st, const void *v1, const void *v2)
{
    if (v1 && v2) {
        if (iop_struct_is_class(st)) {
            const iop_struct_t *st2 = *(const iop_struct_t **)v2;

            st = *(const iop_struct_t **)v1;
            if (st != st2) {
                return false;
            }

            do {
                if (!__iop_equals(st, v1, v2)) {
                    return false;
                }
            } while ((st = st->class_attrs->parent));

            return true;
        }

        return __iop_equals(st, v1, v2);
    } else {
        return v1 == v2 || (st->size == 0);
    }
}

/* }}} */
/* {{{ Sorting values */
/* {{{ Field path */

typedef enum field_step_type_t {
    FIELD_STEP_TYPE_MOVE,
    FIELD_STEP_TYPE_INDIRECTION,
    FIELD_STEP_TYPE_UNION_FIELD,
    FIELD_STEP_TYPE_GOTO_INDEX,
    FIELD_STEP_TYPE_SCAN_ARRAY,
} field_step_type_t;

typedef struct field_step_t {
    field_step_type_t type : 16;

    /* For step type FIELD_STEP_TYPE_GOTO_INDEX and
     * FIELD_STEP_TYPE_SCAN_ARRAY: size of the elements of the array. */
    uint16_t array_element_sz;

    union {
        /* For step type FIELD_STEP_TYPE_MOVE. Distance (in byte) between the
         * current position and the next field to read. */
        uint16_t offset;

        /* For step type FIELD_STEP_TYPE_UNION_FIELD. Expected union tag for
         * current union. If another field is selected, then the field is
         * considered as missing. */
        uint16_t union_tag;

        /* For step type FIELD_STEP_TYPE_GOTO_INDEX, index of the field in the
         * array. */
        int index;
    } u;
} field_step_t;
GENERIC_INIT(field_step_t, field_step);

qvector_t(field_step, field_step_t);

/* A field path contains the instructions for a quick access to a given field.
 * The path is split in:
 *
 *  - "indirection steps" that contains the number of bytes to skip to the
 *    next pointer to indirect.
 *  - "union steps" that contains the number of bytes to skip to get to the
 *    union and the tag of the field we expect to be selected.
 *
 * Therefore, sequences of inlined struct field will be packed in a single
 * indirection step.
 */
struct iop_field_path_t {
    /* Steps needed to get to the field. */
    qv_t(field_step)    steps;

    /* Description of the field to get. */
    const iop_field_t  *fdesc;

    /* True if the field is an element of an array (eg. the path ends with an
     * index like in the following example: "foo.bar[42]"). */
    bool is_array_element : 1;

    /* True if the field is the name of an IOP class (in this case, the
     * field name is supposed to be '_class'). */
    bool is_typename : 1;

    /* True if the field we're trying to obtain is the length of an array. */
    bool is_array_len : 1;
};

static iop_field_path_t *t_iop_field_path_init(iop_field_path_t *fp)
{
    p_clear(fp, 1);
    t_qv_init(&fp->steps, 16);

    return fp;
}

/* {{{ Get */

/* Get the field(s) associated to a field path for a given IOP
 * struct/class/union either with a callback or by getting a value. */
static iop_value_from_field_res_t
iop_field_path_run(const iop_field_path_t *nonnull field_path,
                   const void *nonnull data, int step_offset,
                   const void **nullable value,
                   iop_ptr_cb_b nullable on_value)
{
    const iop_field_t *fdesc = field_path->fdesc;

    /* XXX Either we use the block callback or we return a value. We cannot do
     * both. */
    assert (!value || !on_value);

    for (int i = step_offset; i < field_path->steps.len; i++) {
        const field_step_t *step = &field_path->steps.tab[i];

        switch (step->type) {
          case FIELD_STEP_TYPE_MOVE:
            data = ((const byte *)data) + step->u.offset;
            break;

          case FIELD_STEP_TYPE_INDIRECTION:
            /* Pointed structure or union (optional), or classes */
            data = *((void **)data);
            if (!data) {
                /* TODO Error for mandatory fields maybe ? */
                return IOP_FIELD_NOT_SET;
            }
            break;

          case FIELD_STEP_TYPE_UNION_FIELD:
            /* Check if the selected member of the union is the one we want
             * (the one specified in field_path), and if not this object is
             * considered as NULL in the sort/filter. */
            THROW_IF(*(const uint16_t *)data != step->u.union_tag,
                     IOP_FIELD_NOT_SET);
            break;

          case FIELD_STEP_TYPE_GOTO_INDEX: {
            const i8__array_t *array = data;
            ssize_t index = step->u.index;

            if (index < 0) {
                /* Negative index: array[-1] is the last element of 'array'.
                 */
                index = array->len + index;
            }
            THROW_IF(index >= array->len || index < 0, IOP_FIELD_NOT_SET);

            data = array->tab + index * step->array_element_sz;
          } break;

          case FIELD_STEP_TYPE_SCAN_ARRAY: {
            const i8__array_t *array = data;

            /* This mode is for block mode only. */
            assert (!value);
            assert (on_value);

            data = array->tab;
            tab_for_each_pos(j, array) {
                iop_value_from_field_res_t res;

                res = iop_field_path_run(field_path, data, i + 1, NULL,
                                         on_value);
                THROW_ERR_IF(res == IOP_FIELD_ERROR);
                data = (const byte *)data + step->array_element_sz;
            }

            return 0;
          } break;
        }
    }

    if (field_path->is_typename) {
        const iop_struct_t *st = *(const void **)data;

        data = &st->fullname;
    } else
    if (fdesc->repeat == IOP_R_REPEATED) {
        if (!field_path->is_array_element && !field_path->is_array_len) {
            const i8__array_t *array = data;

            THROW_IF(!array->len, IOP_FIELD_NOT_SET);
        }
    } else
    if (fdesc->repeat == IOP_R_OPTIONAL && iop_type_is_scalar(fdesc->type)) {
        data = iop_opt_field_getv_const(fdesc->type, data);
        THROW_IF(!data, IOP_FIELD_NOT_SET);
    }

    if (value) {
        *value = data;
    }
    if (on_value && on_value(data) < 0) {
        return IOP_FIELD_ERROR;
    }
    return 0;
}

static int iop_get_fieldp(const void *nonnull data,
                          const iop_field_path_t *nonnull field_path,
                          const void **nonnull value)
{
    return iop_field_path_run(field_path, data, 0, value, NULL);
}

/* }}} */
/* {{{ Compile */

/* Allow the field paths to contain wildcards array indexes '[*]'.
 * Field paths with wildcards can only be run with
 * 'iop_field_path_for_each_value()'. */
#define FIELD_PATH_ALLOW_WILDCARD  (1 << 0)

static int
t_iop_compile_field_path(const iop_struct_t *st, lstr_t field_path_s,
                         int flags, iop_field_path_t *fp, sb_t *err)
{
    const iop_field_t *fdesc = NULL;
    pstream_t field_path_ps = ps_initlstr(&field_path_s);
    const iop_struct_t *it = st;
    field_step_t *step;

    /* Don't use the same field path twice. */
    assert (!fp->steps.len);

    if (ps_done(&field_path_ps)) {
        if (err) {
            sb_adds(err, "cannot process empty field path");
        }
        return -1;
    }
    step = NULL;
    while (!ps_done(&field_path_ps)) {
        pstream_t fname;
        opt_i32_t index = OPT_NONE;
        bool scan_array = false;

        RETHROW(parse_field_from_path(&field_path_ps, &fname, &index,
                                      &scan_array, err));
        if (scan_array && !(flags & FIELD_PATH_ALLOW_WILDCARD)) {
            if (err) {
                sb_sets(err, "unexpected wildcard");
            }
            return -1;
        }

        if (ps_strequal(&fname, "_class")) {
            if (!iop_struct_is_class(it)) {
                if (err) {
                    sb_adds(err,
                            "cannot fetch typename of a non-class field");
                }
                return -1;
            }
            if (!ps_done(&field_path_ps)) {
                if (err) {
                    sb_adds(err, "cannot fetch subfield of a typename");
                }
                return -1;
            }
            fp->is_typename = true;
            break;
        }

        if (iop_field_find_by_name(it, LSTR_PS_V(&fname), NULL,
                                   &fdesc) < 0)
        {
            if (err) {
                sb_addf(err, "cannot process field path `%*pM', "
                        "field `%*pM' is unknown in structure `%*pM'",
                        LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname),
                        LSTR_FMT_ARG(it->fullname));
            }
            return -1;
        }

        if (it->is_union) {
            step = field_step_init(qv_growlen(&fp->steps, 1));
            step->type = FIELD_STEP_TYPE_UNION_FIELD;
            step->u.union_tag = fdesc->tag;
        }
        if (fdesc->repeat == IOP_R_REPEATED && !OPT_ISSET(index)
        &&  lstr_equal(LSTR_PS_V(&field_path_ps), LSTR("len")))
        {
            ps_skip_upto(&field_path_ps, ps_end(&field_path_ps));

            /* Length of arrays containing values of repeated fields can be
             * accessed with '.len'. */
            fp->is_array_len = true;
        }
        if (ps_done(&field_path_ps)) {
            fp->fdesc = fdesc;
        }

        if (fdesc->data_offs || fp->is_array_len) {
            if (!step || step->type != FIELD_STEP_TYPE_MOVE) {
                step = field_step_init(qv_growlen(&fp->steps, 1));
                step->type = FIELD_STEP_TYPE_MOVE;
            }
            step->u.offset += fdesc->data_offs;

            if (fp->is_array_len) {
                /* Position the pointer on the array length. */
                step->u.offset += offsetof(i8__array_t, len);

                return 0;
            }
        }

        if (fdesc->repeat == IOP_R_REPEATED) {
            if (scan_array || OPT_ISSET(index)) {
                step = field_step_init(qv_growlen(&fp->steps, 1));
                step->array_element_sz = fdesc->size;

                if (scan_array) {
                    step->type = FIELD_STEP_TYPE_SCAN_ARRAY;
                } else {
                    step->type = FIELD_STEP_TYPE_GOTO_INDEX;
                    step->u.index = OPT_VAL(index);
                }
                if (ps_done(&field_path_ps)) {
                    fp->is_array_element = true;
                }
            } else
            if (!ps_done(&field_path_ps)) {
                if (err) {
                    sb_addf(err, "cannot process field path `%*pM', "
                            "field `%*pM' is repeated in structure `%*pM'",
                            LSTR_FMT_ARG(field_path_s), PS_FMT_ARG(&fname),
                            LSTR_FMT_ARG(it->fullname));
                }
                return -1;
            }
        } else
        if (OPT_ISSET(index)) {
            if (err) {
                sb_addf(err, "got index but field `%*pM:%*pM' "
                        "is not repeated", LSTR_FMT_ARG(it->fullname),
                        PS_FMT_ARG(&fname));
            }
            return -1;
        }

        if (fdesc->type == IOP_T_STRUCT || fdesc->type == IOP_T_UNION) {
            it = fdesc->u1.st_desc;

            if (iop_field_is_pointed(fdesc)) {
                step = field_step_init(qv_growlen(&fp->steps, 1));
                step->type = FIELD_STEP_TYPE_INDIRECTION;
            }
        }
    }

    return 0;
}

/* }}} */
/* {{{ IOP field path public API */

const iop_field_path_t *nullable
t_iop_field_path_compile(const iop_struct_t *nonnull st, lstr_t path,
                         sb_t *nullable err)
{
    iop_field_path_t *fp;

    fp = t_iop_field_path_init(t_new_raw(iop_field_path_t, 1));
    RETHROW_NP(t_iop_compile_field_path(st, path, FIELD_PATH_ALLOW_WILDCARD,
                                        fp, err));

    return fp;
}

void iop_field_path_get_type(const iop_field_path_t *nonnull fp,
                             iop_full_type_t *nonnull type,
                             bool *nonnull is_array)
{
    if (fp->is_typename) {
        *type = IOP_FTYPE_STRING;
        *is_array = false;
    } else
    if (fp->is_array_len) {
        *type = IOP_FTYPE_I32;
        *is_array = false;
    } else {
        p_clear(type, 1);
        type->type = fp->fdesc->type;
        if (type->type == IOP_T_ENUM) {
            type->en = fp->fdesc->u1.en_desc;
        } else
        if (!iop_type_is_scalar(type->type)) {
            type->st = fp->fdesc->u1.st_desc;
        }
        if (fp->is_array_element) {
            *is_array = false;
        } else {
            *is_array = fp->fdesc->repeat == IOP_R_REPEATED;
        }
    }
}

int iop_field_path_for_each_value(const iop_field_path_t *nonnull fp,
                                  const void *nonnull st_ptr,
                                  iop_ptr_cb_b nonnull on_value)
{
    THROW_ERR_IF(iop_field_path_run(fp, st_ptr, 0, NULL, on_value) ==
                 IOP_FIELD_ERROR);
    return 0;
}

/* }}} */
/* }}} */
/* {{{ cmp functions */

static cmp_f iop_get_cmp_fun(iop_type_t type)
{
    switch (type) {
      case IOP_T_I8:
        return &cmp_i8;
      case IOP_T_U8:
        return &cmp_u8;
      case IOP_T_I16:
        return &cmp_i16;
      case IOP_T_U16:
        return &cmp_u16;
      case IOP_T_ENUM:
        return &cmp_i32;
      case IOP_T_I32:
        return &cmp_i32;
      case IOP_T_U32:
        return &cmp_u32;
      case IOP_T_I64:
        return &cmp_i64;
      case IOP_T_U64:
        return &cmp_u64;
      case IOP_T_BOOL:
        return &cmp_bool;
      case IOP_T_DOUBLE:
        return &cmp_double;
      case IOP_T_UNION:
        return &cmp_u16; /* XXX: we compare the union tag. */
      case IOP_T_STRING:
        return &cmp_lstr_iutf8;
      case IOP_T_XML:
        return &cmp_lstr_iutf8;
      case IOP_T_DATA:
        return &cmp_lstr_bin;
      case IOP_T_VOID:
        return NULL; /* XXX: cmp func is get but never called for void */

      case IOP_T_STRUCT:
        break;
    }
    e_panic("iop_type unsupported");
}

/*}}}*/
/* {{{ equality functions */

/* Equality functions must return 0 if values are equal and another value of
 * values are different. */

static int iop_string_sql_like(const void *s1, const void *s2)
{
    return lstr_utf8_is_ilike(*(const lstr_t *)s1,
                              *(const lstr_t *)s2) ? 0 : -1;
}

static cmp_f iop_get_equal_fun_sql_like(iop_type_t type)
{
    if (type == IOP_T_STRING) {
        return &iop_string_sql_like;
    }

    return iop_get_cmp_fun(type);
}

/*}}}*/
/* {{{ iop_msort */

typedef struct iop_sort_priv_t {
    iop_field_path_t fp;
    int flags;
} iop_sort_priv_t;

qvector_t(iop_sort_p, iop_sort_priv_t);

static int
iop_cmp_value(iop_type_t ftype, const iop_struct_t *nullable st_desc,
              size_t fsize, iop_repeat_t repeat, bool need_indirection,
              const void *nonnull r1, const void *nonnull r2);

static int
compare_field(const void *d1, const void *d2, const iop_sort_priv_t *priv)
{
    bool d1_is_set = iop_get_fieldp(d1, &priv->fp, &d1) >= 0;
    bool d2_is_set = iop_get_fieldp(d2, &priv->fp, &d2) >= 0;
    int res;

    if (!d1_is_set && !d2_is_set) {
        return 0;
    }
    if (!d1_is_set) {
        return (priv->flags & IOP_SORT_NULL_FIRST) ? -1 : 1;
    }
    if (!d2_is_set) {
        return (priv->flags & IOP_SORT_NULL_FIRST) ? 1 : -1;
    }
    if (d1 == d2) {
        return 0;
    }

    if (priv->fp.is_typename) {
        res = lstr_utf8_icmp(*(lstr_t *)d1, *(lstr_t *)d2);
    } else
    if (priv->fp.is_array_len) {
        res = CMP(*(int *)d1, *(int *)d2);
    } else {
        const iop_field_t *fdesc = priv->fp.fdesc;
        iop_repeat_t repeat;
        const iop_struct_t *st_desc = NULL;
        bool need_indirection = false;

        repeat = fdesc->repeat;
        if (repeat != IOP_R_REPEATED || priv->fp.is_array_element) {
            /* XXX iop_get_fieldp() already did whatever is necessary to get a
             * proper field pointer. */
            repeat = IOP_R_REQUIRED;
        }

        if (!iop_type_is_scalar(fdesc->type)) {
            st_desc = fdesc->u1.st_desc;

            if (repeat == IOP_R_REPEATED) {
                /* XXX We only need indirection on arrays of objects. In other
                 * cases, 'iop_get_fieldp()' always give a simple pointer on
                 * the targeted field. */
                /* XXX We check whether the fdesc is a reference in case
                 * arrays of references become an IOP feature. */
                need_indirection = iop_struct_is_class(st_desc) ||
                    iop_field_is_reference(fdesc);
            }
        }

        res = iop_cmp_value(fdesc->type, st_desc, fdesc->size, repeat,
                            need_indirection, d1, d2);
    }

    return priv->flags & IOP_SORT_REVERSE ? -res : res;
}

int iop_msort_desc(const iop_struct_t *st, void *vec, int len,
                   const qv_t(iop_sort) *params, sb_t *err)
{
    t_scope;
    bool is_class = iop_struct_is_class(st);
    qv_t(iop_sort_p) sorts;

    if (unlikely(params->len == 0)) {
        return 0;
    }

    t_qv_init(&sorts, params->len);
    qv_growlen(&sorts, params->len);

    tab_enumerate_ptr(pos, sort, params) {
        iop_sort_priv_t *priv = &sorts.tab[pos];

        t_iop_field_path_init(&priv->fp);
        RETHROW(t_iop_compile_field_path(st, sort->field_path, 0, &priv->fp,
                                         err));

        if (priv->fp.fdesc
        &&  priv->fp.fdesc->type == IOP_T_VOID
        &&  priv->fp.fdesc->repeat == IOP_R_REQUIRED)
        {
            if (err) {
                sb_addf(err, "cannot sort on void required field `%*pM'",
                        LSTR_FMT_ARG(sort->field_path));
            }
            return -1;
        }

        priv->flags = sort->flags;
    }

    __qv_sort(vec, is_class ? sizeof(void *) : st->size, len,
        ^int (const void *d1, const void *d2) {
            const qv_t(iop_sort_p) *_sorts = &sorts;

            if (is_class) {
                d1 = *(void **)d1;
                d2 = *(void **)d2;
            }

            tab_for_each_ptr(sort, _sorts) {
                int ret = compare_field(d1, d2, sort);

                if (ret) {
                    return ret;
                }
            }
            return 0;
        });

    return 0;
}

int iop_sort_desc(const iop_struct_t *st, void *vec, int len,
                  lstr_t field_path, int flags, sb_t *err)
{
    qv_t(iop_sort) params;
    iop_sort_t param = {
        .field_path = field_path,
        .flags = flags,
    };

    qv_init_static(&params, &param, 1);
    return iop_msort_desc(st, vec, len, &params, err);
}

/* }}} */
/* {{{ IOP arbitrary sorting function */

#define CMP_RETHROW(expr)                                                    \
    do {                                                                     \
        int __cmp_res = (expr);                                              \
        THROW_IF(__cmp_res, __cmp_res);                                      \
    } while (0)

static int __iop_cmp(const iop_struct_t *st, const void *v1, const void *v2);

static int
iop_cmp_value(iop_type_t ftype, const iop_struct_t *nullable st_desc,
              size_t fsize, iop_repeat_t repeat, bool need_indirection,
              const void *nonnull r1, const void *nonnull r2)
{
    int n = 1;
    int n1 = 1;
    int n2 = 1;

    if (repeat == IOP_R_REPEATED) {
        /* Here we just check the length of the repeated field, then we
         * position our pointers on values to compare them later. */
        n1   = ((iop_array_u8_t *)r1)->len;
        n2   = ((iop_array_u8_t *)r2)->len;
        r1  = ((iop_array_u8_t *)r1)->tab;
        r2  = ((iop_array_u8_t *)r2)->tab;
        n = MIN(n1, n2);
    } else
    if (repeat == IOP_R_OPTIONAL) {
        /* Optional blocks types cannot be compared using a single memcmp
         * we need to handle absent values first. */
        bool has = iop_opt_field_isset(ftype, r1);

        CMP_RETHROW(CMP(has, iop_opt_field_isset(ftype, r2)));
        if (!has) {
            return 0;
        }
    }

    if (ftype == IOP_T_VOID) {
        /* Two void fields are always equal if present. */
        return 0;
    } else {
        cmp_f cmp_scalar = st_desc ? NULL : iop_get_cmp_fun(ftype);
        const uint8_t *p1 = r1;
        const uint8_t *p2 = r2;

        for (int i = 0; i < n; i++) {
            if (st_desc) {
                /* We need to recurse to compare structures & unions. */
                CMP_RETHROW(iop_cmp_desc(st_desc,
                                need_indirection ? *(void **)p1 : p1,
                                need_indirection ? *(void **)p2 : p2));
            } else {
                CMP_RETHROW(cmp_scalar(p1, p2));
            }
            p1 += fsize;
            p2 += fsize;
        }
    }

    CMP_RETHROW(CMP(n1, n2));

    return 0;
}

int iop_cmp_field(const iop_field_t *nonnull fdesc,
                  const void *nonnull st1, const void *nonnull st2)
{
    const void *r1 = (const uint8_t *)st1 + fdesc->data_offs;
    const void *r2 = (const uint8_t *)st2 + fdesc->data_offs;
    const iop_struct_t *st_desc = NULL;

    if (!iop_type_is_scalar(fdesc->type)) {
        st_desc = fdesc->u1.st_desc;
    }

    return iop_cmp_value(fdesc->type, st_desc, fdesc->size, fdesc->repeat,
                         iop_field_is_pointed(fdesc), r1, r2);
}

static int
__iop_cmp(const iop_struct_t *st, const void *v1, const void *v2)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;

    THROW_IF(v1 == v2, 0);

    if (st->is_union) {
        int tag_v1 = RETHROW(iop_union_get_tag(st, v1));
        int tag_v2 = RETHROW(iop_union_get_tag(st, v2));

        fdesc = get_union_field(st, v1);
        if (tag_v1 != tag_v2) {
            const iop_field_t *f2;

            f2 = get_union_field(st, v2);
            /* TODO Flag to compare tag only. */
            CMP_RETHROW(lstr_utf8_icmp(fdesc->name, f2->name));
            assert (false);

            return CMP(tag_v1, tag_v2);
        }
        end   = fdesc + 1;
    } else {
        fdesc = st->fields;
        end   = fdesc + st->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        CMP_RETHROW(iop_cmp_field(fdesc, v1, v2));
    }

    return 0;
}

int iop_cmp_desc(const iop_struct_t *st, const void *v1, const void *v2)
{
    if (!v1 || !v2) {
        return st->size ? CMP(v1, v2) : 0;
    }

    if (iop_struct_is_class(st)) {
        const iop_struct_t *st2 = *(const iop_struct_t **)v2;

        st = *(const iop_struct_t **)v1;
        if (st != st2) {
            /* TODO Have a flag to compare class IDs instead. */
            CMP_RETHROW(lstr_utf8_icmp(st->fullname, st2->fullname));
            assert (false);

            return CMP(st, st2);
        }

        do {
            CMP_RETHROW(__iop_cmp(st, v1, v2));
        } while ((st = st->class_attrs->parent));

        return 0;
    }

    return __iop_cmp(st, v1, v2);
}

#undef CMP_RETHROW

static void
__iop_xsort_desc(const iop_struct_t *st, void *vec, int len, bool pointed)
{
    __qv_sort(vec, pointed ? sizeof(void *) : st->size, len,
        ^int (const void *d1, const void *d2) {
            if (pointed) {
                d1 = *(void **)d1;
                d2 = *(void **)d2;
            }

            return iop_cmp_desc(st, d1, d2);
        });
}

void iop_xsort_desc(const iop_struct_t *st, void *vec, int len)
{
    __iop_xsort_desc(st, vec, len, iop_struct_is_class(st));
}

void iop_xpsort_desc(const iop_struct_t *st, const void **vec, int len)
{
    __iop_xsort_desc(st, vec, len, true);
}

/* }}} */

/* }}} */
/* {{{ Filtering values */

static bool iop_filter_is_value_in_array(const void *val,
                                         void * const * values, int len,
                                         cmp_f equal)
{
    /* TODO: sort values and use a bisection. */
    for (int i = 0; i < len; i++) {
        if (equal(val, values[i]) == 0) {
            return true;
        }
    }
    return false;
}

static bool iop_filter_val_matches(const byte *vec_read,
                                   const iop_field_path_t *fp,
                                   bool is_pointer, opt_bool_t is_set,
                                   unsigned flags, void * const *values,
                                   int len, cmp_f equal)
{
    bool val_is_set;
    const void *tmp;
    const void *val;
    bool val_match_res;

    tmp = is_pointer ? *(void **)vec_read : vec_read;
    val_is_set = iop_get_fieldp(tmp, fp, &val) >= 0;

    if (OPT_ISSET(is_set)) {
        return val_is_set == OPT_VAL(is_set);
    }

    val_match_res = !(flags & IOP_FILTER_INVERT_MATCH);

    if (!val_is_set) {
        return !val_match_res;
    }

    if (fp->fdesc && fp->fdesc->repeat == IOP_R_REPEATED
    &&  !fp->is_array_len && !fp->is_array_element)
    {
        const iop_array_i8_t *array = val;

        for (int i = 0; i < array->len; i++) {
            val = (const char *)array->tab + i * fp->fdesc->size;

            if (iop_filter_is_value_in_array(val, values, len, equal)) {
                return val_match_res;
            }
        }
    } else {
        if (iop_filter_is_value_in_array(val, values, len, equal)) {
            return val_match_res;
        }
    }

    return !val_match_res;
}

static int
__t_iop_filter(const iop_struct_t *st, const void *vec, int len,
               lstr_t field_path, void * const *values,
               int values_len, opt_bool_t is_set, unsigned flags,
               iop_filter_bitmap_op_t bitmap_op, byte **bitmap, sb_t *err)
{
    bool is_pointer = iop_struct_is_class(st);
    iop_field_path_t fp;
    cmp_f equal = NULL;
    const byte *vec_read = vec;
    size_t elem_size = is_pointer ? sizeof(void *) : st->size;

    t_iop_field_path_init(&fp);
    /* TODO Support wildcards. */
    RETHROW(t_iop_compile_field_path(st, field_path, 0, &fp, err));
    assert (fp.is_typename || fp.fdesc);

    if (OPT_ISSET(is_set)) {
        assert (!values_len);
        if (!fp.is_typename && !fp.is_array_len
        &&  fp.fdesc->repeat != IOP_R_OPTIONAL
        &&  fp.fdesc->repeat != IOP_R_REPEATED)
        {
            if (err) {
                sb_addf(err, "field `%*pM' in the structure `%*pM' is "
                        "neither optional nor repeated",
                        LSTR_FMT_ARG(field_path), LSTR_FMT_ARG(st->fullname));
            }
            return -1;
        }
    } else {
        iop_type_t type;

        if (fp.is_typename) {
            type = IOP_T_STRING;
        } else
        if (fp.is_array_len) {
            type = IOP_T_I32;
        } else {
            if (fp.fdesc->type == IOP_T_STRUCT) {
                if (err) {
                    sb_addf(err, "cannot filter on sub-structure `%*pM'",
                            LSTR_FMT_ARG(field_path));
                }
                return -1;
            }
            if (fp.fdesc->type == IOP_T_VOID) {
                if (err) {
                    sb_addf(err, "cannot filter on void field `%*pM'",
                            LSTR_FMT_ARG(field_path));
                }
                return -1;
            }
            type = fp.fdesc->type;
        }

        if (flags & IOP_FILTER_SQL_LIKE) {
            equal = iop_get_equal_fun_sql_like(type);
        } else {
            equal = iop_get_cmp_fun(type);
        }
    }

    if (!*bitmap) {
        *bitmap = t_new(byte, BITS_TO_ARRAY_LEN(byte, len));
        bitmap_op = BITMAP_OP_OR;
    }

    for (int i = 0; i < len; i++) {
        switch (bitmap_op) {
#define VAL_MATCHES()                                                        \
            iop_filter_val_matches(vec_read, &fp, is_pointer, is_set,        \
                                   flags, values, values_len, equal)

          case BITMAP_OP_AND:
            if (TST_BIT(*bitmap, i) && !VAL_MATCHES()) {
                RST_BIT(*bitmap, i);
            }
            break;

          case BITMAP_OP_OR:
            if (!TST_BIT(*bitmap, i) && VAL_MATCHES()) {
                SET_BIT(*bitmap, i);
            }
            break;

#undef VAL_MATCHES
        }

        vec_read += elem_size;
    }

    return 0;
}

int iop_filter(const iop_struct_t *st, void *vec, int *len, lstr_t field_path,
               void * const *values, int values_len, unsigned flags,
               sb_t *err)
{
    t_scope;
    byte *bitmap = NULL;

    RETHROW(t_iop_filter_bitmap(st, vec, *len, field_path,
                                values, values_len, flags,
                                BITMAP_OP_OR, &bitmap, err));
    iop_filter_bitmap_apply(st, vec, len, bitmap);
    return 0;
}

int iop_filter_opt(const iop_struct_t *st, void *vec, int *len,
                   lstr_t field_path, bool is_set, sb_t *err)
{
    t_scope;
    byte *bitmap = NULL;

    RETHROW(t_iop_filter_opt_bitmap(st, vec, *len, field_path,
                                    is_set, BITMAP_OP_AND, &bitmap, err));
    iop_filter_bitmap_apply(st, vec, len, bitmap);
    return 0;
}

int t_iop_filter_bitmap(const iop_struct_t *st, const void *vec, int len,
                        lstr_t field_path, void * const *values,
                        int values_len, unsigned flags,
                        iop_filter_bitmap_op_t bitmap_op, byte **bitmap,
                        sb_t *err)
{
    return __t_iop_filter(st, vec, len, field_path, values,
                          values_len, (opt_bool_t)OPT_NONE, flags,
                          bitmap_op, bitmap, err);
}

int t_iop_filter_opt_bitmap(const iop_struct_t *st, const void *vec, int len,
                            lstr_t field_path, bool is_set,
                            iop_filter_bitmap_op_t bitmap_op, byte **bitmap,
                            sb_t *err)
{
    return __t_iop_filter(st, vec, len, field_path, NULL, 0,
                          (opt_bool_t)OPT(is_set), 0, bitmap_op, bitmap, err);
}

void iop_filter_bitmap_apply(const iop_struct_t *st, void *vec, int *len,
                             const byte *bitmap)
{
    bool is_pointer = iop_struct_is_class(st);
    size_t elem_size = is_pointer ? sizeof(void *) : st->size;
    const byte *vec_read = vec;
    const byte *vec_start = vec;
    byte *vec_write = vec;

    for (int i = 0; i < *len; i++) {
        if (!TST_BIT(bitmap, i)) {
            if (vec_start != vec_read && vec_write != vec_read) {
                p_move(vec_write, vec_start, vec_read - vec_start);
            }
            vec_write += vec_read - vec_start;
            vec_start = vec_read + elem_size;
        }

        vec_read += elem_size;
    }

    if (vec_start != vec_read && vec_write != vec_read) {
        p_move(vec_write, vec_start, vec_read - vec_start);
        vec_write += vec_read - vec_start;
    }
    assert (elem_size > 0);
    *len = (vec_write - (byte *)vec) / elem_size;
}

/* }}} */
/* {{{ Hashing values */

#define ATTRS
#define F(x)  x
#include "hashing-values.in.c"
#undef F
#undef ATTRS

/* }}} */
/* {{{ Check constraints before packing */

typedef struct iop_err_t {
    sb_t err;
    sb_t path;
    const iop_struct_t *desc;
} iop_err_t;

static __thread iop_err_t iop_err_g;

__attribute__((constructor))
static void iop_init_err(void)
{
    if (unlikely(iop_err_g.err.size == 0)) {
        p_clear(&iop_err_g, 1);
        sb_init(&iop_err_g.err);
        sb_init(&iop_err_g.path);
    }
}

static void iop_wipe_err(void)
{
    if (iop_err_g.err.size) {
        sb_wipe(&iop_err_g.err);
        sb_wipe(&iop_err_g.path);
        iop_err_g.desc = NULL;
    }
}

thr_hooks(iop_init_err, iop_wipe_err);

void iop_set_verr(const char *fmt, va_list ap)
{
    sb_setvf(&iop_err_g.err, fmt, ap);
}

int iop_set_err(const char *fmt, ...)
{
    va_list ap;

    va_start(ap, fmt);
    iop_set_verr(fmt, ap);
    va_end(ap);
    return -1;
}

int iop_set_err2(const lstr_t *s)
{
    sb_set(&iop_err_g.err, s->s, s->len);
    return -1;
}

void iop_clear_err(void)
{
    sb_reset(&iop_err_g.err);
    sb_reset(&iop_err_g.path);
    iop_err_g.desc = NULL;
}

static void iop_expand_err(void)
{
    if (!iop_err_g.desc) {
        return;
    }
    if (iop_err_g.path.len) {
        sb_prependf(&iop_err_g.err, "in %s of type %s: ",
                    iop_err_g.path.data + 1, iop_err_g.desc->fullname.s);
    } else {
        sb_prependf(&iop_err_g.err, "in type %s: ",
                    iop_err_g.desc->fullname.s);
    }
    iop_err_g.desc = NULL;
}

const char *iop_get_err(void)
{
    if (iop_err_g.err.len) {
        iop_expand_err();
        return iop_err_g.err.data;
    }
    return NULL;
}

lstr_t iop_get_err_lstr(void)
{
    if (iop_err_g.err.len) {
        iop_expand_err();
        return LSTR_INIT_V(iop_err_g.err.data, iop_err_g.err.len);
    }
    return LSTR_NULL_V;
}

static int
__iop_check_constraints_struct(const iop_struct_t *desc, const void *val);
static int
__iop_check_constraints_class(const iop_struct_t *desc, const void *val);

__cold static void sb_prepend_field(sb_t *sb, const iop_field_t *fdesc, int j)
{
    if (fdesc->repeat == IOP_R_REPEATED) {
        sb_prependf(sb, ".%s[%d]", fdesc->name.s, j);
    } else {
        sb_prependf(sb, ".%s", fdesc->name.s);
    }
}

static const char *t_fmt_field(const iop_field_t *fdesc, int j)
{
    if (fdesc->repeat == IOP_R_REPEATED) {
        return t_fmt("%s[%d]", fdesc->name.s, j);
    } else {
        return fdesc->name.s;
    }
}

int iop_field_check_constraints(const iop_struct_t *desc, const iop_field_t
                                *fdesc, const void *ptr, int n, bool recurse)
{
    check_constraints_f *check_constraints = NULL;

    if ((check_constraints = iop_field_get_constraints_cb(desc, fdesc))) {
        if (unlikely(check_constraints(ptr, n) < 0)) {
            iop_err_g.desc = desc;
            sb_reset(&iop_err_g.path);
            return -1;
        }
    }
    switch (fdesc->type) {
      case IOP_T_ENUM:
        if (TST_BIT(&fdesc->u1.en_desc->flags, IOP_ENUM_STRICT)) {
            const iop_enum_t *en_desc = fdesc->u1.en_desc;

            for (int j = 0; j < n; j++) {
                int32_t intval = IOP_FIELD(int32_t, ptr, j);

                if (iop_ranges_search(en_desc->ranges,
                                      en_desc->ranges_len, intval) != -1)
                {
                    continue;
                } else {
                    t_scope;

                    iop_err_g.desc = desc;
                    sb_reset(&iop_err_g.path);
                    iop_set_err("%d is not a valid value for enum %*pM"
                                " (field %s)",
                                intval, LSTR_FMT_ARG(en_desc->fullname),
                                t_fmt_field(fdesc, j));
                    return -1;
                }
            }
        }
        break;

      case IOP_T_I8:
      case IOP_T_U8:
      case IOP_T_I16:
      case IOP_T_U16:
      case IOP_T_I32:
      case IOP_T_U32:
      case IOP_T_I64:
      case IOP_T_U64:
      case IOP_T_BOOL:
      case IOP_T_DOUBLE:
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
      case IOP_T_VOID:
        break;

      case IOP_T_UNION:
      case IOP_T_STRUCT: {
        bool is_class;
        bool is_ref;

        if (!recurse) {
            return 0;
        }

        is_class = iop_field_is_class(fdesc);
        is_ref   = iop_field_is_reference(fdesc);
        for (int j = 0; j < n; j++) {
            int ret;
            const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);

            if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                /* Non-optional class fields have to be dereferenced
                 * (dereferencing of optional fields was already done
                 *  by the caller).
                 */
                v = *(void **)v;
            }
            if (is_class) {
                ret = __iop_check_constraints_class(fdesc->u1.st_desc, v);
            } else {
                ret = __iop_check_constraints_struct(fdesc->u1.st_desc, v);
            }
            if (ret < 0) {
                sb_prepend_field(&iop_err_g.path, fdesc, j);
                return -1;
            }
        }
        break;
      }
    }

    return 0;
}

static int
__iop_check_constraints_struct(const iop_struct_t *desc, const void *val)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    unsigned           desc_flags = desc->flags;

    if (!TST_BIT(&desc_flags, IOP_STRUCT_HAS_CONSTRAINTS))
        return 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_opt_field_isset(fdesc->type, ptr)) {
                continue;
            }
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                ptr = *(void **)ptr;
            }
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0) {
                unsigned fdesc_flags = fdesc->flags;

                if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY)) {
                    iop_err_g.desc = desc;
                    sb_reset(&iop_err_g.path);
                    iop_set_err("empty array not allowed for field `%*pM`",
                                LSTR_FMT_ARG(fdesc->name));
                    return -1;
                }
                continue;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field if it's still equal to its default value */
            if (iop_field_is_defval(fdesc, ptr, true))
                continue;
        }

        RETHROW(iop_field_check_constraints(desc, fdesc, ptr, n, true));
    }

    return 0;
}

static int
__iop_check_constraints_class(const iop_struct_t *desc, const void *val)
{
    desc = *(const iop_struct_t **)val;

    if (unlikely(desc->class_attrs->is_abstract)) {
        iop_err_g.desc = desc;
        sb_reset(&iop_err_g.path);
        return iop_set_err("'%*pM' is an abstract class",
                           LSTR_FMT_ARG(desc->fullname));
    }

    do {
        RETHROW(__iop_check_constraints_struct(desc, val));
    } while ((desc = desc->class_attrs->parent));

    return 0;
}

int iop_check_constraints_desc(const iop_struct_t *desc, const void *val)
{
    int ret;

    if (iop_struct_is_class(desc)) {
        ret = __iop_check_constraints_class(desc, val);
    } else {
        ret = __iop_check_constraints_struct(desc, val);
    }
    return ret;
}

/* }}} */
/* {{{ Get value encoding size */

void iop_bpack_set_threaded_threshold(size_t threshold)
{
    /* XXX: Repeated fields having at least threaded_pack_threshold elements
     * will be packed using multi-threading (if thread jobs are enabled).
     * It must be at least 2 because one-element arrays are handled in a
     * specific way that prevents the multi-threaded path to work (and anyway,
     * this would be useless). */
    if (!expect(threshold >= 2)) {
        return;
    }

    _G.threaded_pack_threshold = threshold;
}

static bool
iop_bpack_is_threadable(const iop_field_t *fdesc, int flags, size_t n)
{
    return ((fdesc->type == IOP_T_STRUCT || fdesc->type == IOP_T_UNION)
        &&  fdesc->repeat == IOP_R_REPEATED
        &&  !(flags & IOP_BPACK_MONOTHREAD)
        &&  module_is_loaded(MODULE(thr))
        &&  thr_parallelism_g > 1
        &&  n >= _G.threaded_pack_threshold);
}

static int __iop_bpack_size_class(const iop_struct_t *desc, const void *val,
                                  const unsigned flags, qv_t(i32) *szs,
                                  bool in_thread);
static void iop_bpack_size_struct_union_job(thr_job_t *job, thr_syn_t *syn);
static void iop_bpack_size_class_job(thr_job_t *job, thr_syn_t *syn);

typedef struct pack_size_job_t {
    thr_job_t job;
    const iop_field_t *fdesc;
    const void *v;
    unsigned flags;
    int32_t n;
    int chunk_id;
} pack_size_job_t;

typedef struct pack_size_res_t {
    int32_t packed_len;
    qv_t(i32) szs;
    int chunk_id;
} pack_size_res_t;
qvector_t(pack_size_res, pack_size_res_t);

typedef struct pack_size_td_t {
    thr_td_t td;
    qv_t(pack_size_res) res;
} pack_size_td_t;

static int get_chunk_count(size_t n)
{
    /* chunks of size 200 provide a good performance improvement
     * on 4 and 16 cores machines */
    size_t chunks = DIV_ROUND_UP(n, 200);

    /* at least 1, at most 3 times the processors */
    return CLIP(chunks, MIN(thr_parallelism_g, n), thr_parallelism_g * 3);
}

static int __iop_bpack_size_threaded(const iop_field_t *fdesc,
                                     const void *val, const unsigned flags,
                                     int n, qv_t(i32) *szs)
{
    pack_size_job_t *jobs;
    thr_syn_t syn;
    __block int len = 0;
    __block size_t szs_len_blk = 0;
    size_t szs_len;
    qv_t(pack_size_res) res;
    int chunks_packed_size_offs, chunks_szs_offs;
    unsigned chunk_size;
    int chunk_remainder;
    int n_count = 0;
    bool is_class = iop_field_is_class(fdesc);

    int chunks = get_chunk_count(n);

    jobs = p_new(pack_size_job_t, chunks);
    qv_init(&res);
    qv_growlen(&res, chunks);

    /* Chunk metadata is added between the array length and the element sizes.
     *
     * ╔══════════════════════════════╗          -----------------------------
     * ║ array len                    ║              present in mono packing
     * ╠══════════════════════════════╣          -----------------------------
     * ║ chunk count = n              ║
     * ╠══════════════════════════════╣            added for multi-threaded
     * ║ chunk 0 offset in this array ║ ═══╗               packing
     * ╠══════════════════════════════╣    ║
     * ║ ...                          ║    ║
     * ╠══════════════════════════════╣    ║
     * ║ chunk n offset in this array ║ ═══╬═══╗
     * ╠══════════════════════════════╣    ║   ║
     * ║ chunk 0 packed size          ║    ║   ║
     * ╠══════════════════════════════╣    ║   ║
     * ║ ...                          ║    ║   ║
     * ╠══════════════════════════════╣    ║   ║
     * ║ chunk n packed size          ║    ║   ║
     * ╠══════════════════════════════╣    ║   ║ -----------------------------
     * ║ size of array element 0      ║<═══╝   ║
     * ╠══════════════════════════════╣        ║     present in mono packing
     * ║ ...                          ║        ║
     * ╠══════════════════════════════╣        ║
     * ║ ...                          ║        ║
     * ╠══════════════════════════════╣        ║
     * ║ size of array element N      ║<═══════╝     (N = n * chunk size)
     * ╠══════════════════════════════╣
     * ║ size of array element N+1    ║
     * ╚══════════════════════════════╝          -----------------------------
     */
    qv_growlen(szs, 1);
    szs->tab[szs->len - 1] = chunks;
    chunks_packed_size_offs = szs->len;
    qv_growlen(szs, chunks);
    chunks_szs_offs = szs->len;
    qv_growlen(szs, chunks);
    chunk_size = n / chunks;
    chunk_remainder = n % chunks;

    thr_syn_init(&syn);
    thr_syn_declare_td(&syn, ^{
        pack_size_td_t *td = p_new(pack_size_td_t, 1);

        qv_init(&td->res);
        return &td->td;
    }, ^(thr_td_t **ptd) {
        pack_size_td_t *r;

        r = container_of(*ptd, pack_size_td_t, td);
        qv_wipe(&r->res);
        p_delete(ptd);
    });

    /* chunks are handled manually (instead of thr_for_each)
     * because we need to retrieve and store chunk infos
     * (packed size and szs len) for packing. */
    for (int i = 0; i < chunks; i++) {
        pack_size_job_t *job = &jobs[i];

        if (is_class) {
            job->job.run = iop_bpack_size_class_job;
        } else {
            job->job.run = iop_bpack_size_struct_union_job;
        }
        job->fdesc = fdesc;
        job->n = i < chunk_remainder ? chunk_size + 1 : chunk_size;
        job->flags = flags;
        job->v = (byte *)val + (n_count * fdesc->size);
        job->chunk_id = i;
        thr_syn_schedule(&syn, &job->job);
        n_count += job->n;
    }
    thr_syn_wait(&syn);

    /* each td contains 1-n results, which need to be
     * put in order before inserting in szs */
    thr_syn_collect_td(&syn, ^(const thr_td_t *td) {
        const pack_size_td_t *r;

        r = container_of(td, const pack_size_td_t, td);
        tab_for_each_ptr(e, &r->res) {
            res.tab[e->chunk_id] = *e;
            len += e->packed_len;
            szs_len_blk += e->szs.len;
        }
    });

    /* cannot use the __block variable in qv_grow macro */
    szs_len = szs_len_blk;
    qv_grow(szs, szs_len);
    for (int i = 0; i < res.len; i++) {
        szs->tab[chunks_szs_offs + i] = res.tab[i].packed_len;
        szs->tab[chunks_packed_size_offs + i] =
            szs->len - chunks_packed_size_offs;
        qv_extend(szs, &res.tab[i].szs);
        qv_wipe(&res.tab[i].szs);
    }
    thr_syn_wipe(&syn);
    qv_wipe(&res);
    p_delete(&jobs);
    /* XXX: substract n because we already added it in
     * __iop_bpack_size when we found an IOP_R_REPEATED. */
    return len - n;
}

static int __iop_bpack_size(const iop_struct_t *desc, const void *val,
                            const unsigned flags, qv_t(i32) *szs,
                            bool in_thread)
{
    const iop_field_t *fdesc;
    const iop_field_t *end;
    int len = 0;

    if (desc->is_union) {
        fdesc = get_union_field(desc, val);
        end   = fdesc + 1;
    } else {
        fdesc = desc->fields;
        end   = fdesc + desc->fields_len;
    }

    for (; fdesc < end; fdesc++) {
        const void *ptr = (char *)val + fdesc->data_offs;
        int n = 1;

        if (flags & IOP_BPACK_SKIP_PRIVATE) {
            const iop_field_attrs_t *attrs = iop_field_get_attrs(desc, fdesc);

            if (attrs && TST_BIT(&attrs->flags, IOP_FIELD_PRIVATE)) {
                continue;
            }
        }

        if (fdesc->repeat == IOP_R_OPTIONAL) {
            if (!iop_opt_field_isset(fdesc->type, ptr)) {
                continue;
            }
            if ((1 << fdesc->type) & IOP_STRUCTS_OK) {
                ptr = *(void **)ptr;
            }
        } else
        if (fdesc->repeat == IOP_R_REPEATED) {
            n   = ((lstr_t *)ptr)->len;
            ptr = ((lstr_t *)ptr)->data;
            if (n == 0)
                continue;
            if (n > 1) {
                if ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    int32_t i32 = n * fdesc->size;

                    len += 1 + fdesc->tag_len;
                    len += get_len_len(i32) + i32;
                    continue;
                }
                /* Add:
                 * - 4 to encode the len on 32 bits,
                 * - n because there will be n tags 0 to separate elements.
                 */
                len += 4 + n;
            }
        } else
        if (fdesc->repeat == IOP_R_DEFVAL) {
            /* Skip the field if still equals to its default value */
            if ((flags & IOP_BPACK_SKIP_DEFVAL)
            &&   iop_field_is_defval(fdesc, ptr, true))
            {
                continue;
            }
        }

        len += 1 + fdesc->tag_len;
        switch (fdesc->type) {
          case IOP_T_I8:
            len += n;
            break;
          case IOP_T_U8:
            len += n;
            for (int j = 0; j < n; j++)
                len += IOP_FIELD(uint8_t, ptr, j) >> 7;
            break;
          case IOP_T_I16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int16_t, ptr, j));
            break;
          case IOP_T_U16:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(uint16_t, ptr, j));
            break;
          case IOP_T_I32:
          case IOP_T_ENUM:
            for (int j = 0; j < n; j++)
                len += get_vint32_len(IOP_FIELD(int32_t, ptr, j));
            break;
          case IOP_T_U32:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(uint32_t, ptr, j));
            break;
          case IOP_T_I64:
          case IOP_T_U64:
            for (int j = 0; j < n; j++)
                len += get_vint64_len(IOP_FIELD(int64_t, ptr, j));
            break;
          case IOP_T_BOOL:
            len += n;
            break;
          case IOP_T_VOID:
            if (desc->is_union || fdesc->repeat == IOP_R_OPTIONAL) {
                assert (n == 1);
                len += 1;
            } else {
                /* mandatory void in structs are not packed, remove tag_len */
                len -= (1 + fdesc->tag_len);
            }
            break;
          case IOP_T_DOUBLE:
            len += n * 8;
            break;
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            for (int j = 0; j < n; j++) {
                int32_t i32 = IOP_FIELD(lstr_t, ptr, j).len;
                len += get_len_len(i32 + 1) + i32 + 1;
            }
            break;

          case IOP_T_UNION:
          case IOP_T_STRUCT:
          default: {
            bool is_class = iop_field_is_class(fdesc);
            bool is_ref   = iop_field_is_reference(fdesc);
            bool threadable = iop_bpack_is_threadable(fdesc, flags, n);

            /* do not multi thread packing of an array if we are already
             * multithreading, to avoid recursive thr_syn_wait() that can
             * cause a thread explosion */
            if (threadable && !in_thread) {
                len += __iop_bpack_size_threaded(fdesc, ptr, flags, n, szs);
                break;
            }
            for (int j = 0; j < n; j++) {
                const void *v = &IOP_FIELD(const char, ptr, j * fdesc->size);
                int32_t offs = szs->len;
                int32_t i32;

                qv_growlen(szs, 1);

                if ((is_class || is_ref) && fdesc->repeat != IOP_R_OPTIONAL) {
                    /* Non-optional class fields have to be dereferenced
                     * (dereferencing of optional fields was already done
                     *  just above).
                     */
                    v = *(void **)v;
                }
                if (is_class) {
                    i32 = __iop_bpack_size_class(fdesc->u1.st_desc, v, flags,
                                                 szs, in_thread);
                } else {
                    i32 = __iop_bpack_size(fdesc->u1.st_desc, v, flags, szs,
                                           in_thread);
                }

                szs->tab[offs] = i32;
                len += get_len_len(i32) + i32;

            }
            break;
          }
        }
    }

    return len;
}

/* "in_thread" argument is set to true to avoid thread explosions */
#define bpack_size_struct_union(st_desc, v, flags, szsp)  \
    __iop_bpack_size(st_desc, v, flags, szsp, true);
#define bpack_size_class(st_desc, v, flags, szsp)  \
    __iop_bpack_size_class(st_desc, *(void **)v, flags, &szs, true);

#define GEN_PACK_SIZE_JOB(type)  \
static void                                                                  \
iop_bpack_size_##type##_job(thr_job_t *job, thr_syn_t *syn)                  \
{                                                                            \
    pack_size_job_t *pj = (pack_size_job_t *)job;                            \
    qv_t(i32) szs;                                                           \
    int chunk_len = 0;                                                       \
    pack_size_td_t *td;                                                      \
    int n = pj->n;                                                           \
    const iop_struct_t *st_desc = pj->fdesc->u1.st_desc;                     \
    uint32_t flags = pj->flags;                                              \
    const void *orig_v = pj->v;                                              \
    int fdesc_size = pj->fdesc->size;                                        \
                                                                             \
    qv_init(&szs);                                                           \
    qv_grow(&szs, 1024); /* arbitrary could use some heuristics */           \
                                                                             \
    for (int i = 0; i < n; i++) {                                            \
        const void *v = &IOP_FIELD(const char, orig_v, i * fdesc_size);      \
        int32_t offs = szs.len, i32;                                         \
                                                                             \
        qv_growlen(&szs, 1);                                                 \
        i32 = bpack_size_##type (st_desc, v, flags, &szs);                   \
                                                                             \
        szs.tab[offs] = i32;                                                 \
        chunk_len += get_len_len(i32) + i32 + 1;                             \
    }                                                                        \
                                                                             \
    /* write result to td */                                                 \
    td = container_of(thr_syn_acquire_td(syn), pack_size_td_t, td);          \
    qv_growlen(&td->res, 1);                                                 \
    td->res.tab[td->res.len - 1].szs = szs;                                  \
    td->res.tab[td->res.len - 1].packed_len = chunk_len;                     \
    td->res.tab[td->res.len - 1].chunk_id = pj->chunk_id;                    \
    thr_syn_release_td(syn, &td->td);                                        \
}

GEN_PACK_SIZE_JOB(class)
GEN_PACK_SIZE_JOB(struct_union)
#undef bpack_size_struct_union
#undef bpack_size_class
#undef GEN_PACK_SIZE_JOB

static int __iop_bpack_size_class(const iop_struct_t *desc, const void *val,
                                  const unsigned flags, qv_t(i32) *szs,
                                  bool in_thread)
{
    int size = 0, level_size;
    bool first = true;

    desc = *(const iop_struct_t **)val;

    e_assert(panic, !desc->class_attrs->is_abstract,
             "packing of abstract class '%*pM' is forbidden",
             LSTR_FMT_ARG(desc->fullname));

    /* If this assert fails, you are exporting private classes through
     * a public interface... this is BAD!
     */
    assert (!desc->class_attrs->is_private
            || !(flags & IOP_BPACK_SKIP_PRIVATE));

    do {
        int szs_pos = szs->len;

        qv_growlen(szs, 1);
        level_size = __iop_bpack_size(desc, val, flags, szs, in_thread);
        szs->tab[szs_pos] = level_size;
        size += level_size;
        if (first || level_size) {
            /* Add 1 for tag 0, followed by the class id */
            size += 1 + get_vint32_len(desc->class_attrs->class_id);
            first = false;
        }
    } while ((desc = desc->class_attrs->parent));

    return size;
}

int iop_bpack_size_flags(const iop_struct_t *desc, const void *val,
                         const unsigned flags, qv_t(i32) *szs)
{
    if (flags & IOP_BPACK_STRICT) {
        RETHROW(iop_check_constraints_desc(desc, val));
    }

    /* Put the packer flags in first to reuse them when packing */
    qv_append(szs, flags);

    if (iop_struct_is_class(desc)) {
        return __iop_bpack_size_class(desc, val, flags, szs, false);
    } else {
        return __iop_bpack_size(desc, val, flags, szs, false);
    }
}

/* }}} */
/* {{{ Packing */

static uint8_t *pack_struct(void *dst, const iop_struct_t *, const void *,
                            const unsigned, const int **, bool in_thread);
static uint8_t *pack_class(void *dst, const iop_struct_t *, const void *,
                           const unsigned, const int **, bool in_thread);
static uint8_t *pack_union(void *dst, const iop_struct_t *, const void *,
                           const unsigned, const int **, bool in_thread);

static uint8_t *
pack_value(uint8_t *dst, const iop_struct_t *desc, const iop_field_t *f,
           const void *v, const unsigned flags, const int **szsp,
           bool in_thread)
{
    uint32_t len;

    switch (f->type) {
      case IOP_T_I8:
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        *dst++ = *(int8_t *)v;
        return dst;
      case IOP_T_U8:
        return pack_int32(dst, f->tag, f->tag_len, *(uint8_t *)v);
      case IOP_T_I16:
        return pack_int32(dst, f->tag, f->tag_len, *(int16_t *)v);
      case IOP_T_U16:
        return pack_int32(dst, f->tag, f->tag_len, *(uint16_t *)v);
      case IOP_T_I32:
      case IOP_T_ENUM:
        return pack_int32(dst, f->tag, f->tag_len, *(int32_t *)v);
      case IOP_T_U32:
        return pack_int64(dst, f->tag, f->tag_len, *(uint32_t *)v);
      case IOP_T_I64:
      case IOP_T_U64:
        return pack_int64(dst, f->tag, f->tag_len, *(int64_t *)v);
      case IOP_T_BOOL:
        /* bool are mapped to 0 or 1 */
        assert (*(uint8_t *)v == 0 || *(uint8_t *)v == 1);
        dst    = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(INT1));
        /* XXX: cast in uint8_t because casting in bool would have no effect.
         */
        *dst++ = !!*(uint8_t *)v;
        return dst;
      case IOP_T_VOID:
        /* Do not pack required void in structs */
        if (desc->is_union || f->repeat != IOP_R_REQUIRED) {
            /* void types do not contain any value, but the wire format
             * requires we send at least one byte of data with the tag. */
            return pack_len(dst, f->tag, f->tag_len, 0);
        }
        return dst;
      case IOP_T_DOUBLE:
        dst = pack_tag(dst, f->tag, f->tag_len, IOP_WIRE_MASK(QUAD));
        return put_unaligned_double_le(dst, *(double *)v);
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        len = ((lstr_t *)v)->len;
        dst = pack_len(dst, f->tag, f->tag_len, len + 1);
        dst = mempcpyz(dst, ((lstr_t *)v)->data, len);
        return dst;
      case IOP_T_UNION:
        if (iop_field_is_reference(f)) {
            v = *(void **)v;
        }
        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        return pack_union(dst, f->u1.st_desc, v, flags, szsp, in_thread);
      case IOP_T_STRUCT:
      default: {
        bool is_class = iop_field_is_class(f);
        bool is_ref   = iop_field_is_reference(f);

        dst = pack_len(dst, f->tag, f->tag_len, *(*szsp)++);
        if ((is_class || is_ref) && f->repeat != IOP_R_OPTIONAL) {
            /* Non-optional class fields have to be dereferenced
             * (dereferencing of optional fields was done in pack_struct).
             */
            v = *(void **)v;
        }
        if (is_class) {
            return pack_class(dst, f->u1.st_desc, v, flags, szsp, in_thread);
        } else {
            return pack_struct(dst, f->u1.st_desc, v, flags, szsp, in_thread);
        }
      }
    }
}

typedef struct pack_job_t {
    thr_job_t job;
    uint8_t *dst;
    const iop_field_t *f;
    const void *v;
    uint32_t n;
    unsigned flags;
    const int *szs;
    bool is_class;
    bool last_chunk;
} pack_job_t;

typedef struct pack_td_t {
    thr_td_t td;
    const void *v;
    const int *szs;
    uint8_t *dst;
} pack_td_t;

#define _pack_class(dst, st_desc, v, flags, szs)  \
    pack_class(dst, st_desc, *(void **)v, flags, szs, true)
#define _pack_union(dst, st_desc, v, flags, szs)  \
    pack_union(dst, st_desc, v, flags, szs, true)
#define _pack_struct(dst, st_desc, v, flags, szs)  \
    pack_struct(dst, st_desc, v, flags, szs, true)

#define GEN_PACK_JOB(type)  \
static void pack_value_vec_##type##_job(thr_job_t *job, thr_syn_t *syn)      \
{                                                                            \
    pack_job_t *pj = (pack_job_t *)job;                                      \
    uint32_t n = pj->n;                                                      \
    uint8_t *dst = pj->dst;                                                  \
    const iop_struct_t *st_desc = pj->f->u1.st_desc;                         \
    const void *v = pj->v;                                                   \
    unsigned flags = pj->flags;                                              \
    const int *szs = pj->szs;                                                \
    const int fsize = pj->f->size;                                           \
                                                                             \
    for (uint32_t i = 0; i < n; i++) {                                       \
        dst = pack_len(dst, 0, 0, *(szs++));                                 \
        dst = _pack_##type(dst, st_desc, v, flags, &szs);                    \
        v = (const byte *)v + fsize;                                         \
    }                                                                        \
                                                                             \
    if (pj->last_chunk) {                                                    \
        pack_td_t *td = container_of(thr_syn_acquire_td(syn), pack_td_t, td);\
        td->v = v;                                                           \
        td->szs = szs;                                                       \
        td->dst = dst;                                                       \
        thr_syn_release_td(syn, &td->td);                                    \
    }                                                                        \
}

GEN_PACK_JOB(class);
GEN_PACK_JOB(struct);
GEN_PACK_JOB(union);

#undef _pack_class
#undef _pack_struct
#undef _pack_union
#undef GEN_PACK_JOB

static uint8_t *
pack_value_vec_threaded(uint8_t *dst, const iop_field_t *f, const void *v,
                        uint32_t n, const unsigned flags, const int **szsp)
{
    pack_job_t *jobs;
    thr_syn_t syn;
    __block uint8_t *dst_res = dst;
    int32_t *len_chunks;
    bool is_class = iop_field_is_class(f);
    int chunks = *(*szsp)++;
    int chunk_size = n / chunks;
    int chunk_remainder = n % chunks;
    int n_count = 0;

    jobs = p_new(pack_job_t, chunks);
    len_chunks = p_new(int32_t, chunks);

    thr_syn_init(&syn);
    thr_syn_declare_td(&syn, ^{
        pack_td_t *td = p_new(pack_td_t, 1);
        return &td->td;
    }, ^(thr_td_t **ptd) {
        p_delete(ptd);
    });

    for (int i = 0; i < chunks; i++) {
        int32_t offs;
        pack_job_t *job = &jobs[i];

        /* get relative offset of chunk in szs */
        offs = *((*szsp) + i);
        /* get chunk packed size from metadata in szs */
        len_chunks[i] = *((*szsp) + i + chunks);

        job->szs = (*szsp) + offs;
        /* chunk output ptr = previous chunk output ptr
         *  + packed size of previous chunk */
        job->dst = i == 0 ? dst : jobs[i - 1].dst + len_chunks[i - 1];
        job->f = f;
        /* last chunk may has remainder elements */
        job->n = i < chunk_remainder ? chunk_size + 1 : chunk_size;
        job->v = (byte *)v + (n_count * f->size);
        job->flags = flags;
        switch (f->type) {
          case IOP_T_STRUCT:
            if (is_class) {
                job->job.run = pack_value_vec_class_job;
            } else {
                job->job.run = pack_value_vec_struct_job;
            }
            break;
          case IOP_T_UNION:
            job->job.run = pack_value_vec_union_job;
            break;
          default:
            assert (false);
            break;
        }
        job->last_chunk = i == chunks - 1;
        thr_syn_schedule(&syn, &job->job);
        n_count += job->n;
    }
    *szsp += chunks;

    thr_syn_wait(&syn);
    thr_syn_collect_td(&syn, ^(const thr_td_t *td) {
        const pack_td_t *r = container_of(td, const pack_td_t, td);

        *szsp = r->szs;
        dst_res = r->dst;
    });
    thr_syn_wipe(&syn);

    p_delete(&jobs);
    p_delete(&len_chunks);

    return dst_res;
}

static uint8_t *
pack_value_vec(uint8_t *dst, const iop_field_t *f, const void *v, uint32_t n,
               const unsigned flags, const int **szsp, bool in_thread)
{
    const lstr_t *d;
    uint32_t len;
    bool is_class;

    /* do not multi thread packing of an array if we are already
     * multithreading, to avoid recursive thr_syn_wait() that can
     * cause a thread explosion */
    if (iop_bpack_is_threadable(f, flags, n) && !in_thread) {
        return pack_value_vec_threaded(dst, f, v, n, flags, szsp);
    }

    switch (f->type) {
      case IOP_T_I32:
      case IOP_T_ENUM:
        do {
            dst = pack_int32(dst, 0, 0, *(int32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_U32:
        do {
            dst = pack_int64(dst, 0, 0, *(uint32_t *)v);
            v   = (char *)v + 4;
        } while (--n > 0);
        return dst;
      case IOP_T_I64:
      case IOP_T_U64:
        do {
            dst = pack_int64(dst, 0, 0, *(int64_t *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_DOUBLE:
        do {
            dst = pack_tag(dst, 0, 0, IOP_WIRE_MASK(QUAD));
            dst = put_unaligned_double_le(dst, *(double *)v);
            v   = (char *)v + 8;
        } while (--n > 0);
        return dst;
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        do {
            d = v;
            len = d->len;
            dst = pack_len(dst, 0, 0, len + 1);
            dst = mempcpyz(dst, d->data, len);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_UNION:
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            dst = pack_union(dst, f->u1.st_desc, v, flags, szsp, in_thread);
            v   = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      case IOP_T_STRUCT:
        is_class = iop_field_is_class(f);
        do {
            dst = pack_len(dst, 0, 0, *(*szsp)++);
            if (is_class) {
                dst = pack_class(dst, f->u1.st_desc, *(void **)v, flags,
                                 szsp, in_thread);
            } else {
                dst = pack_struct(dst, f->u1.st_desc, v, flags, szsp,
                                  in_thread);
            }
            v = (char *)v + f->size;
        } while (--n > 0);
        return dst;
      default:
        e_panic("should not happen");
    }
}

static uint8_t *
pack_struct(void *dst, const iop_struct_t *desc, const void *v,
            const unsigned flags, const int **szsp, bool in_thread)
{
    assert(!desc->is_union); /* We don't want a union here */

    for (int i = 0; i < desc->fields_len; i++) {
        const iop_field_t *f = desc->fields + i;
        const void *ptr = (char *)v + f->data_offs;

        if (flags & IOP_BPACK_SKIP_PRIVATE) {
            const iop_field_attrs_t *attrs = iop_field_get_attrs(desc, f);

            if (attrs && TST_BIT(&attrs->flags, IOP_FIELD_PRIVATE)) {
                continue;
            }
        }

        if (f->repeat == IOP_R_OPTIONAL) {
            if (!iop_opt_field_isset(f->type, ptr)) {
                continue;
            }
            if ((1 << f->type) & IOP_STRUCTS_OK) {
                ptr = *(void **)ptr;
            }
        } else
        if (f->repeat == IOP_R_REPEATED) {
            const lstr_t *data = ptr;

            if (data->len == 0)
                continue;
            ptr = data->data;
            if (data->len > 1) {
                if ((1 << f->type) & IOP_REPEATED_OPTIMIZE_OK) {
                    /* When data unit is really small (byte, bool, …) we
                     * prefer to pack them in one big block */
                    uint32_t sz = data->len * f->size;

                    assert (f->size <= 2);
                    dst = pack_len(dst, f->tag, f->tag_len, sz);
                    dst = mempcpy(dst, data->data, sz);
                } else {
                    dst = pack_tag(dst, f->tag, f->tag_len,
                                   IOP_WIRE_MASK(REPEAT));
                    dst = put_unaligned_le32(dst, data->len);
                    dst = pack_value_vec(dst, f, ptr, data->len, flags, szsp,
                                         in_thread);
                }
                continue;
            }
        } else
        if (f->repeat == IOP_R_DEFVAL) {
            /* Skip the field if it's still equal to its default value */
            if ((flags & IOP_BPACK_SKIP_DEFVAL)
            &&  iop_field_is_defval(f, ptr, true))
            {
                continue;
            }
        }

        dst = pack_value(dst, desc, f, ptr, flags, szsp, in_thread);
    }
    return dst;
}

static uint8_t *pack_class(void *dst, const iop_struct_t *desc, const void *v,
                           const unsigned flags, const int **szsp,
                           bool in_thread)
{
    bool first = true;

    desc = *(const iop_struct_t **)v;

    do {
        int level_size = *(*szsp)++;

        if (first || level_size) {
            /* We write the class id in a tag 0 only if:
             *  - this is the first level, because we always want to write the
             *    real class id of the packed object,
             *  - if there is actually something to pack.
             */
            dst = pack_int32(dst, 0, 0, desc->class_attrs->class_id);
            first = false;
        }
        if (level_size) {
            dst = pack_struct(dst, desc, v, flags, szsp, in_thread);
        }
    } while ((desc = desc->class_attrs->parent));

    return dst;
}

static uint8_t *
pack_union(void *dst, const iop_struct_t *desc, const void *v,
           const unsigned flags, const int **szsp, bool in_thread)
{
    const iop_field_t *f = get_union_field(desc, v);

    return pack_value(dst, desc, f, (char *)v + f->data_offs, flags, szsp,
                      in_thread);
}

void iop_bpack(void *dst, const iop_struct_t *desc, const void *v,
               const int *szs)
{
    /* Read packing flags from first `szs' value */
    const unsigned flags = *szs++;

    if (desc->is_union) {
        pack_union(dst, desc, v, flags, &szs, false);
    } else
    if (iop_struct_is_class(desc)) {
        pack_class(dst, desc, v, flags, &szs, false);
    } else {
        pack_struct(dst, desc, v, flags, &szs, false);
    }
}

lstr_t mp_iop_bpack_struct_flags(mem_pool_t *mp, const iop_struct_t *st,
                                 const void *v, const unsigned flags)
{
    qv_t(i32) sizes;
    byte *data;
    int len;

    if (!v) {
        return LSTR_NULL_V;
    }
    qv_inita(&sizes, 1024);

    len = iop_bpack_size_flags(st, v, flags, &sizes);
    if (len < 0) {
        qv_wipe(&sizes);
        return LSTR_NULL_V;
    }
    data = mp_new_raw(mp, byte, len + 1);
    data[len] = '\0';

    iop_bpack(data, st, v, sizes.tab);
    qv_wipe(&sizes);
    return mp_lstr_init(mp, data, len);
}

lstr_t t_iop_bpack_struct_flags(const iop_struct_t *st, const void *v,
                                const unsigned flags)
{
    return mp_iop_bpack_struct_flags(t_pool(), st, v, flags);
}

/* }}} */
/* {{{ Unpacking */

static int iop_union_get_data_offset(const iop_struct_t *nonnull desc)
{
    int size = desc->size;

    assert (desc->is_union);

    for (int i = 0; i < desc->fields_len; i++) {
        uint16_t offs = desc->fields[i].data_offs;

        if (offs) {
            return offs;
        }
    }

    return size;
}

void iop_union_set_tag(const iop_struct_t *nonnull desc, int value,
                       void *nonnull st)
{
    switch (iop_union_get_data_offset(desc)) {
      case 1:
        *(uint8_t *)st = (uint8_t)value;
        break;
      case 2:
        *(uint16_t *)st = (uint16_t)value;
        break;
      case 4:
      case 8:
        *(uint32_t *)st = (uint32_t)value;
        break;
      default:
        assert (false);
    }
}

int iop_union_get_tag(const iop_struct_t *nonnull desc,
                      const void *nonnull st)
{
    switch (iop_union_get_data_offset(desc)) {
      case 1:
        return *(uint8_t *)st;
      case 2:
      case 4:
      case 8:
        return *(uint16_t *)st;
      default:
        assert (false);
        return -1;
    }
}

static inline int get_uint32(pstream_t *ps, int ilen, uint32_t *u32)
{
    switch (ilen) {
      case 1:
        *u32 = RETHROW(ps_getc(ps));
        return 0;

      case 2: {
        uint16_t u16 = 0;
        RETHROW(ps_get_le16(ps, &u16));
        *u32 = u16;
      } return 0;

      case 4:
        return ps_get_le32(ps, u32);
    }
    e_panic("this should not happen");
}

/*
 * XXX: an iop_range helps doing run-length encoded binary search. We know
 * that IOPs tags are mostly contiguous, hence we encode "full" runs of tags
 * this way:
 *   [ offset0, start_tag0, offset1, ..., offset_n, start_tag_n, offset_end]
 *
 * This means that the offset0-th up to the offset1-th values described by
 * this iop_range take values contiguously from the range:
 *   [ start_tag0 .. start_tag0 + offset1 - offset0 [
 *
 * Of course, offset0 is always equal to 0, and offset_n should be equal to
 * ranges_len.
 *
 * Example: the iop_range for "10 11 12 13 100 101 102" is "0 10 4 100 7"
 *  - positions [0 .. 4[ have values in [10  .. 10 + 4 - 0[
 *  - positions [4 .. 7[ have values in [100 .. 100 + 7 - 4[
 *
 */
int iop_ranges_search(int const * ranges, int ranges_len, int tag)
{
    int l = 0, r = ranges_len;

    while (l < r) {
        int i = (l + r) / 2;
        int offs  = ranges[i * 2];
        int start = ranges[i * 2 + 1];

        if (tag < start) {
            r = i;
            continue;
        }
        if (tag + offs >= start + ranges[i * 2 + 2]) {
            l = i + 1;
            continue;
        }
        return ranges[i * 2] + (tag - start);
    }
    return -1;
}

static int iop_enum_pos_from_val(const iop_enum_t *e, int val)
{
    return iop_ranges_search(e->ranges, e->ranges_len, val);
}

static int iop_enum_pos_from_str(const iop_enum_t *e, const char *s, int len)
{
    lstr_t ename;

    if (len < 0) {
        ename = LSTR(s);
    } else {
        ename = LSTR_INIT_V(s, len);
    }
    for (int i = 0; i < e->enum_len; i++) {
        if (lstr_ascii_iequal(e->names[i], ename)) {
            return i;
        }
    }
    if (TST_BIT(&e->flags, IOP_ENUM_ALIASES) && e->aliases) {
        for (int i = 0; i < e->aliases->len; i++) {
            if (lstr_ascii_iequal(e->aliases->aliases[i].name, ename)) {
                return e->aliases->aliases[i].pos;
            }
        }
    }
    return -1;
}

int iop_enum_from_str2_desc(const iop_enum_t *e, const char *s, int len,
                            bool *found)
{
    int pos = iop_enum_pos_from_str(e, s, len);

    if (pos < 0) {
        *found = false;
        return -1;
    }
    *found = true;
    return e->values[pos];
}

int iop_enum_from_str_desc(const iop_enum_t *e, const char *s, int len,
                           int err)
{
    bool found;
    int val = iop_enum_from_str2_desc(e, s, len, &found);

    return (found) ? val : err;
}

int iop_enum_from_lstr_desc(const iop_enum_t *e, const lstr_t s, bool *found)
{
    return iop_enum_from_str2_desc(e, s.s, s.len, found);
}


static int iop_skip_field(pstream_t *ps, iop_wire_type_t wt)
{
    uint32_t u32 = 0;

    switch (wt) {
      case IOP_WIRE_BLK1: PS_CHECK(get_uint32(ps, 1, &u32)); break;
      case IOP_WIRE_BLK2: PS_CHECK(get_uint32(ps, 2, &u32)); break;
      case IOP_WIRE_BLK4: PS_CHECK(get_uint32(ps, 4, &u32)); break;

      case IOP_WIRE_INT1:
      case IOP_WIRE_INT2:
      case IOP_WIRE_INT4:
        u32 = 1 << (wt - IOP_WIRE_INT1);
        break;
      case IOP_WIRE_QUAD:
        u32 = 8;
        break;

      case IOP_WIRE_REPEAT: {
        uint32_t n = 0;

        PS_CHECK(get_uint32(ps, 4, &n));
        PS_WANT(n >= 1);

        while (n--) {
            PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
            wt = IOP_WIRE_FMT(__ps_getc(ps));
            RETHROW(iop_skip_field(ps, wt));
        }
      } break;

      default:
        return -1;
    }

    return ps_skip(ps, u32);
}

static ALWAYS_INLINE
int iop_patch_int(const iop_field_t *fdesc, void *ptr, int64_t i64)
{
#define CHECK_RANGE(_min, _max)  THROW_ERR_IF(i64 < _min || i64 > _max)

    switch (fdesc->type) {
      case IOP_T_I8:
        CHECK_RANGE(INT8_MIN, INT8_MAX);
        *(int8_t *)ptr = i64;
        break;
      case IOP_T_U8:
        CHECK_RANGE(0, UINT8_MAX);
        *(uint8_t *)ptr  = i64;
        break;
      case IOP_T_I16:
        CHECK_RANGE(INT16_MIN, INT16_MAX);
        *(int16_t *)ptr = i64;
        break;
      case IOP_T_U16:
        CHECK_RANGE(0, UINT16_MAX);
        *(uint16_t *)ptr = i64;
        break;
      case IOP_T_ENUM:
      case IOP_T_I32:
        CHECK_RANGE(INT32_MIN, INT32_MAX);
        *(int32_t *)ptr = i64;
        break;
      case IOP_T_U32:
        CHECK_RANGE(0, UINT32_MAX);
        *(uint32_t *)ptr = i64;
        break;
      case IOP_T_I64: case IOP_T_U64:
        *(int64_t *)ptr = i64;
        break;
      case IOP_T_BOOL:
        CHECK_RANGE(0, 1);
        *(bool *)ptr = i64;
        break;
      case IOP_T_VOID:
        /* Never write a void field into a struct, it does not exist */
        e_named_trace(3, "iop/c/unpacker", "dropped value (0x%jx) into void "
                      "field `%*pM`", i64, LSTR_FMT_ARG(fdesc->name));
        break;
      case IOP_T_DOUBLE:
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_UNION:
      case IOP_T_STRUCT:
      case IOP_T_XML:
        e_panic("iop_type unsupported");
    }

#undef CHECK_RANGE
    return 0;
}

static ALWAYS_INLINE int
__get_tag_wt(pstream_t *ps, uint32_t *tag, iop_wire_type_t *wt)
{
    *wt  = IOP_WIRE_FMT(ps->b[0]);
    *tag = IOP_TAG(__ps_getc(ps));
    if (likely(*tag < IOP_LONG_TAG(1)))
        return 0;
    if (likely(*tag == IOP_LONG_TAG(1)))
        return get_uint32(ps, 1, tag);
    return get_uint32(ps, 2, tag);
}

static ALWAYS_INLINE int
__get_class_id(pstream_t *ps, iop_wire_type_t wt, uint16_t *class_id)
{
    switch (wt) {
      case IOP_WIRE_INT1:
        PS_WANT(ps_has(ps, 1));
        *class_id = (int8_t)__ps_getc(ps);
        return 0;

      case IOP_WIRE_INT2:
        PS_WANT(ps_has(ps, 2));
        *class_id = (int16_t)__ps_get_le16(ps);
        return 0;

      case IOP_WIRE_INT4:
        PS_WANT(ps_has(ps, 4));
        *class_id = (int16_t)__ps_get_le32(ps);
        return 0;

      default:
        return -1;
    }
}

int iop_skip_absent_field_desc(mem_pool_t *mp, void *value,
                               const iop_struct_t *sdesc,
                               const iop_field_t *fdesc)
{
    void *ptr = (char *)value + fdesc->data_offs;

    switch (fdesc->repeat) {
      case IOP_R_REQUIRED: {
        const iop_struct_t *desc = fdesc->u1.st_desc;
        bool is_class;

        /* A required void field can be skipped */
        if (fdesc->type == IOP_T_VOID) {
            return 0;
        }

        /* For a required field, only structs can be absents, be careful that
         * union must be present */
        PS_WANT(fdesc->type == IOP_T_STRUCT);

        if ((is_class = iop_field_is_class(fdesc))) {
            /* For classes, we consider that the absent object is of the
             * expected type, and not a child.
             * We have to allocate it since it's pointed. */
            PS_WANT(!desc->class_attrs->is_abstract);
            *(void **)ptr = mp_imalloc(mp, desc->size, 8, MEM_RAW);
            ptr = *(void **)ptr;
            *(const iop_struct_t **)ptr = desc;
        } else
        if (iop_field_is_reference(fdesc)) {
            *(void **)ptr = mp_imalloc(mp, desc->size, 8, MEM_RAW);
            ptr = *(void **)ptr;
        }
        do {
            for (int i = 0; i < desc->fields_len; i++) {
                RETHROW(iop_skip_absent_field_desc(mp, ptr, desc,
                                                   desc->fields + i));
            }
        } while (is_class && (desc = desc->class_attrs->parent));
      } return 0;

      case IOP_R_DEFVAL:
        RETHROW(iop_field_set_defval(fdesc, ptr));
        break;

      case IOP_R_REPEATED: {
        unsigned fdesc_flags = fdesc->flags;

        if (TST_BIT(&fdesc_flags, IOP_FIELD_NO_EMPTY_ARRAY)) {
            sb_reset(&iop_err_g.path);
            iop_err_g.desc = sdesc;
            iop_set_err("empty array not allowed for field `%*pM`",
                        LSTR_FMT_ARG(fdesc->name));
            return -1;
        }
        p_clear((lstr_t *)ptr, 1);
      } break;

      case IOP_R_OPTIONAL:
        iop_field_set_absent(fdesc, ptr);
        break;
    }
    return 0;
}

static int
unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
              pstream_t *ps, unsigned flags, iop_wire_type_t *class_id_wt);
static int unpack_class(mem_pool_t *mp, const iop_struct_t *desc,
                        void **value, pstream_t *ps, unsigned flags);
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, unsigned flags);

static int unpack_value(mem_pool_t *mp, iop_wire_type_t wt,
                        const iop_field_t *fdesc, void *v,
                        pstream_t *ps, unsigned flags)
{
    uint32_t u32 = 0;
    pstream_t ps_tmp;

    if (iop_field_is_reference(fdesc)) {
        v = iop_field_ptr_alloc(mp, fdesc, v);
    }

    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));
        /* FALLTHROUGH */

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK || fdesc->type == IOP_T_VOID);
        PS_WANT(ps_has(ps, u32));
        switch (fdesc->type) {
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            *(lstr_t *)v = LSTR_INIT_V(((flags & IOP_UNPACK_COPY_STRINGS)
                                        ? mp_dup(mp, ps->s, u32)
                                        : ps->p), u32 - 1);
            return __ps_skip(ps, u32);
          case IOP_T_UNION:
            ps_tmp = __ps_get_ps(ps, u32);
            return unpack_union(mp, fdesc->u1.st_desc, v, &ps_tmp, flags);
          case IOP_T_STRUCT:
            ps_tmp = __ps_get_ps(ps, u32);
            if (iop_field_is_class(fdesc)) {
                *(void **)v = NULL;
                return unpack_class(mp, fdesc->u1.st_desc, v, &ps_tmp, flags);
            } else {
                return unpack_struct(mp, fdesc->u1.st_desc, v, &ps_tmp, flags,
                                     NULL);
            }
          case IOP_T_VOID:
            /* do not write anything into void */
            if (u32 > 0) {
                e_named_trace(3, "iop/c/unpacker", "dropped block (%u bytes) "
                              "into void field `%*pM`", u32,
                              LSTR_FMT_ARG(fdesc->name));
            }
            return __ps_skip(ps, u32);
          default:
            break;
        }
        return -1;

      case IOP_WIRE_INT1:
        PS_WANT(ps_has(ps, 1));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int8_t)__ps_getc(ps));

      case IOP_WIRE_INT2:
        PS_WANT(ps_has(ps, 2));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int16_t)__ps_get_le16(ps));

      case IOP_WIRE_INT4:
        PS_WANT(ps_has(ps, 4));
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        return iop_patch_int(fdesc, v, (int32_t)__ps_get_le32(ps));

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_WANT(ps_has(ps, 8));
            return iop_patch_int(fdesc, v, __ps_get_le64(ps));
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE)
            return ps_get_double_le(ps, v);
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        return ps_get_le64(ps, v);
      default:
        return -1;
    }
}

/* Returns:
 * * 1 when "change of level" (used for classes) tag was seen; in that case,
 *   the wire type associated to this tag is written in class_id_wt.
 * * 0 otherwise on success.
 * * a negative value on error.
 */
static int
unpack_struct(mem_pool_t *mp, const iop_struct_t *desc, void *value,
              pstream_t *ps, unsigned flags, iop_wire_type_t *class_id_wt)
{
    bool is_class = iop_struct_is_class(desc);
    const iop_field_t *fdesc = desc->fields;
    const iop_field_t *end   = desc->fields + desc->fields_len;
    iop_wire_type_t wt = 0;
    uint32_t tag = 1;

    while (!ps_done(ps)) {
        uint32_t n = 1;
        void *v;

        PS_CHECK(__get_tag_wt(ps, &tag, &wt));
        if (tag == 0) {
            /* This is a "change of level" tag in a packed class; check that
             * all the remaining fields at this level are optional. */
            PS_WANT(is_class);
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking class %*pM, got change of level tag",
                          LSTR_FMT_ARG(desc->fullname));
            while (fdesc < end) {
                PS_CHECK(iop_skip_absent_field_desc(mp, value, desc, fdesc));
                fdesc++;
            }
            *class_id_wt = wt;
            return 1;
        }
        if (fdesc >= end) {
            goto end;
        }

        while (unlikely(tag > fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker", "unpacking struct %*pM, "
                          "skipping absent field %*pM (tag %u)",
                          LSTR_FMT_ARG(desc->fullname),
                          LSTR_FMT_ARG(fdesc->name), fdesc->tag);
            PS_CHECK(iop_skip_absent_field_desc(mp, value, desc, fdesc));
            if (++fdesc == end) {
                goto end;
            }
        }
        if (unlikely(tag < fdesc->tag)) {
            e_named_trace(5, "iop/c/unpacker",
                          "unpacking struct %*pM, skipping unknown tag %u",
                          LSTR_FMT_ARG(desc->fullname), tag);
            PS_CHECK(iop_skip_field(ps, wt));
            continue;
        }

        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, unpacking field %*pM (tag %u)",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name), tag);

        if (fdesc && flags & IOP_UNPACK_FORBID_PRIVATE) {
            const iop_field_attrs_t *attrs = iop_field_get_attrs(desc, fdesc);

            if (attrs && TST_BIT(&attrs->flags, IOP_FIELD_PRIVATE)) {
                iop_set_err("field `%*pM` of struct `%*pM` is private",
                            LSTR_FMT_ARG(fdesc->name),
                            LSTR_FMT_ARG(desc->fullname));
                return -1;
            }
        }

        if (wt == IOP_WIRE_REPEAT) {
            PS_CHECK(get_uint32(ps, 4, &n));
            PS_WANT(n >= 1);
            PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
            wt = IOP_WIRE_FMT(__ps_getc(ps));
        }

        v = (char *)value + fdesc->data_offs;
        if (fdesc->repeat == IOP_R_REPEATED) {
            lstr_t *data = v;

            if (wt != IOP_WIRE_REPEAT
            &&  ((1 << fdesc->type) & IOP_REPEATED_OPTIMIZE_OK))
            {
                /* optimized version of repeated fields are packed in simples
                 * IOP blocks */
                uint32_t len = 0;

                switch (wt) {
                  case IOP_WIRE_BLK1:
                    PS_CHECK(get_uint32(ps, 1, &len));
                    break;
                  case IOP_WIRE_BLK2:
                    PS_CHECK(get_uint32(ps, 2, &len));
                    break;
                  case IOP_WIRE_BLK4:
                    PS_CHECK(get_uint32(ps, 4, &len));
                    break;
                  default:
                    /* Here we expect to have a uniq-value packed as a normal
                     * field (data->len == 1) */
                    goto unpack_array;
                }
                PS_WANT(ps_has(ps, len));

                if (fdesc->size == 1) {
                    data->len = len;
                    data->data = ((flags & IOP_UNPACK_COPY_STRINGS)
                                  ? mp_dup(mp, ps->s, len)
                                  : (void *)ps->p);
                } else {
                    assert (fdesc->size == 2);
                    PS_WANT(len % 2 == 0);
                    data->len  = len / 2;
                    data->data = mp_dup(mp, ps->s, len);
                }

                __ps_skip(ps, len);
                v = data->data;
                n = data->len;
                goto next;
            }

          unpack_array:
            data->len  = n;
            data->data = v = mp_imalloc(mp, n * fdesc->size, 8, MEM_RAW);

            while (n-- > 1) {
                if (unpack_value(mp, wt, fdesc, v, ps, flags) < 0) {
                    sb_prepend_field(&iop_err_g.path, fdesc,
                                     data->len - n - 1);
                    return -1;
                }
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
                v  = (char *)v + fdesc->size;
            }
            if (unpack_value(mp, wt, fdesc, v, ps, flags) < 0) {
                sb_prepend_field(&iop_err_g.path, fdesc, 0);
                return -1;
            }
            v = data->data;
            n = data->len;
        } else {
            while (n-- > 1) {
                PS_CHECK(iop_skip_field(ps, wt));
                PS_WANT(ps_has(ps, 1) && IOP_TAG(ps->b[0]) == 0);
                wt = IOP_WIRE_FMT(__ps_getc(ps));
            }
            if (fdesc->repeat == IOP_R_OPTIONAL && !iop_field_is_class(fdesc))
            {
                v = iop_field_set_present(mp, fdesc, v);
            }
            if (unpack_value(mp, wt, fdesc, v, ps, flags) < 0) {
                sb_prepend_field(&iop_err_g.path, fdesc, 0);
                return -1;
            }
            n = 1;
        }

      next:
        if (unlikely(iop_field_has_constraints(desc, fdesc))) {
            RETHROW(iop_field_check_constraints(desc, fdesc, v, n, false));
        }
        fdesc++;
    }

  end:
    /* consume tags that no longer exists */
    while (!ps_done(ps)
    &&     (desc->fields_len == 0
        ||  tag > desc->fields[desc->fields_len - 1].tag))
    {
        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, skipping unknown tag %u",
                      LSTR_FMT_ARG(desc->fullname), tag);
        PS_CHECK(iop_skip_field(ps, wt));
        if (ps_done(ps)) {
            break;
        }
        PS_CHECK(__get_tag_wt(ps, &tag, &wt));
        if (tag == 0) {
            PS_WANT(is_class);
            *class_id_wt = wt;
            break;
        }
    }

    /* consume fields that are not set */
    for (; fdesc < end; fdesc++) {
        e_named_trace(5, "iop/c/unpacker",
                      "unpacking struct %*pM, skipping %*pM field",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(fdesc->name));
        PS_CHECK(iop_skip_absent_field_desc(mp, value, desc, fdesc));
    }

    /* return 1 if change of level tag has been found */
    return (tag == 0) ? 1 : 0;
}

static inline int
unpack_skip_all_fields(mem_pool_t *mp, const iop_struct_t *desc, void *value)
{
    const iop_field_t *fdesc = desc->fields;
    const iop_field_t *end   = fdesc + desc->fields_len;

    for ( ; fdesc < end; fdesc++) {
        PS_CHECK(iop_skip_absent_field_desc(mp, value, desc, fdesc));
    }
    return 0;
}

static int unpack_class(mem_pool_t *mp, const iop_struct_t *desc,
                        void **value, pstream_t *ps, unsigned flags)
{
    const iop_struct_t *real_desc;
    iop_wire_type_t wt;
    uint32_t tag = 1;
    uint16_t child_id = 0;
    pstream_t saved_ps = *ps;

    if (likely(!ps_done(ps))) {
        /* Get the class id of the packed class instance */
        PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    }

    if (unlikely(tag != 0)) {
        /* struct -> class backward compat handling, ok if the class has no
         * parents. */
        if (desc->class_attrs->parent) {
            iop_set_err("invalid binary encoding for value of type `%*pM`",
                        LSTR_FMT_ARG(desc->fullname));
            return -1;
        }
        *ps = saved_ps;
        real_desc = desc;
    } else {
        PS_CHECK(__get_class_id(ps, wt, &child_id));

        if (unlikely(!(real_desc = iop_get_class_by_id(desc, child_id)))) {
            SB_1k(err);

            sb_addf(&err, "cannot find child %d of class '%*pM'",
                    child_id, LSTR_FMT_ARG(desc->fullname));
            e_trace(0, "%*pM; missing IOP_REGISTER_PACKAGES?",
                    SB_FMT_ARG(&err));
            iop_set_err2(&LSTR_SB_V(&err));
            return -1;
        }
    }

    if (real_desc != desc) {
        /* We are trying to unpack a class of type "desc", and the packed
         * class is of type "real_desc". Check that this is authorized. */
        if (unlikely(!iop_class_is_a(real_desc, desc))) {
            SB_1k(err);

            sb_addf(&err, "class '%*pM' (id %d) is not a child of '%*pM' "
                    "(id %d) as expected",
                    LSTR_FMT_ARG(real_desc->fullname), child_id,
                    LSTR_FMT_ARG(desc->fullname),
                    desc->class_attrs->class_id);
            e_trace(0, "%*pM", SB_FMT_ARG(&err));
            iop_set_err2(&LSTR_SB_V(&err));
            return -1;
        }
        e_named_trace(5, "iop/c/unpacker",
                      "unpacking a class of type %*pM, real type %*pM",
                      LSTR_FMT_ARG(desc->fullname),
                      LSTR_FMT_ARG(real_desc->fullname));
    }

    if (flags & IOP_UNPACK_FORBID_PRIVATE
    &&  real_desc->class_attrs->is_private)
    {
        iop_set_err("class `%*pM` is private",
                    LSTR_FMT_ARG(real_desc->fullname));
        return -1;
    }

    PS_WANT(!real_desc->class_attrs->is_abstract);
    *value = mp_irealloc(mp, *value, 0, real_desc->size, 8, MEM_RAW);

    /* Set the __vptr pointer */
    *(const iop_struct_t **)(*value) = real_desc;

    /* Unpack the several levels */
    for (;;) {
        uint16_t class_id = 0;
        int res;

        PS_CHECK((res = unpack_struct(mp, real_desc, *value, ps, flags, &wt)));

        if (!(real_desc = real_desc->class_attrs->parent)) {
            return 0;
        }

        if (res != 1) {
            /* "Change of level" tag was not seen yet */
            if (ps_done(ps)) {
                /* Such a tag won't be there because pstream is finished. This
                 * is possible if all the remaining levels have only optional
                 * fields. */
                do {
                    PS_CHECK(unpack_skip_all_fields(mp, real_desc, *value));
                } while ((real_desc = real_desc->class_attrs->parent));
                return 0;
            }
            /* Read it */
            PS_CHECK(__get_tag_wt(ps, &tag, &wt));
            PS_WANT(tag == 0);
        }

        /* Get the next class id, and run the tree up to it; the skipped
         * classes must have only optional fields. */
        PS_CHECK(__get_class_id(ps, wt, &class_id));
        while (class_id != real_desc->class_attrs->class_id) {
            PS_CHECK(unpack_skip_all_fields(mp, real_desc, *value));
            PS_WANT((real_desc = real_desc->class_attrs->parent));
        }
    }
}

/* note: returns 0 on success, -1 on error and 1 if the pstream hasn't been
 * fully consumed. */
static int unpack_union(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                        pstream_t *ps, unsigned flags)
{
    const iop_field_t *fdesc = desc->fields;

    iop_wire_type_t wt;
    uint32_t tag;
    int ifield;

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Write the selected field */
    iop_union_set_tag(desc, fdesc->tag, value);
    value = (char *)value + fdesc->data_offs;

    e_named_trace(5, "iop/c/unpacker", "unpacking union %*pM field %*pM",
                  LSTR_FMT_ARG(desc->fullname), LSTR_FMT_ARG(fdesc->name));
    if (unpack_value(mp, wt, fdesc, value, ps, flags) < 0) {
        sb_prepend_field(&iop_err_g.path, fdesc, 0);
        return -1;
    }
    if (unlikely(iop_field_has_constraints(desc, fdesc))) {
        RETHROW(iop_field_check_constraints(desc, fdesc, value, 1, false));
    }
    return ps_done(ps) ? 0 : 1;
}

int iop_bunpack_flags(mem_pool_t *mp, const iop_struct_t *desc, void *value,
                      pstream_t ps, unsigned flags)
{
    assert (!iop_struct_is_class(desc));
    assert (mp && mp->mem_pool & MEM_BY_FRAME);
    e_named_trace(5, "iop/c/unpacker", "unpacking IOP object %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    iop_clear_err();
    if (desc->is_union) {
        return unpack_union(mp, desc, value, &ps, flags) ? -1 : 0;
    }
    return unpack_struct(mp, desc, value, &ps, flags, NULL) < 0 ? -1 : 0;
}

int iop_bunpack_ptr_flags(mem_pool_t *mp, const iop_struct_t *desc,
                          void **value, pstream_t ps, unsigned flags)
{
    e_named_trace(5, "iop/c/unpacker", "unpacking IOP object %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    iop_clear_err();

    if (!iop_struct_is_class(desc)) {
        *value = mp_irealloc(mp, *value, 0, desc->size, 8, MEM_RAW);
        return iop_bunpack_flags(mp, desc, *value, ps, flags);
    }
    assert (mp && mp->mem_pool & MEM_BY_FRAME);

    return unpack_class(mp, desc, value, &ps, flags);
}

/* XXX: this function can unpack only union because the struct can't be
 * delimited in a stream.
 * */
int iop_bunpack_multi_flags(mem_pool_t *mp, const iop_struct_t *desc,
                            void *value, pstream_t *ps, unsigned flags)
{
    pstream_t ps_save = *ps;

    assert(desc->is_union);

    e_named_trace(5, "iop/c/unpacker", "unpacking IOP union(s) %*pM",
                  LSTR_FMT_ARG(desc->fullname));
    iop_clear_err();
    if (unpack_union(mp, desc, value, ps, flags) < 0) {
        *ps = ps_save;
        return -1;
    }

    return 0;
}

/* XXX this function doesn't check the IOP content and trust what it reads
 * XXX: this function can unpack only union because the struct can't be
 * delimited in a stream. */
int iop_bskip(const iop_struct_t *desc, pstream_t *ps)
{
    const iop_field_t *fdesc = desc->fields;
    iop_wire_type_t wt;
    uint32_t tag, u32 = 0;
    int ifield;

    assert(desc->is_union);

    PS_WANT(!ps_done(ps));
    /* We get the selected tag in the union */
    PS_CHECK(__get_tag_wt(ps, &tag, &wt));
    /* Repeated fields are forbidden in union */
    PS_WANT(wt != IOP_WIRE_REPEAT);

    ifield = iop_ranges_search(desc->ranges, desc->ranges_len, tag);
    PS_CHECK(ifield);
    fdesc += ifield;

    /* Skip union data */
    switch (wt) {
      case IOP_WIRE_BLK1:
        PS_CHECK(get_uint32(ps, 1, &u32));
        goto read_blk;

      case IOP_WIRE_BLK2:
        PS_CHECK(get_uint32(ps, 2, &u32));
        goto read_blk;

      case IOP_WIRE_BLK4:
        PS_CHECK(get_uint32(ps, 4, &u32));

      read_blk:
        PS_WANT((1 << fdesc->type) & IOP_BLK_OK);
        PS_CHECK(ps_skip(ps, u32)); /* Skip block */
        return 0;

      case IOP_WIRE_INT1:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 1));
        return 0;

      case IOP_WIRE_INT2:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 2));
        return 0;

      case IOP_WIRE_INT4:
        PS_WANT((1 << fdesc->type) & IOP_INT_OK);
        PS_CHECK(ps_skip(ps, 4));
        return 0;

      case IOP_WIRE_QUAD:
        if ((1 << fdesc->type) & IOP_INT_OK) {
            PS_CHECK(ps_skip(ps, 8));
            return 0;
        }
#if __FLOAT_WORD_ORDER != __BYTE_ORDER
        if (fdesc->type == IOP_T_DOUBLE) {
            PS_CHECK(ps_skip(ps, sizeof(double)));
            return 0;
        }
#endif
        PS_WANT((1 << fdesc->type) & IOP_QUAD_OK);
        PS_CHECK(ps_skip(ps, 8));
        return 0;
      default:
        return -1;
    }
}

ssize_t iop_get_field_len(pstream_t ps)
{
    iop_wire_type_t wt;
    uint32_t tag, u32, tag_len, len_len;

    if (ps_done(&ps))
        return 0;
    wt  = IOP_WIRE_FMT(ps.b[0]);
    tag = IOP_TAG(ps.b[0]);
    if (likely(tag < IOP_LONG_TAG(1))) {
        tag_len = 1;
    } else {
        tag_len = 2 + tag - IOP_LONG_TAG(1);
    }
    switch (wt) {
      case IOP_WIRE_BLK1:
        len_len = 1;
        break;
      case IOP_WIRE_BLK2:
        len_len = 2;
        break;
      case IOP_WIRE_BLK4:
        len_len = 4;
        break;
      case IOP_WIRE_REPEAT: /* not supported by this function */
        return -1;
      case IOP_WIRE_INT1:
        return tag_len + 1;
      case IOP_WIRE_INT2:
        return tag_len + 2;
      case IOP_WIRE_INT4:
        return tag_len + 4;
      case IOP_WIRE_QUAD:
        return tag_len + 8;
      default:
        return -1;
    }
    if (ps_skip(&ps, tag_len) < 0)
        return 0;
    u32 = 0;
    if (get_uint32(&ps, len_len, &u32) < 0)
        return 0;
    return tag_len + len_len + u32;
}

/* }}} */
/* {{{ Introspection */

const iop_iface_t *iop_mod_find_iface(const iop_mod_t *mod, uint32_t tag)
{
    size_t l = 0, r = mod->ifaces_len;

    while (l < r) {
        size_t  i = (l + r) / 2;
        const iop_iface_alias_t *alias = &mod->ifaces[i];

        if (tag == alias->tag) {
            return alias->iface;
        }
        if (tag < alias->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_iface_find_rpc(const iop_iface_t *iface, uint32_t tag)
{
    size_t l = 0, r = iface->funs_len;

    while (l < r) {
        size_t i = (l + r) / 2;
        const iop_rpc_t *rpc = &iface->funs[i];

        if (tag == rpc->tag) {
            return rpc;
        }
        if (tag < rpc->tag) {
            r = i;
        } else {
            l = i + 1;
        }
    }
    return NULL;
}

const iop_rpc_t *iop_mod_find_rpc(const iop_mod_t *mod, uint32_t cmd)
{
    const iop_iface_t *iface = RETHROW_P(iop_mod_find_iface(mod, cmd >> 16));
    return iop_iface_find_rpc(iface, cmd & 0xffff);
}

const iop_struct_t *
_iop_class_first_non_empty_parent(const iop_struct_t *cls)
{
    do {
        cls = cls->class_attrs->parent;
    } while (cls && !cls->fields_len);

    return cls;
}

const iop_field_t * nullable
iop_struct_get_next_field(const iop_field_t *nullable field,
                          const iop_struct_t *nonnull *nonnull st)
{
    return _iop_struct_next_field(iop_struct_is_class(*st), field, st);
}

/* }}} */
/* {{{ Altering IOP objects */

void iop_prune(const iop_struct_t *st, void *obj, lstr_t gen_attr)
{
    iop_for_each_field_fast(st, obj, ^int (const iop_struct_t *st_desc,
                                           const iop_field_t *fdesc,
                                           void *st_ptr) {
        /* Check first if the field is repeated of optional for perfs. */
        if (fdesc->repeat == IOP_R_REPEATED
        ||  fdesc->repeat == IOP_R_OPTIONAL)
        {
            if (iop_field_get_bool_gen_attr(st_desc, fdesc, gen_attr,
                                            false))
            {
                int res;

                t_seal();
                res = iop_skip_absent_field_desc(t_pool(), st_ptr, st_desc,
                                                 fdesc);
                t_unseal();
                assert (res >= 0);
                return IOP_FIELD_SKIP;
            }
        } else {
            assert (!iop_field_get_bool_gen_attr(st_desc, fdesc, gen_attr,
                                                 false));
        }

        return 0;
    });
}

/* }}} */
/* {{{ Introspection - iop_for_each_field() */

/* {{{ Stack management */

typedef struct field_stack_el_t {
    htnode_t link;
    const iop_struct_t *st_desc;
    const iop_field_t *f;
    const void *st_ptr;
    int index;
} field_stack_el_t;

struct iop_field_stack_t {
    htlist_t flist;
};

static inline iop_field_stack_t *
iop_field_stack_init(iop_field_stack_t *fstack)
{
    p_clear(fstack, 1);
    htlist_init(&fstack->flist);

    return fstack;
}

static field_stack_el_t *field_stack_el_init(field_stack_el_t *el)
{
    p_clear(el, 1);
    el->index = -1;

    return el;
}

static void field_path_print_rec(sb_t *sb, const field_stack_el_t *el)
{
    if (el->link.next) {
        field_stack_el_t *e;

        e = htlist_entry(el->link.next, field_stack_el_t, link);
        field_path_print_rec(sb, e);
        sb_addc(sb, '.');
    }

    sb_add_lstr(sb, el->f->name);
    if (el->index >= 0) {
        sb_addf(sb, "[%d]", el->index);
    }
}

void sb_add_iop_field_stack(sb_t *nonnull buf,
                           const iop_field_stack_t *nonnull fstack)
{
    field_stack_el_t *el;

    el = htlist_first_entry(&fstack->flist, field_stack_el_t, link);
    if (el) {
        field_path_print_rec(buf, el);
    } else {
        sb_adds(buf, "<root>");
    }
}

lstr_t t_iop_field_stack_to_lstr(const iop_field_stack_t *nonnull fstack)
{
    SB_1k(buf);

    sb_add_iop_field_stack(&buf, fstack);

    return t_lstr_dup(LSTR_SB_V(&buf));
}

static void iop_field_stack_fill_head(iop_field_stack_t *fstack,
                                      const iop_struct_t *st_desc,
                                      const void *st_ptr,
                                      const iop_field_t *fdesc)
{
    field_stack_el_t *el;

    el = htlist_first_entry(&fstack->flist, field_stack_el_t, link);
    el->st_desc = st_desc;
    el->st_ptr = st_ptr;
    el->f = fdesc;
}

static int on_field_cb(const iop_struct_t *st_desc, void *st_ptr,
                       const iop_field_t *fdesc,
                       iop_field_stack_t *fstack,
                       iop_for_each_field_cb_b nonnull cb)
{
    iop_field_stack_fill_head(fstack, st_desc, st_ptr, fdesc);

    return cb(st_desc, fdesc, st_ptr, fstack);
}

#define F_LOCAL_WSTACK                                                       \
    field_stack_el_t _stack_el;                                              \
                                                                             \
    field_stack_el_init(&_stack_el);                                         \
    htlist_add(&fstack->flist, &_stack_el.link)

#define SET_INDEX_WSTACK(_index)                                             \
    htlist_first_entry(&fstack->flist, field_stack_el_t,                     \
                       link)->index = _index

#define ON_FIELD_DONE_WSTACK()  htlist_pop(&fstack->flist)

/* }}} */
/* {{{ iop_for_each_field() */

#define F_STATIC
#define F_NAME         _iop_for_each_field
#define F_PROTO                                                              \
    iop_field_stack_t *nonnull fstack,                                       \
    iop_for_each_field_cb_b nonnull cb
#define F_ARGS         fstack, cb
#define F_LOCAL        F_LOCAL_WSTACK

#define F(x)              x##_with_stack
#define ON_FIELD          on_field_cb
#define ON_FIELD_DONE()   ON_FIELD_DONE_WSTACK()
#define SET_INDEX(index)  SET_INDEX_WSTACK(index)
#include "for-each.in.c"

int iop_for_each_field(const iop_struct_t *nullable st_desc,
                       void *nonnull st_ptr,
                       iop_for_each_field_cb_b nonnull cb)
{
    iop_field_stack_t fstack;

    iop_field_stack_init(&fstack);

    return _iop_for_each_field(st_desc, st_ptr, &fstack, cb);
}

/* }}} */
/* {{{ iop_for_each_field_const() */

static int on_field_const_cb(
    const iop_struct_t *st_desc, const void *st_ptr,
    const iop_field_t *fdesc, iop_field_stack_t *fstack,
    iop_for_each_field_const_cb_b nonnull cb)
{
    iop_field_stack_fill_head(fstack, st_desc, st_ptr, fdesc);

    return cb(st_desc, fdesc, st_ptr, fstack);
}

#define F_STATIC
#define F_NAME         _iop_for_each_field_const
#define F_PROTO                                                              \
    iop_field_stack_t *nonnull fstack,                                       \
    iop_for_each_field_const_cb_b nonnull cb
#define F_ARGS         fstack, cb
#define F_LOCAL        F_LOCAL_WSTACK
#define MODIFIER       const

#define F(x)              x##_const_with_stack
#define ON_FIELD          on_field_const_cb
#define ON_FIELD_DONE()   ON_FIELD_DONE_WSTACK()
#define SET_INDEX(index)  SET_INDEX_WSTACK(index)
#include "for-each.in.c"

int iop_for_each_field_const(
    const iop_struct_t *nullable st_desc,
    const void *nonnull st_ptr,
    iop_for_each_field_const_cb_b nonnull cb)
{
    iop_field_stack_t fstack;

    iop_field_stack_init(&fstack);

    return _iop_for_each_field_const(st_desc, st_ptr, &fstack, cb);
}

/* }}} */
/* {{{ iop_for_each_field_fast() */

/* XXX Intermediary function because the block rewriter don't dig included C
 *     files. */
static int call_field_fast_cb(const iop_struct_t *st_desc, void *st_ptr,
                              const iop_field_t *fdesc,
                              iop_for_each_field_fast_cb_b cb)
{
    return cb(st_desc, fdesc, st_ptr);
}

#define F_NAME    iop_for_each_field_fast
#define F_PROTO   iop_for_each_field_fast_cb_b cb
#define F_ARGS    cb
#define F(x)      x##_blk_fast
#define ON_FIELD  call_field_fast_cb
#include "for-each.in.c"

/* }}} */
/* {{{ iop_for_each_field_const_fast() */

static int call_field_const_fast_cb(const iop_struct_t *st_desc,
                                    const void *st_ptr,
                                    const iop_field_t *fdesc,
                                    iop_for_each_field_const_fast_cb_b cb)
{
    return cb(st_desc, fdesc, st_ptr);
}

#define F_NAME    iop_for_each_field_const_fast
#define F_PROTO   iop_for_each_field_const_fast_cb_b cb
#define F_ARGS    cb
#define F(x)      x##_blk_const_fast
#define MODIFIER  const
#define ON_FIELD  call_field_const_fast_cb
#include "for-each.in.c"

/* }}} */
/* {{{ iop_for_each_st() */

static int on_field_st_cb(const iop_struct_t *st_desc, void *st_ptr,
                          const iop_field_t *fdesc,
                          iop_field_stack_t *fstack,
                          iop_for_each_st_cb_b nonnull cb)
{
    iop_field_stack_fill_head(fstack, st_desc, st_ptr, fdesc);

    return 0;
}

static int call_st_cb(const iop_struct_t *st_desc, void *st_ptr,
                      iop_field_stack_t *fstack, iop_for_each_st_cb_b cb)
{
    return cb(st_desc, st_ptr, fstack);
}

#define F_STATIC
#define F_NAME     _iop_for_each_st
#define F_PROTO                                                              \
    iop_field_stack_t *fstack,                                               \
    iop_for_each_st_cb_b cb
#define F_ARGS     fstack, cb
#define F(x)       x##_st_blk
#define ON_STRUCT  call_st_cb
#define F_LOCAL    F_LOCAL_WSTACK

#define ON_FIELD          on_field_st_cb
#define ON_FIELD_DONE()   ON_FIELD_DONE_WSTACK()
#define SET_INDEX(index)  SET_INDEX_WSTACK(index)

#include "for-each.in.c"

int iop_for_each_st(const iop_struct_t *nullable st_desc,
                    void *nonnull st_ptr,
                    iop_for_each_st_cb_b nonnull cb)
{
    iop_field_stack_t fstack;

    iop_field_stack_init(&fstack);

    return _iop_for_each_st(st_desc, st_ptr, &fstack, cb);
}

/* }}} */
/* {{{ iop_for_each_st_const() */

static int on_field_st_const_cb(const iop_struct_t *nonnull st_desc,
                                const void *nonnull st_ptr,
                                const iop_field_t *nonnull fdesc,
                                iop_field_stack_t *nonnull fstack,
                                iop_for_each_st_const_cb_b nonnull cb)
{
    iop_field_stack_fill_head(fstack, st_desc, st_ptr, fdesc);

    return 0;
}

static int call_st_const_cb(const iop_struct_t *st_desc,
                            const void *st_ptr,
                            iop_field_stack_t *fstack,
                            const iop_for_each_st_const_cb_b cb)
{
    return cb(st_desc, st_ptr, fstack);
}

#define F_STATIC
#define F_NAME     _iop_for_each_st_const
#define F_PROTO                                                              \
    iop_field_stack_t *fstack,                                               \
    iop_for_each_st_const_cb_b cb
#define F_ARGS     fstack, cb
#define F(x)       x##_st_const_blk
#define ON_STRUCT  call_st_const_cb
#define F_LOCAL    F_LOCAL_WSTACK
#define MODIFIER   const

#define ON_FIELD          on_field_st_const_cb
#define ON_FIELD_DONE()   ON_FIELD_DONE_WSTACK()
#define SET_INDEX(index)  SET_INDEX_WSTACK(index)

#include "for-each.in.c"

int iop_for_each_st_const(const iop_struct_t *nullable st_desc,
                          const void *nonnull st_ptr,
                          iop_for_each_st_const_cb_b nonnull cb)
{
    iop_field_stack_t fstack;

    iop_field_stack_init(&fstack);

    return _iop_for_each_st_const(st_desc, st_ptr, &fstack, cb);
}

/* }}} */
/* {{{ iop_for_each_st_fast() */

static int call_st_cb_fast(const iop_struct_t *st_desc, void *st_ptr,
                           iop_for_each_st_fast_cb_b cb)
{
    return cb(st_desc, st_ptr);
}

#define F_NAME     iop_for_each_st_fast
#define F_PROTO    iop_for_each_st_fast_cb_b cb
#define F_ARGS     cb
#define F(x)       x##_st_blk_fast
#define ON_STRUCT  call_st_cb_fast
#include "for-each.in.c"

/* }}} */
/* {{{ iop_for_each_st_const_fast() */

static int call_st_const_fast_cb(const iop_struct_t *st_desc, void *st_ptr,
                                 iop_for_each_st_const_fast_cb_b cb)
{
    return cb(st_desc, st_ptr);
}

#define F_NAME     iop_for_each_st_const_fast
#define F_PROTO    iop_for_each_st_const_fast_cb_b cb
#define F_ARGS     cb
#define F(x)       x##_st_const_fast_blk
#define MODIFIER   const
#define ON_STRUCT  call_st_const_fast_cb
#include "for-each.in.c"

/* }}} */

#undef F_LOCAL_WSTACK
#undef ON_FIELD_DONE_WSTACK
#undef SET_INDEX_WSTACK

/* }}} */
/* {{{ IOP iop_full_type_t */

uint32_t qhash_iop_full_type_hash(const qhash_t *qhash,
                                  const iop_full_type_t *type)
{
    if (type->type == IOP_T_ENUM) {
        return u64_hash32((uint64_t)type->en);
    }
    if (!iop_type_is_scalar(type->type)) {
        return u64_hash32((uint64_t)type->st);
    }

    return type->type;
}

bool qhash_iop_full_type_equal(const qhash_t *qhash,
                               const iop_full_type_t *t1,
                               const iop_full_type_t *t2)
{
    THROW_FALSE_IF(t1->type != t2->type);
    if (t1->type == IOP_T_ENUM) {
        return t1->en == t2->en;
    }
    if (!iop_type_is_scalar(t1->type)) {
        return t1->st == t2->st;
    }
    return true;
}

void iop_field_get_type(const iop_field_t *nonnull field,
                        iop_full_type_t *nonnull type)
{
    p_clear(type, 1);
    type->type = field->type;
    if (field->type == IOP_T_ENUM) {
        type->en = field->u1.en_desc;
    } else
    if (!iop_type_is_scalar(field->type)) {
        type->st = field->u1.st_desc;
    }
}

/* }}} */
/* {{{ IOP context */

static void iop_env_copy(iop_env_t *dst, iop_env_t *src)
{
    iop_env_init(dst);

    qm_for_each_pos(iop_class_by_id, pos, &src->classes_by_id) {
        qm_add(iop_class_by_id, &dst->classes_by_id,
               &src->classes_by_id.keys[pos], src->classes_by_id.values[pos]);
    }
    qm_for_each_pos(iop_dsos, pos, &src->dsos_by_pkg) {
        qm_add(iop_dsos, &dst->dsos_by_pkg, src->dsos_by_pkg.keys[pos],
               src->dsos_by_pkg.values[pos]);
    }

    qm_set_minsize(iop_objs, &dst->iop_obj_by_fullname,
                   qm_len(iop_objs, &src->iop_obj_by_fullname));
    qm_for_each_pos(iop_objs, pos, &src->iop_obj_by_fullname) {
        qv_t(iop_obj) vec;
        lstr_t obj_fullname;

        obj_fullname = lstr_dup(src->iop_obj_by_fullname.keys[pos]);
        qv_init(&vec);
        qv_copy(&vec, &src->iop_obj_by_fullname.values[pos]);
        qm_add(iop_objs, &dst->iop_obj_by_fullname, &obj_fullname, vec);
    }
}

void iop_env_set(iop_env_t *env)
{
    iop_env_wipe(&_G.env);
    _G.env = *env;
}

void iop_env_get(iop_env_t *env)
{
    iop_env_copy(env, &_G.env);
}

iop_env_t *iop_env_init(iop_env_t *env)
{
    qm_init(iop_class_by_id, &env->classes_by_id);
    qm_init(iop_dsos,   &env->dsos_by_pkg);
    qm_init(iop_objs,   &env->iop_obj_by_fullname);
    return env;
}

void iop_env_wipe(iop_env_t *env)
{
    qm_wipe(iop_class_by_id, &env->classes_by_id);
    qm_wipe(iop_dsos,      &env->dsos_by_pkg);
    qm_deep_wipe(iop_objs, &env->iop_obj_by_fullname, lstr_wipe, qv_wipe);
}

/* }}} */
/* {{{ Class manipulation */

iop_value_t const *
iop_get_class_cvar_desc(const iop_struct_t *desc, lstr_t name)
{
    iop_static_field_t _search = { .name = name };
    iop_static_field_t *search = &_search;

    const iop_class_attrs_t *cls = desc->class_attrs;
    bool found;
    int pos;
    cmp_b cmp = ^int (const void *a, const void *b) {
        const iop_static_field_t **v1 = (const iop_static_field_t **)a;
        const iop_static_field_t **v2 = (const iop_static_field_t **)b;

        return lstr_cmp((*v1)->name, (*v2)->name);
    };

    assert (iop_struct_is_class(desc));

    pos = bisect_blk(&search, cls->static_fields,
                     sizeof(iop_static_field_t *),
                     cls->static_fields_len, &found, cmp);
    if (found) {
        const iop_static_field_t *f;

        f = desc->class_attrs->static_fields[pos];
        return &f->value;
    }
    return NULL;
}

const iop_value_t *iop_get_class_cvar(const void *obj, lstr_t name)
{
    return iop_get_class_cvar_desc(*(iop_struct_t **)obj, name);
}

const iop_value_t *iop_get_cvar_desc(const iop_struct_t *desc, lstr_t name)
{
    assert (iop_struct_is_class(desc));

    do {
        const iop_class_attrs_t *cls = desc->class_attrs;
        const iop_value_t *v;

        if ((v = iop_get_class_cvar_desc(desc, name))) {
            return v;
        }
        desc = cls->parent;
    } while (desc);

    return NULL;
}

const iop_value_t *iop_get_cvar(const void *obj, lstr_t name)
{
    return iop_get_cvar_desc(*(iop_struct_t **)obj, name);
}

bool iop_class_is_a(const iop_struct_t *cls1, const iop_struct_t *cls2)
{
    if (!iop_struct_is_class(cls1) || !iop_struct_is_class(cls2)) {
        assert (false);
        return false;
    }

    do {
        if (cls1 == cls2) {
            return true;
        }
    } while ((cls1 = cls1->class_attrs->parent));

    return false;
}

static const qv_t(iop_obj) *
iop_get_objs_env(lstr_t fullname, const iop_env_t *env)
{
    int pos;

    pos = RETHROW_NP(qm_find_safe(iop_objs, &env->iop_obj_by_fullname,
                                  &fullname));

    return &env->iop_obj_by_fullname.values[pos];
}

static const qv_t(iop_obj) *iop_get_objs(lstr_t fullname)
{
    return iop_get_objs_env(fullname, &_G.env);
}

const iop_struct_t *
iop_get_class_by_fullname(const iop_struct_t *st, lstr_t fullname)
{
    const qv_t(iop_obj) *objs;

    assert (iop_struct_is_class(st));
    while (st->class_attrs->parent) {
        st = st->class_attrs->parent;
    }

    objs = RETHROW_P(iop_get_objs(fullname));

    tab_for_each_ptr(obj, objs) {
        if (obj->type == IOP_OBJ_TYPE_ST
        &&  obj->ancestor == st)
        {
            return obj->desc.st;
        }
    }

    return NULL;
}

const iop_struct_t *
iop_get_class_by_id(const iop_struct_t *st, uint16_t class_id)
{
    class_id_key_t key = {
        .master   = st,
        .child_id = class_id,
    };

    if (st->class_attrs->class_id == class_id) {
        return st;
    }

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    return qm_get_def_safe(iop_class_by_id, &_G.env.classes_by_id, &key,
                           NULL);
}

void iop_for_each_registered_classes(iop_for_each_class_b cb)
{
    qm_for_each_pos(iop_class_by_id, pos, &_G.env.classes_by_id) {
        cb(_G.env.classes_by_id.values[pos]);
    }
}

/* }}} */
/* {{{ Snmp manipulation */

int iop_struct_get_nb_snmp_indexes(const iop_struct_t *st)
{
    int nb = 0;

    for (int i = 0; i < st->fields_len; i++) {
        if (iop_field_is_snmp_index(&st->fields[i])) {
            nb++;
        }
    }
    return nb;
}

int iop_struct_get_nb_snmp_smiv2_indexes(const iop_struct_t *st)
{
    int nb = 0;

    for (int i = 0; i < st->fields_len; i++) {
        const iop_field_t *field =&st->fields[i];

        if (iop_field_is_snmp_index(field)) {
            if (field->type == IOP_T_STRING) {
                /* there is at most 128 sub-identifiers
                 * (see RFC 2578, section 3.5). */
                return 128;
            } else {
                nb++;
            }
        }
    }

    return MIN(nb, 128);
}

const iop_snmp_attrs_t *iop_get_snmp_attrs(const iop_field_attrs_t *attrs)
{
    for (int i = 0; i < attrs->attrs_len; i++) {
        if (attrs->attrs[i].type == IOP_FIELD_SNMP_INFO) {
            return (iop_snmp_attrs_t*)attrs->attrs[i].args->v.p;
        }
    }
    e_panic("all snmpObj fields should have snmp attribute");
}

const iop_snmp_attrs_t *iop_get_snmp_attr_match_oid(const iop_struct_t *st,
                                                    int oid)
{
    assert (iop_struct_is_snmp_st(st));

    for (int i = 0; i < st->fields_len; i++) {
        const iop_field_t *field = &st->fields[i];

        if (field->tag == oid) {
            return iop_get_snmp_attrs(&st->fields_attrs[i]);
        }
    }
    e_panic("no field matches wanted OID");
}

const iop_field_attrs_t *iop_get_field_attr_match_oid(const iop_struct_t *st,
                                                      int tag)
{
    for (int i = 0; i < st->fields_len; i++) {
        const iop_field_t *field = &st->fields[i];

        if (field->tag == tag) {
            return &st->fields_attrs[i];
        }
    }
    e_panic("no field matches wanted OID");
}

/* }}} */
/* {{{ Packages registration / manipulation */

static int iop_register_class(const iop_struct_t *desc, iop_env_t *env,
                              sb_t *err)
{
    class_id_key_t key = {
        .master   = desc,
        .child_id = desc->class_attrs->class_id,
    };
    uint32_t pos;

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    /* Register in classes_by_id hash table */
    pos = qm_put(iop_class_by_id, &env->classes_by_id, &key, desc, 0);
    if (pos & QHASH_COLLISION) {
        pos ^= QHASH_COLLISION;
        if (env->classes_by_id.values[pos] != desc) {
            sb_setf(err,
                    "conflicting class id %d: used by both '%*pM' and '%*pM'",
                    desc->class_attrs->class_id, LSTR_FMT_ARG(desc->fullname),
                    LSTR_FMT_ARG(env->classes_by_id.values[pos]->fullname));
            return -1;
        }
    }
    return 0;
}

static int
iop_class_check_parents_are_registered(const iop_struct_t *st,
                                       const iop_struct_t *master,
                                       const iop_env_t *env,
                                       qh_t(cptr) *registered,
                                       sb_t *err)
{
    uint32_t pos;
    const iop_struct_t *child = st;

    pos = qh_put(cptr, registered, st, 0);
    if (pos & QHASH_COLLISION) {
        return 0;
    }

    while ((st = st->class_attrs->parent)) {
        class_id_key_t key = {
            .master   = master,
            .child_id = st->class_attrs->class_id,
        };

        pos = qh_put(cptr, registered, st, 0);
        if (pos & QHASH_COLLISION) {
            return 0;
        }

        if (qm_find_safe(iop_class_by_id, &env->classes_by_id, &key) < 0) {
            sb_setf(err, "class `%*pM` is not registered while its child "
                    "class `%*pM` is", LSTR_FMT_ARG(st->fullname),
                    LSTR_FMT_ARG(child->fullname));
            return -1;
        }
    }

    return 0;
}

int iop_check_registered_classes(const iop_env_t *env, sb_t *err)
{
    /* Check all the parent classes of the registered classes are also
     * registered. */
    t_scope;
    qh_t(cptr) registered;

    t_qh_init(cptr, &registered,
              qm_len(iop_class_by_id, &env->classes_by_id));

    qm_for_each_pos(iop_class_by_id, pos, &env->classes_by_id) {
        const iop_struct_t *st     = env->classes_by_id.values[pos];
        const iop_struct_t *master = env->classes_by_id.keys[pos].master;

        RETHROW(iop_class_check_parents_are_registered(st, master, env,
                                                       &registered, err));
    }

    return 0;
}

static const char *iop_obj_type_to_str(const iop_obj_t *obj)
{
    switch (obj->type) {
      case IOP_OBJ_TYPE_ST: {
        const iop_struct_t *st = obj->desc.st;

        if (st->is_union) {
            return "union";
        }

        if (iop_struct_is_class(st)) {
            return "class";
        }

        return "struct";
      }

      case IOP_OBJ_TYPE_ENUM:
        return "enum";

      case IOP_OBJ_TYPE_PKG:
        return "package";
    }

    assert (false);
    return NULL;
}

static inline bool iop_obj_equals(iop_obj_t obj1, iop_obj_t obj2)
{
    THROW_FALSE_IF(obj1.type != obj2.type);
    return obj1.desc.st == obj2.desc.st;
}

static int
iop_register_obj(lstr_t fullname, iop_obj_t obj, unsigned flags,
                 iop_env_t *env, sb_t *err)
{
    qv_t(iop_obj) *vec;
    uint32_t pos;

    pos = qm_reserve(iop_objs, &env->iop_obj_by_fullname, &fullname, 0);
    if (pos & QHASH_COLLISION) {
        vec = &env->iop_obj_by_fullname.values[pos & ~QHASH_COLLISION];
        tab_for_each_entry(_obj, vec) {
            if (iop_obj_equals(_obj, obj)) {
                return 0;
            }
        }

        if (!(flags & IOP_REGPKG_FROM_DSO)) {
            sb_setf(err, "%s '%*pM' was already registered",
                    iop_obj_type_to_str(&obj), LSTR_FMT_ARG(fullname));
            return -1;
        }
    } else {
        vec = qv_init(&env->iop_obj_by_fullname.values[pos]);
        env->iop_obj_by_fullname.keys[pos] = lstr_dup(fullname);
    }

    qv_append(vec, obj);
    return 1;
}

#define IOP_OBJ_ST(_st)  \
    (iop_obj_t){ .desc = { .st = _st }, .type = IOP_OBJ_TYPE_ST }
#define IOP_OBJ_ENUM(_en)  \
    (iop_obj_t){ .desc = { .en = _en }, .type = IOP_OBJ_TYPE_ENUM }
#define IOP_OBJ_PKG(_pkg)  \
    (iop_obj_t){ .desc = { .pkg = _pkg }, .type = IOP_OBJ_TYPE_PKG }

static int
iop_register_struct(const iop_struct_t *st, unsigned flags,
                    iop_env_t *env, sb_t *err)
{
    iop_obj_t obj = IOP_OBJ_ST(st);

    if (iop_struct_is_class(st)) {
        const iop_struct_t *parent = st;

        while (parent->class_attrs->parent) {
            parent = parent->class_attrs->parent;
        }
        obj.ancestor = parent;

        RETHROW(iop_register_class(st, env, err));
    }

    return iop_register_obj(st->fullname, obj, flags, env, err);
}

static int
iop_register_enum(const iop_enum_t *en, unsigned flags, iop_env_t *env,
                  sb_t *err)
{
    return iop_register_obj(en->fullname, IOP_OBJ_ENUM(en), flags, env, err);
}

static int
iop_register_pkg(const iop_pkg_t *pkg, unsigned flags, iop_env_t *env,
                 sb_t *err)
{
    return iop_register_obj(pkg->name, IOP_OBJ_PKG(pkg), flags, env, err);
}

int iop_register_packages_env(const iop_pkg_t **pkgs, int len, iop_dso_t *dso,
                              iop_env_t *env, unsigned flags, sb_t *err)
{
    if (dso) {
        assert (flags & IOP_REGPKG_FROM_DSO);
    } else {
        assert (!(flags & IOP_REGPKG_FROM_DSO));
    }

    /* Register the packages. */
    for (int i = 0; i < len; i++) {
        const iop_pkg_t *pkg = pkgs[i];
        int ret;

        /* Register the package itself. */
        ret = RETHROW(iop_register_pkg(pkg, flags, env, err));
        if (ret == 0) {
            continue;
        }
        if (dso) {
            qm_add(iop_dsos, &env->dsos_by_pkg, pkg, dso);
        }

        /* Register its structs/union/classes. */
        for (const iop_struct_t *const *it = pkg->structs; *it; it++) {
            const iop_struct_t *desc = *it;

            RETHROW(iop_register_struct(desc, flags, env, err));
        }

        /* Register its enums. */
        for (const iop_enum_t *const *it = pkg->enums; *it; it++) {
            const iop_enum_t *desc = *it;

            RETHROW(iop_register_enum(desc, flags, env, err));
        }
    }

    return 0;
}

void iop_register_packages(const iop_pkg_t **pkgs, int len, unsigned flags)
{
    SB_1k(err);

    if (iop_register_packages_env(pkgs, len, NULL, &_G.env, flags, &err) < 0)
    {
        e_panic("%*pM", SB_FMT_ARG(&err));
    }
}

const iop_enum_t *iop_get_enum(lstr_t fullname)
{
    const iop_obj_t *obj = RETHROW_P(iop_get_obj(fullname));

    THROW_NULL_IF(obj->type != IOP_OBJ_TYPE_ENUM);

    return obj->desc.en;
}

static const iop_obj_t *iop_get_obj_env(lstr_t fullname, const iop_env_t *env)
{
    return &RETHROW_P(iop_get_objs_env(fullname, env))->tab[0];
}

const iop_obj_t *iop_get_obj(lstr_t fullname)
{
    return iop_get_obj_env(fullname, &_G.env);
}

const iop_pkg_t *iop_get_pkg_env(lstr_t pkgname, const iop_env_t *env)
{
    const iop_obj_t *obj;

    obj = RETHROW_P(iop_get_obj_env(pkgname, env));
    THROW_NULL_IF(obj->type != IOP_OBJ_TYPE_PKG);

    return obj->desc.pkg;
}

const iop_pkg_t *iop_get_pkg(lstr_t pkgname)
{
    return iop_get_pkg_env(pkgname, &_G.env);
}

iop_dso_t *iop_dso_get_from_pkg(const iop_pkg_t *pkg)
{
    return qm_get_def_safe(iop_dsos, &_G.env.dsos_by_pkg, pkg, NULL);
}

static void iop_unregister_class(const iop_struct_t *desc)
{
    class_id_key_t key = {
        .master   = desc,
        .child_id = desc->class_attrs->class_id,
    };

    while (key.master->class_attrs->parent) {
        key.master = key.master->class_attrs->parent;
    }

    qm_del_key(iop_class_by_id, &_G.env.classes_by_id, &key);
}

static int iop_unregister_obj(lstr_t fullname, iop_obj_t obj)
{
    int pos;
    qv_t(iop_obj) *vec;

    pos = RETHROW(qm_find(iop_objs, &_G.env.iop_obj_by_fullname, &fullname));
    vec = &_G.env.iop_obj_by_fullname.values[pos];
    tab_for_each_pos(obj_pos, vec) {
        if (iop_obj_equals(vec->tab[obj_pos], obj)) {
            if (vec->len > 1) {
                qv_remove(vec, obj_pos);
            } else {
                qv_wipe(vec);
                lstr_wipe(&_G.env.iop_obj_by_fullname.keys[pos]);
                qm_del_at(iop_objs, &_G.env.iop_obj_by_fullname, pos);
            }

            return 0;
        }
    }

    return -1;
}

static int iop_unregister_struct(const iop_struct_t *st)
{
    return iop_unregister_obj(st->fullname, IOP_OBJ_ST(st));
}

static int iop_unregister_enum(const iop_enum_t *en)
{
    return iop_unregister_obj(en->fullname, IOP_OBJ_ENUM(en));
}

void iop_unregister_packages(const iop_pkg_t **pkgs, int len)
{
    SB_1k(err);

    for (int i = 0; i < len; i++) {
        const iop_pkg_t *pkg = pkgs[i];

        /* Unregister the package itself. */
        if (iop_unregister_obj(pkg->name, IOP_OBJ_PKG(pkg)) < 0) {
            continue;
        }
        qm_del_key(iop_dsos, &_G.env.dsos_by_pkg, pkg);

        /* Unregister its classes. */
        for (const iop_struct_t *const *it = pkg->structs; *it; it++) {
            const iop_struct_t *desc = *it;

            if (iop_struct_is_class(desc)) {
                iop_unregister_class(desc);
            }

            iop_unregister_struct(desc);
        }

        /* Unregister its enums. */
        for (const iop_enum_t *const *it = pkg->enums; *it; it++) {
            const iop_enum_t *desc = *it;

            iop_unregister_enum(desc);
        }
    }

    if (iop_check_registered_classes(&_G.env, &err) < 0) {
        e_panic("%*pM", SB_FMT_ARG(&err));
    }
}

void iop_for_each_registered_pkgs(iop_for_each_pkg_b cb)
{
    qm_for_each_pos(iop_objs, pos, &_G.env.iop_obj_by_fullname) {
        tab_for_each_entry(obj, &_G.env.iop_obj_by_fullname.values[pos]) {
            if (obj.type == IOP_OBJ_TYPE_PKG) {
                cb(obj.desc.pkg);
            }
        }
    }
}

/* }}} */
/* {{{ Enum printf formatter %*pE */

static ssize_t
iop_enum_formatter(int modifier, const void *_ev, size_t flags,
                   FILE *stream, char *buf, size_t buf_len)
{
    const struct iop_enum_value *ev = _ev;
    lstr_t s = iop_enum_to_str_desc(ev->desc, ev->v);

    if (flags & IOP_ENUM_FMT_FULL) {
        if (!s.s) {
            return formatter_writef(stream, buf, buf_len, "<unknown>(%d)",
                                    ev->v);
        }

        return formatter_writef(stream, buf, buf_len, "%*pM(%d)",
                                LSTR_FMT_ARG(s), ev->v);
    }

    if (!s.s) {
        return formatter_writef(stream, buf, buf_len, "%d", ev->v);
    }

    return formatter_write(stream, buf, buf_len, s.s, s.len);
}

/* }}} */
/* {{{ Union type formatter */

static ssize_t
iop_union_type_formatter(int modifier, const void *_desc, size_t iop_tag,
                         FILE *stream, char *buf, size_t buf_len)
{
    const iop_struct_t *desc = _desc;
    lstr_t type_s;
    int pos;

    pos = iop_ranges_search(desc->ranges, desc->ranges_len, iop_tag);
    if (unlikely(pos < 0)) {
        return formatter_writef(stream, buf, buf_len, "<unknown>(%zd)",
                                iop_tag);
    }

    type_s = desc->fields[pos].name;

    return formatter_write(stream, buf, buf_len, type_s.s, type_s.len);
}

/* }}} */
/* {{{ Backward compatibility checks */

typedef struct iop_compat_couple_t {
    const void *st1;
    const void *st2;
    unsigned flags;
    unsigned padding;
} iop_compat_couple_t;

static uint32_t qhash_hash_compat_couple(const qhash_t *qh,
                                         const iop_compat_couple_t *ptr)
{
    return mem_hash32(ptr, sizeof(*ptr));
}
static bool qhash_compat_couple_equal(const qhash_t *qh,
                                      const iop_compat_couple_t *ptr1,
                                      const iop_compat_couple_t *ptr2)
{
    return memcmp(ptr1, ptr2, sizeof(*ptr1)) == 0;
}

qh_kvec_t(compat_couple, iop_compat_couple_t,
          qhash_hash_compat_couple, qhash_compat_couple_equal);

struct iop_compat_ctx_t {
    qh_t(compat_couple) seen_couples;
    qh_t(cptr)          seen_opt_st;
    sb_t *err;
    sb_t err_ctx;
    qv_t(i32) err_ctx_offs;
    int indent_lvl;
};

static iop_compat_ctx_t *iop_compat_ctx_init(iop_compat_ctx_t *ctx)
{
    p_clear(ctx, 1);
    qh_init(compat_couple, &ctx->seen_couples);
    qh_init(cptr, &ctx->seen_opt_st);
    sb_init(&ctx->err_ctx);
    qv_init(&ctx->err_ctx_offs);
    return ctx;
}
static void iop_compat_ctx_wipe(iop_compat_ctx_t *ctx)
{
    qh_wipe(compat_couple, &ctx->seen_couples);
    qh_wipe(cptr, &ctx->seen_opt_st);
    sb_wipe(&ctx->err_ctx);
    qv_wipe(&ctx->err_ctx_offs);
}
DO_NEW(iop_compat_ctx_t, iop_compat_ctx);
DO_DELETE(iop_compat_ctx_t, iop_compat_ctx);

static void iop_compat_make_indent(sb_t *sb, int indent_lvl)
{
    for (int i = 0; i < indent_lvl; i++) {
        sb_adds(sb, "  | ");
    }
}

__attr_printf__(2, 3)
static void
iop_compat_push_err_ctx(iop_compat_ctx_t *ctx, const char *fmt, ...)
{
    va_list ap;

    qv_append(&ctx->err_ctx_offs, ctx->err_ctx.len);

    iop_compat_make_indent(&ctx->err_ctx, ctx->indent_lvl);
    va_start(ap, fmt);
    sb_addvf(&ctx->err_ctx, fmt, ap);
    va_end(ap);
    sb_addc(&ctx->err_ctx, '\n');

    ctx->indent_lvl++;
}

static void iop_compat_pop_err_ctx(iop_compat_ctx_t *ctx)
{
    ctx->indent_lvl--;
    assert (ctx->indent_lvl >= 0);
    if (ctx->err_ctx_offs.len > 0) {
        sb_clip(&ctx->err_ctx, *tab_last(&ctx->err_ctx_offs));
        qv_remove_last(&ctx->err_ctx_offs);
    }
}

__attr_printf__(2, 3)
static void iop_compat_add_err(iop_compat_ctx_t *ctx, const char *fmt, ...)
{
    va_list ap;

    if (ctx->err->len > 0) {
        sb_addc(ctx->err, '\n');
    }

    sb_addsb(ctx->err, &ctx->err_ctx);
    sb_reset(&ctx->err_ctx);
    qv_clear(&ctx->err_ctx_offs);

    iop_compat_make_indent(ctx->err, ctx->indent_lvl);

    va_start(ap, fmt);
    sb_addvf(ctx->err, fmt, ap);
    va_end(ap);
}

static int
__iop_struct_check_backward_compat(const iop_struct_t *st1,
                                   const iop_struct_t *st2,
                                   unsigned flags, iop_compat_ctx_t *ctx);

/* Add compat couple into the hash table. A special handler is needed as flags
 * must be added individually. Flags that need to be checked are returned. */
static unsigned
iop_compat_mark_couple(const void *st1, const void *st2,
                       unsigned flags, iop_compat_ctx_t *ctx)
{
    iop_compat_couple_t couple = {
        .st1   = st1,
        .st2   = st2,
    };
    unsigned chk_flags = flags;

    for (unsigned i = 0; flags && i < bitsizeof(flags); i++) {
        if (!TST_BIT(&flags, i)) {
            continue;
        }

        couple.flags = 1 << i;
        if (qh_add(compat_couple, &ctx->seen_couples, &couple) < 0) {
            /* Couple already checked with this flag. */
            RST_BIT(&chk_flags, i);
        }
        RST_BIT(&flags, i);
    }

    return chk_flags;
}

static int
__iop_enum_check_backward_compat(const iop_enum_t *en1,
                                 const iop_enum_t *en2,
                                 unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    /* XXX: do not simply test en1 == en2 because it allows to easily write
     *      "compatible" z-tests. */

    if (!(flags = iop_compat_mark_couple(en1, en2, flags, ctx))) {
        /* No checks to be done. */
        return 0;
    }

    if (!TST_BIT(&en1->flags, IOP_ENUM_STRICT)
    &&   TST_BIT(&en2->flags, IOP_ENUM_STRICT))
    {
        iop_compat_add_err(ctx, "enum is strict and was not before");
        res = -1;
    }

    for (int i = 0; i < en1->enum_len; i++) {
        int pos2_bin  = -1;
        int pos2_json = -1;

        if (flags & IOP_COMPAT_BIN) {
            pos2_bin = iop_ranges_search(en2->ranges, en2->ranges_len,
                                         en1->values[i]);
            if (pos2_bin < 0) {
                iop_compat_add_err(ctx,
                                   "numeric value %d does not exist anymore",
                                   en1->values[i]);
                res = -1;
            }
        }

        if (flags & IOP_COMPAT_JSON) {
            pos2_json = iop_enum_pos_from_str(en2, en1->names[i].s,
                                              en1->names[i].len);
            if (pos2_json < 0) {
                iop_compat_add_err(ctx, "value `%*pM` does not exist anymore",
                                   LSTR_FMT_ARG(en1->names[i]));
                res = -1;
            }
        }

        if (pos2_bin >= 0 && pos2_json >= 0 && pos2_bin != pos2_json) {
            iop_compat_add_err(ctx, "value `%*pM` (%d): name and value "
                               "lookups mismatch: `%*pM` (%d) != `%*pM` (%d)",
                               LSTR_FMT_ARG(en1->names[i]), en1->values[i],
                               LSTR_FMT_ARG(en2->names[pos2_json]),
                               en2->values[pos2_json],
                               LSTR_FMT_ARG(en2->names[pos2_bin]),
                               en2->values[pos2_bin]);
            res = -1;
        }
    }

    return res;
}

static void
backward_compat_build_tables(uint32_t table_bin[IOP_T_max + 1],
                             uint32_t table_json[IOP_T_max + 1],
                             uint32_t table_bin_r[IOP_T_max + 1])
{
    STATIC_ASSERT (IOP_T_max <= bitsizeof(uint32_t));

    /* A type is always compatible with void and itself. */
    for (int i = 0; i <= IOP_T_max; i++) {
        table_bin[i] = TO_BIT(VOID) | 1U << i;
    }

    /* Build authorized binary types transition table. */
    table_bin[IOP_T_U32]    |= TO_BIT(U64)          | TO_BIT(I64);
    table_bin[IOP_T_I32]    |= TO_BIT(U64)          | TO_BIT(I64);
    table_bin[IOP_T_U16]    |= table_bin[IOP_T_U32] | table_bin[IOP_T_I32];
    table_bin[IOP_T_I16]    |= table_bin[IOP_T_U32] | table_bin[IOP_T_I32];
    table_bin[IOP_T_U8]     |= table_bin[IOP_T_U16] | table_bin[IOP_T_I16];
    table_bin[IOP_T_I8]     |= table_bin[IOP_T_U16] | table_bin[IOP_T_I16];
    table_bin[IOP_T_BOOL]   |= table_bin[IOP_T_U8]  | table_bin[IOP_T_I8];
    table_bin[IOP_T_ENUM]   |= table_bin[IOP_T_I32];

    table_bin[IOP_T_STRING] |= TO_BIT(DATA)         | TO_BIT(XML);
    table_bin[IOP_T_DATA]   = table_bin[IOP_T_STRING];
    table_bin[IOP_T_XML]    = table_bin[IOP_T_STRING];

    /* Build authorized json types transition table. */
    p_copy(table_json, table_bin, IOP_T_max + 1);
    table_json[IOP_T_ENUM]   = TO_BIT(ENUM)   | TO_BIT(VOID);
    table_json[IOP_T_STRING] = TO_BIT(STRING) | TO_BIT(VOID);
    table_json[IOP_T_DATA]   = TO_BIT(DATA)   | TO_BIT(VOID);
    table_json[IOP_T_XML]    = TO_BIT(XML)    | TO_BIT(VOID);

    /* build repeated table for binary format due to special array packing
     * (cf : IOP_REPEATED_OPTIMIZE_OK) */
    p_copy(table_bin_r, table_bin, IOP_T_max + 1);
    table_bin_r[IOP_T_U16]  = TO_BIT(U16);
    table_bin_r[IOP_T_I16]  = TO_BIT(I16);
    table_bin_r[IOP_T_U8]   = TO_BIT(U8);
    table_bin_r[IOP_T_I8]   = TO_BIT(I8);
    table_bin_r[IOP_T_BOOL] = TO_BIT(U8) | TO_BIT(I8) | TO_BIT(BOOL);
}

static bool _iop_struct_is_optional(const iop_struct_t *st,
                                    bool forbid_abstract,
                                    bool check_parents,
                                    iop_compat_ctx_t *ctx);

static int
iop_field_check_backward_compat(const iop_field_t *f1,
                                const iop_field_t *f2,
                                unsigned flags, iop_compat_ctx_t *ctx)
{
    static int first_call = true;
    static uint32_t table_bin[IOP_T_max + 1];
    static uint32_t table_json[IOP_T_max + 1];
    static uint32_t table_bin_r[IOP_T_max + 1];

    if (unlikely(first_call)) {
        first_call = false;
        backward_compat_build_tables(table_bin, table_json, table_bin_r);
    }

    /* Check type transition. */
    if (f1->repeat == IOP_R_REPEATED && f2->repeat == IOP_R_REPEATED) {
        if ((flags & IOP_COMPAT_BIN
             && !TST_BIT(&table_bin_r[f1->type], f2->type))
        ||  (flags & IOP_COMPAT_JSON
             && !TST_BIT(&table_json[f1->type], f2->type)))
        {
            iop_compat_add_err(ctx, "incompatible types");
            return -1;
        }
    } else {
        if ((flags & IOP_COMPAT_BIN
             && !TST_BIT(&table_bin[f1->type], f2->type))
        ||  (flags & IOP_COMPAT_JSON
             && !TST_BIT(&table_json[f1->type], f2->type)))
        {
            iop_compat_add_err(ctx, "incompatible types");
            return -1;
        }
    }

    /* Check repeated -> non-repeated: always forbidden
     * (except when replacing with non-repeated void)
     * (non-repeated -> repeated is always supported) */
    if (f1->repeat == IOP_R_REPEATED && f2->repeat != IOP_R_REPEATED
    &&  f2->type != IOP_T_VOID)
    {
        iop_compat_add_err(ctx, "was repeated and is not anymore");
        return -1;
    }

    /* Check non-required -> required:
     * forbidden iff it isn't an optional struct or void. */
    if ((f1->repeat == IOP_R_DEFVAL || f1->repeat == IOP_R_OPTIONAL)
    &&  f2->repeat == IOP_R_REQUIRED && f2->type != IOP_T_VOID
    &&  (f2->type != IOP_T_STRUCT
         || !_iop_struct_is_optional(f2->u1.st_desc, true, true, ctx)))
    {
        iop_compat_add_err(ctx, "is required and was not before");
        return -1;
    }

    /* Check backward compat of complex types. */
    switch (f2->type) {
      case IOP_T_UNION:
      case IOP_T_STRUCT:
        assert (f1->type == f2->type);
        return __iop_struct_check_backward_compat(f1->u1.st_desc,
                                                  f2->u1.st_desc,
                                                  flags, ctx);

      case IOP_T_ENUM:
        assert (f1->type == f2->type);
        if (!f1->u1.en_desc || !f2->u1.en_desc) {
            /* This happens for SNMP traps using an enumeration... */
            return 0;
        }
        return __iop_enum_check_backward_compat(f1->u1.en_desc,
                                                f2->u1.en_desc,
                                                flags, ctx);
      case IOP_T_I8:
      case IOP_T_I16:
      case IOP_T_I32:
      case IOP_T_I64:
      case IOP_T_BOOL:
      case IOP_T_DOUBLE:
      case IOP_T_U8:
      case IOP_T_U16:
      case IOP_T_U32:
      case IOP_T_U64:
      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
      case IOP_T_VOID:
        break;
    }

    return 0;
}

static const iop_struct_t *
get_parents_until_id(const iop_struct_t *st, const uint16_t *class_id,
                     qv_t(iop_struct) *vec)
{
    while ((st = st->class_attrs->parent)) {
        if (class_id && st->class_attrs->class_id == *class_id) {
            break;
        }
        qv_append(vec, st);
    }

    return st;
}

static const iop_struct_t *
get_parents_until_name(const iop_struct_t *st, const lstr_t *name,
                       qv_t(iop_struct) *vec)
{
    while ((st = st->class_attrs->parent)) {
        if (name && lstr_equal(st->fullname, *name)) {
            break;
        }
        qv_append(vec, st);
    }

    return st;
}

static bool are_all_parents_empty(const iop_struct_t *st)
{
    while ((st = st->class_attrs->parent)) {
        if (st->fields_len) {
            return false;
        }
    }

    return true;
}

/* Check that none of the classes added as parents contain a required
 * field. */
static int
check_parent_required_fields(const qv_t(iop_struct) *parents,
                             iop_compat_ctx_t *ctx)
{
    tab_for_each_entry(parent, parents) {
        for (int i = 0; i < parent->fields_len; i++) {
            const iop_field_t *f = &parent->fields[i];

            if (f->repeat == IOP_R_REQUIRED
            &&  (f->type != IOP_T_STRUCT
              || !_iop_struct_is_optional(f->u1.st_desc, true, true, ctx)))
            {
                iop_compat_add_err(ctx, "class `%*pM` was added in the "
                                   "parents with a required field `%*pM`",
                                   LSTR_FMT_ARG(parent->fullname),
                                   LSTR_FMT_ARG(f->name));
                return -1;
            }
        }
    }
    return 0;
}

static int
check_class_parent(const iop_struct_t *st1,
                    const iop_struct_t *parent,
                    unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    iop_compat_push_err_ctx(ctx, "parent `%*pM`:",
                            LSTR_FMT_ARG(parent->fullname));
    res = __iop_struct_check_backward_compat(st1->class_attrs->parent,
                                             parent, flags, ctx);
    iop_compat_pop_err_ctx(ctx);

    return res;
}

static int
check_parent_classes(const iop_struct_t *st1, const iop_struct_t *st2,
                    unsigned flags, iop_compat_ctx_t *ctx)
{
    const iop_struct_t *st2_parent_bin = NULL;
    const iop_struct_t *st2_parent_json = NULL;
    qv_t(iop_struct) parents;
    int res = 0;

    if (!st1->class_attrs->parent && !st2->class_attrs->parent) {
        return 0;
    }

    qv_init(&parents);

    /* Get the classes added in the parents between 'st2' and 'st1'. */
    if (flags & IOP_COMPAT_BIN) {
        const uint16_t *class_id = NULL;

        if (st1->class_attrs->parent) {
            class_id = &st1->class_attrs->parent->class_attrs->class_id;
        }
        st2_parent_bin = get_parents_until_id(st2, class_id, &parents);
        if (class_id && !st2_parent_bin) {
            iop_compat_add_err(ctx, "cannot find class with id %d in the "
                               "parents of `%*pM`",
                               *class_id, LSTR_FMT_ARG(st2->fullname));
            res = -1;
        }

        if (res >= 0 && check_parent_required_fields(&parents, ctx) < 0) {
            res = -1;
        }

        qv_clear(&parents);
    }

    if (flags & IOP_COMPAT_JSON) {
        const lstr_t *class_name = NULL;

        if (st1->class_attrs->parent) {
            class_name = &st1->class_attrs->parent->fullname;
        }
        st2_parent_json = get_parents_until_name(st2, class_name, &parents);
        if (class_name && !st2_parent_json
        &&  (!are_all_parents_empty(st1) || !are_all_parents_empty(st2)))
        {
            iop_compat_add_err(ctx, "cannot find class `%*pM` in the parents "
                               "of `%*pM`", LSTR_FMT_ARG(*class_name),
                               LSTR_FMT_ARG(st2->fullname));
            res = -1;
        }

        if (res >= 0 && check_parent_required_fields(&parents, ctx) < 0) {
            res = -1;
        }
    }

    /* Check upper level. */
    if ((st2_parent_bin || st2_parent_json)
    &&  st1->class_attrs->parent)
    {
        if (st2_parent_bin == st2_parent_json) {
            if (check_class_parent(st1, st2_parent_bin, flags, ctx) < 0) {
                res = -1;
            }
        } else {
            if (st2_parent_bin
            &&  check_class_parent(st1, st2_parent_bin,
                                   IOP_COMPAT_BIN, ctx) < 0)
            {
                res = -1;
            }

            if (st2_parent_json
            &&  check_class_parent(st1, st2_parent_json,
                                   IOP_COMPAT_JSON, ctx) < 0)
            {
                res = -1;
            }
        }
    }

    qv_wipe(&parents);
    return res;
}

bool _iop_struct_is_optional(const iop_struct_t *st, bool forbid_abstract,
                             bool check_parents, iop_compat_ctx_t *ctx)
{
    if (forbid_abstract && iop_struct_is_class(st)
    &&  st->class_attrs->is_abstract)
    {
        return false;
    }

    if (qh_find(cptr, &ctx->seen_opt_st, st) >= 0) {
        return true;
    }

    for (int i = 0; i < st->fields_len; i++) {
        const iop_field_t *f = &st->fields[i];

        if (f->repeat != IOP_R_REQUIRED || f->type == IOP_T_VOID) {
            continue;
        }
        if (f->type != IOP_T_STRUCT
        ||  !_iop_struct_is_optional(f->u1.st_desc, true, true, ctx))
        {
            return false;
        }
    }

    if (check_parents && iop_struct_is_class(st) && st->class_attrs->parent
    &&  !_iop_struct_is_optional(st->class_attrs->parent, false, true, ctx))
    {
        return false;
    }

    qh_add(cptr, &ctx->seen_opt_st, st);
    return true;
}

bool iop_struct_is_optional(const iop_struct_t *st, bool check_parents)
{
    iop_compat_ctx_t ctx;
    int ret;

    iop_compat_ctx_init(&ctx);
    ret = _iop_struct_is_optional(st, false, check_parents, &ctx);
    iop_compat_ctx_wipe(&ctx);
    return ret;
}

static int
__backward_compat_check_new_field(const iop_struct_t *st1,
                                  const iop_field_t *f1,
                                  const iop_field_t *f2,
                                  unsigned flags, iop_compat_ctx_t *ctx)
{
    if (f1) {
        int res = 0;
        SB(name_fmt, 128);

        if (!lstr_equal(f1->name, f2->name)) {
            sb_addf(&name_fmt, "`%*pM` -> `%*pM`", LSTR_FMT_ARG(f1->name),
                    LSTR_FMT_ARG(f2->name));
        } else
        if (f1->tag != f2->tag) {
            sb_addf(&name_fmt, "`%*pM` %hu -> %hu", LSTR_FMT_ARG(f2->name),
                    f1->tag, f2->tag);
        } else {
            sb_addf(&name_fmt, "`%*pM`", LSTR_FMT_ARG(f2->name));
        }

        iop_compat_push_err_ctx(ctx, "field %*pM:", SB_FMT_ARG(&name_fmt));

        if (iop_field_check_backward_compat(f1, f2, flags, ctx) < 0) {
            res = -1;
        }
        iop_compat_pop_err_ctx(ctx);
        return res;
    }

    if (f2->type == IOP_T_VOID) {
        return 0;
    }

    if (st1->is_union || f2->repeat != IOP_R_REQUIRED) {
        return 0;
    }

    if (f2->type == IOP_T_STRUCT
    &&  _iop_struct_is_optional(f2->u1.st_desc, true, true, ctx))
    {
        return 0;
    }

    iop_compat_add_err(ctx, "new field `%*pM` must not be required",
                       LSTR_FMT_ARG(f2->name));

    return -1;
}

static unsigned
iop_generic_compat_ignored(unsigned flags,
                           int (^get_gen_attr)(lstr_t, iop_value_t *))
{
    iop_value_t val;

    if (get_gen_attr(LSTR("compat:ignore"), &val) >= 0 && val.b) {
        return 0;
    }
    if (get_gen_attr(LSTR("compat:ignoreJson"), &val) >= 0 && val.b) {
        flags &= ~IOP_COMPAT_JSON;
    }
    if (get_gen_attr(LSTR("compat:ignoreBin"), &val) >= 0 && val.b) {
        flags &= ~IOP_COMPAT_BIN;
    }

    return flags;
}

static unsigned
iop_struct_compat_ignored(const iop_struct_t *new_st, unsigned flags)
{
    return iop_generic_compat_ignored(flags,
                                      ^int (lstr_t attr, iop_value_t *val) {
        return iop_struct_get_gen_attr(new_st, attr, IOP_T_BOOL, NULL, val);
    });
}

static unsigned iop_rpc_compat_ignored(const iop_iface_t *iface,
                                       const iop_rpc_t *rpc, unsigned flags)
{
    return iop_generic_compat_ignored(flags,
                                      ^int (lstr_t attr, iop_value_t *val) {
        return iop_rpc_get_gen_attr(iface, rpc, attr, IOP_T_BOOL, NULL, val);
    });
}

static unsigned
iop_iface_compat_ignored(const iop_iface_t *iface, unsigned flags)
{
    return iop_generic_compat_ignored(flags,
                                      ^int (lstr_t attr, iop_value_t *val) {
        return iop_iface_get_gen_attr(iface, attr, IOP_T_BOOL, NULL, val);
    });
}

static int
__iop_struct_check_backward_compat(const iop_struct_t *st1,
                                   const iop_struct_t *st2,
                                   unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    /* XXX: do not simply test st1 == st2 because it allows to easily write
     *      "compatible" z-tests. */

    if (!(flags = iop_compat_mark_couple(st1, st2, flags, ctx))) {
        /* No checks to be done. */
        return 0;
    }

    /* Check types of the objects. */
    if (st1->is_union && !st2->is_union) {
        iop_compat_add_err(ctx, "was a union and is now a %s",
                           iop_struct_is_class(st2) ? "class" : "struct");
        return -1;
    }
    if (!st1->is_union && st2->is_union) {
        iop_compat_add_err(ctx, "was a %s and is now a union",
                           iop_struct_is_class(st1) ? "class" : "struct");
        return -1;
    }

    if (iop_struct_is_class(st1) && !iop_struct_is_class(st2)) {
        iop_compat_add_err(ctx, "was a class and is now a struct");
        res = -1;
    }
    if (!iop_struct_is_class(st1) && iop_struct_is_class(st2)) {
        if (st2->class_attrs->is_abstract) {
            iop_compat_add_err(ctx,
                               "was a struct and is now an abstract class");
            res = -1;
        } else
        if (st2->class_attrs->parent) {
            /* TODO: this is theoretically possible for JSON, but the checks
             * on all the fields are missing and should be added here. */
            iop_compat_add_err(ctx, "was a struct and is now a child class");
            res = -1;
        }
    }

    if (iop_struct_is_class(st1) && iop_struct_is_class(st2)) {
        if (!st1->class_attrs->is_abstract && st2->class_attrs->is_abstract) {
            iop_compat_add_err(ctx,
                               "is an abstract class but was not abstract");
            res = -1;
        }
        if (flags & IOP_COMPAT_BIN
        &&  st1->class_attrs->class_id != st2->class_attrs->class_id)
        {
            iop_compat_add_err(ctx, "class id changed (%u != %u)",
                               st1->class_attrs->class_id,
                               st2->class_attrs->class_id);
            res = -1;
        }
        if (flags & IOP_COMPAT_JSON
        &&  !lstr_equal(st1->fullname, st2->fullname))
        {
            iop_compat_add_err(ctx,
                               "class fullname changed (`%*pM` != `%*pM`)",
                               LSTR_FMT_ARG(st1->fullname),
                               LSTR_FMT_ARG(st2->fullname));
            res = -1;
        }
    }

    /* Check fields of st2. */
    for (int i = 0; i < st2->fields_len; i++) {
        const iop_field_t *f2 = &st2->fields[i];
        const iop_field_t *f1_name;
        const iop_field_t *f1_tag = NULL;
        bool got_err = false;
        int pos;

        f1_name = __iop_field_find_by_name(st1, f2->name);
        pos = iop_ranges_search(st1->ranges, st1->ranges_len, f2->tag);
        if (pos >= 0) {
            f1_tag = &st1->fields[pos];
        }

#define CHECK_NEW_FIELD(f1, flags)                                           \
        do {                                                                 \
            if (__backward_compat_check_new_field(st1, f1, f2, flags,        \
                                                  ctx) < 0)                  \
            {                                                                \
                got_err = true;                                              \
                res = -1;                                                    \
            }                                                                \
        } while (0)

        if (flags == IOP_COMPAT_JSON) {
            CHECK_NEW_FIELD(f1_name, IOP_COMPAT_JSON);
        } else
        if (flags == IOP_COMPAT_BIN) {
            CHECK_NEW_FIELD(f1_tag, IOP_COMPAT_BIN);
        } else {
            assert (flags == IOP_COMPAT_ALL);
            if (f1_name && f1_tag) {
                if (f1_name == f1_tag) {
                    CHECK_NEW_FIELD(f1_name, IOP_COMPAT_ALL);
                } else {
                    iop_compat_add_err(ctx,
                        "field `%*pM` (%d): name and tag lookups mismatch: "
                        "`%*pM` (%d) != `%*pM` (%d)",
                        LSTR_FMT_ARG(f2->name), f2->tag,
                        LSTR_FMT_ARG(f1_name->name), f1_name->tag,
                        LSTR_FMT_ARG(f1_tag->name), f1_tag->tag);
                    res = -1;
                }
            } else {
                CHECK_NEW_FIELD(f1_name, IOP_COMPAT_JSON);
                if (!got_err) {
                    CHECK_NEW_FIELD(f1_tag, IOP_COMPAT_BIN);
                }
            }
        }
    }
#undef CHECK_NEW_FIELD

    /* Check that no field disappeared for json backward compat and union
     * case. */
    if (st1->is_union || flags & IOP_COMPAT_JSON) {
        for (int i = 0; i < st1->fields_len; i++) {
            const iop_field_t *f1 = &st1->fields[i];

            if (flags & IOP_COMPAT_JSON
            &&  !__iop_field_find_by_name(st2, f1->name))
            {
                iop_compat_add_err(ctx,
                                   "field `%*pM` does not exist anymore",
                                   LSTR_FMT_ARG(f1->name));
                res = -1;
            } else
            if (flags & IOP_COMPAT_BIN
            &&  iop_ranges_search(st2->ranges, st2->ranges_len, f1->tag) < 0)
            {
                iop_compat_add_err(ctx, "field with tag %d (`%*pM`) does "
                                   "not exist anymore", f1->tag,
                                   LSTR_FMT_ARG(f1->name));
                res = -1;
            }
        }
    }

    /* Specific class checks. */
    if (iop_struct_is_class(st1) && iop_struct_is_class(st2)
    &&  check_parent_classes(st1, st2, flags, ctx) < 0)
    {
            res = -1;
    }

    return res;
}

int iop_struct_check_backward_compat(const iop_struct_t *st1,
                                     const iop_struct_t *st2,
                                     unsigned flags, sb_t *err)
{
    int res;
    iop_compat_ctx_t ctx;

    assert (flags & IOP_COMPAT_BIN || flags & IOP_COMPAT_JSON);

    flags = iop_struct_compat_ignored(st2, flags);
    if (!flags) {
        return 0;
    }

    iop_compat_ctx_init(&ctx);
    ctx.err = err;

    res = __iop_struct_check_backward_compat(st1, st2, flags, &ctx);

    iop_compat_ctx_wipe(&ctx);
    return res;
}

static int
__iop_rpc_check_backward_compat(const iop_rpc_t *rpc1,
                                const iop_rpc_t *rpc2,
                                unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

#define CHECK_RPC(_what)  \
    do {                                                                     \
        iop_compat_push_err_ctx(ctx, "RPC `%*pM` " TOSTR(_what) ":",         \
                                LSTR_FMT_ARG(rpc1->name));                   \
        if (__iop_struct_check_backward_compat(rpc1->_what, rpc2->_what,     \
                                               flags, ctx) < 0)              \
        {                                                                    \
            res = -1;                                                        \
        }                                                                    \
        iop_compat_pop_err_ctx(ctx);                                         \
    } while (0)

    CHECK_RPC(args);

    if (rpc1->async && !rpc2->async) {
        iop_compat_add_err(ctx, "RPC `%*pM` was async and is not anymore",
                           LSTR_FMT_ARG(rpc1->name));
        return -1;
    }
    if (!rpc1->async && rpc2->async) {
        iop_compat_add_err(ctx, "RPC `%*pM` is async but was not before",
                           LSTR_FMT_ARG(rpc1->name));
        return -1;
    }

    CHECK_RPC(result);
    CHECK_RPC(exn);
#undef CHECK_RPC

    return res;
}

static const iop_rpc_t *
__iop_iface_get_rpc_by_name(const iop_iface_t *iface, lstr_t name)
{
    for (int i = 0; i < iface->funs_len; i++) {
        if (lstr_equal(iface->funs[i].name, name)) {
            return &iface->funs[i];
        }
    }

    return NULL;
}

static int
__iop_iface_check_backward_compat(const iop_iface_t *if1,
                                  const iop_iface_t *if2,
                                  unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    /* XXX: do not simply test if1 == if2 because it allows to easily write
     *      "compatible" z-tests. */

    /* Skip SNMP interfaces: they do not have the same backward compatibility
     * rules as the standard interfaces, and it would be quite useless for us.
     */
    if (TST_BIT(&if1->flags, IOP_IFACE_IS_SNMP_IFACE)
    &&  TST_BIT(&if2->flags, IOP_IFACE_IS_SNMP_IFACE))
    {
        return 0;
    }

    for (int i = 0; i < if1->funs_len; i++) {
        const iop_rpc_t *fun1 = &if1->funs[i];
        const iop_rpc_t *fun2;

        if (flags & IOP_COMPAT_JSON) {
            if ((fun2 = __iop_iface_get_rpc_by_name(if2, fun1->name))) {
                unsigned rpc_flags;

                if ((rpc_flags = iop_rpc_compat_ignored(if2, fun2, flags))
                &&  __iop_rpc_check_backward_compat(fun1, fun2,
                                                    rpc_flags, ctx) < 0)
                {
                    res = -1;
                    continue;
                }
            } else {
                iop_compat_add_err(ctx, "RPC `%*pM` does not exist anymore",
                                   LSTR_FMT_ARG(fun1->name));
                res = -1;
                continue;
            }
        }

        if (flags & IOP_COMPAT_BIN) {
            if ((fun2 = iop_iface_find_rpc(if2, fun1->tag))) {
                unsigned rpc_flags;

                if ((rpc_flags = iop_rpc_compat_ignored(if2, fun2, flags))
                &&  __iop_rpc_check_backward_compat(fun1, fun2,
                                                    rpc_flags, ctx) < 0)
                {
                    res = -1;
                }
            } else {
                iop_compat_add_err(ctx, "RPC with tag %d (`%*pM`) does not "
                                   "exist anymore",
                                   fun1->tag, LSTR_FMT_ARG(fun1->name));
                res = -1;
            }
        }
    }

    return res;
}

static const iop_iface_alias_t *
__iop_mod_get_iface_by_name(const iop_mod_t *mod, lstr_t name)
{
    for (int i = 0; i < mod->ifaces_len; i++) {
        if (lstr_equal(mod->ifaces[i].name, name)) {
            return &mod->ifaces[i];
        }
    }

    return NULL;
}

static int
__iop_mod_check_backward_compat(const iop_mod_t *mod1,
                                const iop_mod_t *mod2,
                                unsigned flags, iop_compat_ctx_t *ctx)
{
    int res = 0;

    /* XXX: do not simply test mod1 == mod2 because it allows to easily write
     *      "compatible" z-tests. */

    /* We just perform naive tests here (we check that the interfaces are not
     * renamed or re-tagged without checking their compatibility). The
     * interfaces themselves are tested before anyway.
     */
    for (int i = 0; i < mod1->ifaces_len; i++) {
        const iop_iface_alias_t *if1 = &mod1->ifaces[i];

        if (flags & IOP_COMPAT_JSON) {
            if (!__iop_mod_get_iface_by_name(mod2, if1->name)) {
                iop_compat_add_err(ctx, "interface `%*pM` does not exist "
                                   "anymore", LSTR_FMT_ARG(if1->name));
                res = -1;
            }
        }

        if (flags & IOP_COMPAT_BIN) {
            if (!iop_mod_find_iface(mod2, if1->tag)) {
                iop_compat_add_err(ctx, "interface with tag %d (`%*pM`) does "
                                   "not exist anymore",
                                   if1->tag, LSTR_FMT_ARG(if1->name));
                res = -1;
            }
        }
    }

    return res;
}

static lstr_t iop_get_name_from_fullname(lstr_t fullname)
{
    pstream_t ps = ps_initlstr(&fullname);
    pstream_t elem;

    while (ps_get_ps_chr_and_skip(&ps, '.', &elem) >= 0);

    return LSTR_PS_V(&ps);
}

#define BUILD_GET_BY_NAME(_fun, _type, _vec)                                 \
const _type *_fun(const iop_pkg_t *pkg, lstr_t name)                         \
{                                                                            \
    for (const _type *const *it = pkg->_vec; *it; it++) {                    \
        const _type *obj = *it;                                              \
                                                                             \
        if (lstr_equal(iop_get_name_from_fullname(obj->fullname), name)) {   \
            return obj;                                                      \
        }                                                                    \
    }                                                                        \
    return NULL;                                                             \
}

BUILD_GET_BY_NAME(iop_pkg_get_struct_by_name, iop_struct_t, structs)
static BUILD_GET_BY_NAME(iop_pkg_get_iface_by_name,  iop_iface_t,  ifaces)
static BUILD_GET_BY_NAME(iop_pkg_get_mod_by_name,    iop_mod_t,    mods)

#undef BUILD_GET_BY_NAME

int iop_pkg_check_backward_compat_ctx(const iop_pkg_t *pkg1,
                                      const iop_pkg_t *pkg2,
                                      iop_compat_ctx_t *ctx,
                                      unsigned flags, sb_t *err)
{
    int res = 0;

    assert (flags & IOP_COMPAT_BIN || flags & IOP_COMPAT_JSON);

    ctx->err = err;

    iop_compat_push_err_ctx(ctx, "pkg `%*pM`:", LSTR_FMT_ARG(pkg2->name));

    /* Check structs. */
    for (const iop_struct_t *const *it = pkg1->structs; *it; it++) {
        const iop_struct_t *st1 = *it;
        const iop_struct_t *st2;
        lstr_t name = iop_get_name_from_fullname(st1->fullname);
        const char *what;
        unsigned st_flags;

        if (st1->is_union) {
            what = "union";
        } else
        if (iop_struct_is_class(st1)) {
            what = "class";
        } else {
            what = "struct";
        }

        if (!(st2 = iop_pkg_get_struct_by_name(pkg2, name))) {
            iop_compat_add_err(ctx, "%s `%*pM` does not exist anymore",
                               what, LSTR_FMT_ARG(st1->fullname));
            res = -1;
            continue;
        }

        iop_compat_push_err_ctx(ctx, "%s `%*pM`:",
                                what, LSTR_FMT_ARG(st1->fullname));
        if ((st_flags = iop_struct_compat_ignored(st2, flags))
        &&  __iop_struct_check_backward_compat(st1, st2, st_flags, ctx) < 0)
        {
            res = -1;
        }
        iop_compat_pop_err_ctx(ctx);
    }

    /* Check interfaces. */
    for (const iop_iface_t *const *it = pkg1->ifaces; *it; it++) {
        const iop_iface_t *if1 = *it;
        const iop_iface_t *if2;
        lstr_t name = iop_get_name_from_fullname(if1->fullname);
        unsigned if_flags;

        if (!(if2 = iop_pkg_get_iface_by_name(pkg2, name))) {
            iop_compat_add_err(ctx,
                               "interface `%*pM` does not exist anymore",
                               LSTR_FMT_ARG(if1->fullname));
            res = -1;
            continue;
        }

        iop_compat_push_err_ctx(ctx, "interface `%*pM`:",
                                LSTR_FMT_ARG(if1->fullname));
        if ((if_flags = iop_iface_compat_ignored(if2, flags))
        &&  __iop_iface_check_backward_compat(if1, if2, if_flags, ctx) < 0)
        {
            res = -1;
        }
        iop_compat_pop_err_ctx(ctx);
    }

    /* Check modules. */
    for (const iop_mod_t *const *it = pkg1->mods; *it; it++) {
        const iop_mod_t *mod1 = *it;
        const iop_mod_t *mod2;
        lstr_t name = iop_get_name_from_fullname(mod1->fullname);

        if (!(mod2 = iop_pkg_get_mod_by_name(pkg2, name))) {
            iop_compat_add_err(ctx, "module `%*pM` does not exist anymore",
                               LSTR_FMT_ARG(mod1->fullname));
            res = -1;
            continue;
        }

        iop_compat_push_err_ctx(ctx, "module `%*pM`:",
                                LSTR_FMT_ARG(mod1->fullname));
        if (__iop_mod_check_backward_compat(mod1, mod2, flags, ctx) < 0) {
            res = -1;
        }
        iop_compat_pop_err_ctx(ctx);
    }

    iop_compat_pop_err_ctx(ctx);

    return res;
}

int iop_pkg_check_backward_compat(const iop_pkg_t *pkg1,
                                  const iop_pkg_t *pkg2,
                                  unsigned flags, sb_t *err)
{
    int res;
    iop_compat_ctx_t ctx;

    iop_compat_ctx_init(&ctx);

    res = iop_pkg_check_backward_compat_ctx(pkg1, pkg2, &ctx, flags, err);

    iop_compat_ctx_wipe(&ctx);

    return res;
}

/* }}} */

static int iop_initialize(void *arg)
{
    iop_env_init(&_G.env);
    iprintf_register_formatter('E', &iop_enum_formatter);
    iprintf_register_formatter('U', &iop_union_type_formatter);
    iop_dso_initialize();
    return 0;
}

static int iop_shutdown(void)
{
    iop_dso_shutdown();
    iop_env_wipe(&_G.env);
    return 0;
}

module_t *iop_module_g;

_MODULE_ADD_DECLS(iop);

void iop_module_register(void)
{
    if (!iop_module_g) {
        iop_module_g = module_implement(MODULE(iop), &iop_initialize,
                                        &iop_shutdown, NULL);
    }
}
