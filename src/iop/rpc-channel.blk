/***************************************************************************/
/*                                                                         */
/* Copyright 2022 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include <lib-common/log.h>
#include <lib-common/unix.h>
#include <lib-common/iop-rpc.h>
#include <lib-common/str-buf-pp.h>
#include <lib-common/iop.h>
#include <lib-common/ssl.h>

#include "rpc-channel.fc.c"

/* IC_MSG_STREAM_CONTROL messages uses the "slot" to encode the command.
 */
enum ic_msg_sc_slots {
    IC_SC_BYE = 1,
    IC_SC_NOP,
    IC_SC_VERSION,
};

qm_k32_t(ic, ichannel_t *);
qm_k64_t(ic_hook_ctx, ic_hook_ctx_t *);

static struct {
    qm_t(ic)    ics;
    qm_t(ic_hook_ctx) hook_ctxs;

    qv_t(lstr) traced_names;
    qh_t(u32)  traced_cmds;

    SSL_CTX *ssl_ctx;
    X509 *certificate;

    /* Hook flow */
    ic_hook_ctx_t   *ic_hook_ctx;
    ic_post_hook_f  *post_hook;
    const iop_rpc_t *rpc;
    data_t           post_args;

    /* Loggers */
    logger_t logger;
    logger_t tracing_logger;

    bool tls_disabled;
} ic_g = {
#define _G  ic_g
    .logger = LOGGER_INIT_INHERITS(NULL, "ic"),
    .tracing_logger = LOGGER_INIT_SILENT_INHERITS(&_G.logger, "tracing")
};

const QM(ic_cbs, ic_no_impl);

/*----- messages stuff -----*/

/* Tracing {{{ */

#define ic_msg_trace(msg, fmt, ...)  do {                                    \
        const ic_msg_t *__tr_msg = (msg);                                    \
                                                                             \
        if (unlikely(__tr_msg->trace)) {                                     \
            logger_notice(&_G.tracing_logger, "[msg:%p/slot:%x] "fmt,        \
                          __tr_msg, __tr_msg->slot, ##__VA_ARGS__);          \
        }                                                                    \
    } while (0)

#define ic_slot_is_traced(slot, flags)  \
    (((slot) | (flags)) & IC_MSG_IS_TRACED)

#define ic_slot_trace(slot, flags, fmt, ...)  do {                           \
        if (unlikely(ic_slot_is_traced(slot, flags))) {                      \
            logger_notice(&_G.tracing_logger, "[slot:%x] "fmt,               \
                          (uint32_t)(slot & IC_MSG_SLOT_MASK),               \
                          ##__VA_ARGS__);                                    \
        }                                                                    \
    } while (0)

static void ic_read_tracing(void)
{
#ifndef NDEBUG
    /* IC_TRACE environment variable contains a list of interface or
     * interface.rpc to trace.
     */
    const char *trace = getenv("IC_TRACE");
    pstream_t ps;

    if (!trace) {
        return;
    }

    ps = ps_initstr(trace);
    ps_ltrim(&ps);

    while (!ps_done(&ps)) {
        pstream_t n;

        ps_ltrim(&ps);
        if (ps_get_ps_chr(&ps, ' ', &n) < 0) {
            n = ps;
            ps = ps_init(NULL, 0);
        }

        qv_append(&_G.traced_names, LSTR_PS_V(&n));
    }
#endif
}

#ifndef NDEBUG
bool __ic_rpc_is_traced(const iop_iface_t *iface, const iop_rpc_t *rpc)
{
    t_scope;
    lstr_t rpc_name = t_lstr_fmt("%*pM.%*pM", LSTR_FMT_ARG(iface->fullname),
                                 LSTR_FMT_ARG(rpc->name));

    tab_for_each_entry(name, &_G.traced_names) {
        if (lstr_equal(rpc_name, name)
        ||  lstr_equal(iface->fullname, name))
        {
            return true;
        }
    }

    return false;
}

/* This function can return false positives, because several RPCs can have the
 * same cmd... */
static _Bool ic_cmd_is_traced(int cmd)
{
    static bool first_call = true;

    if (unlikely(first_call)) {
        /* XXX: The filling of _G.traced_cmds is done lazily because when
         * ic_initialize is called, the IOP packages were likely not
         * registered yet. */
        iop_for_each_registered_pkgs(^void (const iop_pkg_t *pkg) {
            for (const iop_mod_t *const *m = pkg->mods; *m; m++) {
                const iop_mod_t *mod = *m;

                for (int ia = 0; ia < mod->ifaces_len; ia++) {
                    const iop_iface_alias_t *iface_alias = mod->ifaces + ia;
                    const iop_iface_t *iface = iface_alias->iface;

                    for (int i = 0; i < iface->funs_len; i++) {
                        const iop_rpc_t *rpc = &iface->funs[i];

                        if (__ic_rpc_is_traced(iface, rpc)) {
                            uint32_t rcmd = iface_alias->tag << 16 | rpc->tag;

                            qh_add(u32, &_G.traced_cmds, rcmd);
                        }
                    }
                }
            }
        });
        first_call = false;
    }

    return qh_find(u32, &_G.traced_cmds, cmd & 0x7fff7fff) >= 0;
}
#endif

/* }}} */
/* {{{ State dumper */

static lstr_t ev_priority_to_str(ev_priority_t prio)
{
    switch (prio) {
      case EV_PRIORITY_LOW:    return LSTR("low");
      case EV_PRIORITY_NORMAL: return LSTR("normal");
      case EV_PRIORITY_HIGH:   return LSTR("high");
    }
    assert (false);
    return LSTR_NULL_V;
}

static void ic_get_state(sb_t *buf)
{
    t_scope;
    qv_t(table_hdr) hdr;
    qv_t(table_data) rows;
    table_hdr_t hdr_data[] = { {
            .title = LSTR_IMMED("ICHANNEL"),
        }, {
            .title = LSTR_IMMED("NAME"),
        }, {
            .title = LSTR_IMMED("ELH"),
        }, {
            .title = LSTR_IMMED("CALLBACK"),
        }, {
            .title = LSTR_IMMED("KIND"),
        }, {
            .title = LSTR_IMMED("ADDRESS"),
        }, {
            .title = LSTR_IMMED("FLAGS"),
        }, {
            .title = LSTR_IMMED("PRIORITY"),
        }, {
            .title = LSTR_IMMED("NEXT SLOT"),
        }, {
            .title = LSTR_IMMED("PENDING QUERIES"),
        }, {
            .title = LSTR_IMMED("NB IOV"),
        }, {
            .title = LSTR_IMMED("IOV TOTAL LEN"),
        }
    };
    uint32_t hdr_size = countof(hdr_data);

    qv_init_static(&hdr, hdr_data, hdr_size);
    t_qv_init(&rows, 200);

    qm_for_each_pos(ic, pos, &_G.ics) {
        t_SB(flags, 64);
        ichannel_t *ic = _G.ics.values[pos];
        qv_t(lstr) *tab = qv_growlen(&rows, 1);
        lstr_t addr;

        t_qv_init(tab, hdr_size);

        qv_append(tab, t_lstr_fmt("%d / %p", ic->id, ic));
        qv_append(tab, ic->name);
        qv_append(tab, t_lstr_fmt("%p", ic->elh));
        qv_append(tab, t_lstr_fmt("%p", ic->on_event));

        if (ic->is_local) {
            qv_append(tab, LSTR("local"));
        } else
        if (ic->is_spawned) {
            qv_append(tab, LSTR("server"));
        } else {
            qv_append(tab, LSTR("client"));
        }

        if (ic->is_local) {
            addr = LSTR("-");
        } else
        if (ic->is_spawned) {
            addr = ic_get_client_addr(ic);
            addr = t_lstr_fmt("peer: %*pM", LSTR_FMT_ARG(addr));
        } else {
            addr = t_addr_fmt_lstr(&ic->su);
        }
        if (ic->remote_addr.s) {
            addr = t_lstr_fmt("%*pM (%*pM)", LSTR_FMT_ARG(addr),
                              LSTR_FMT_ARG(ic->remote_addr));
        }
        qv_append(tab, addr);

#define ADD_FLAG(_field, _str)                                               \
        do {                                                                 \
            if (ic->_field) {                                                \
                if (flags.len) {                                             \
                    sb_adds(&flags, ", ");                                   \
                }                                                            \
                sb_adds(&flags, _str);                                       \
            }                                                                \
        } while (0)

        ADD_FLAG(is_trusted,   "trusted");
        ADD_FLAG(is_closing,   "closing");
        ADD_FLAG(no_autodel,   "no autodel");
        ADD_FLAG(is_seqpacket, "seqpacket");
        ADD_FLAG(is_unix,      "unix");
        ADD_FLAG(auto_reconn,  "auto reconn");
        ADD_FLAG(do_el_unref,  "do el_unref");
        ADD_FLAG(cancel_guard, "cancel guard");
        ADD_FLAG(queuable,     "queuable");
        ADD_FLAG(is_wiped,     "wiped");
        assert (!ic->is_wiped);

        qv_append(tab, LSTR_SB_V(&flags));
#undef ADD_FLAG

        qv_append(tab, ev_priority_to_str(ic->priority));
        qv_append(tab, t_lstr_fmt("%u", ic->nextslot));
        qv_append(tab, t_lstr_fmt("%d", ic_queue_len(ic)));
        qv_append(tab, t_lstr_fmt("%d", ic->iov.len));
        qv_append(tab, t_lstr_fmt("%d", ic->iov_total_len));
    }

    sb_add_table(buf, &hdr, &rows);
    sb_shrink(buf, 1);
}

static void ic_print_state(void)
{
    SB_1k(buf);

    ic_get_state(&buf);
    logger_notice(&_G.logger, "ichannels summary:\n%*pM", SB_FMT_ARG(&buf));
}

/* }}} */
/* {{{ init/shutdown */

/** Check the peer certificate is the Intersec's one.
 *
 * IC peers should all have the same certificate. This function is called
 * whenever a peer sends its certificate to check if its certificate is the
 * same than ours.
 *
 * OpenSSL server:
 *   - with SSL_VERIFY_PEER, will ask the client to give a certificate.
 *   - with SSL_VERIFY_FAIL_IF_NO_PEER_CERT, will reject the client if it does
 *     not provide a certificate.
 *
 * These two options, together with this callback, should ensure that the
 * client and the server authenticate each other. However, because we're a bit
 * paranoïd, we double check that they actually have received the expected
 * certificate (see the call to SSL_get_peer_certificate in ic_tls_handshake).
 */
static int ic_verify_callback(int preverify_ok, X509_STORE_CTX *store_ctx)
{
    X509 *cert;

    if (preverify_ok) {
        /* OpenSSL considers the server OK. (It happens this function is
         * called two times successively, the second time with preverify_ok
         * being 1. In both case the comparison below seems ok. */
        return preverify_ok;
    }

    cert = X509_STORE_CTX_get_current_cert(store_ctx);
    return (cert && X509_cmp(cert, _G.certificate) == 0) ? 1 : preverify_ok;
}

SSL_CTX *ic_get_ssl_ctx(void)
{
    return _G.ssl_ctx;
}

X509 *ic_get_certificate(void)
{
    return _G.certificate;
}

static int ic_initialize(void *arg)
{
    t_scope;
    lstr_t tls_key = t_farch_get_data(ic_fc_g, "ic-key.pem");
    lstr_t tls_cert = t_farch_get_data(ic_fc_g, "ic-cert.pem");
    SB_1k(errbuf);

    _G.certificate = ssl_ctx_convert_certificate_lstr(tls_cert);
    if (!_G.certificate) {
        logger_fatal(&_G.logger, "cannot load IC TLS certificate");
    }

    /* Configure a default TLS context with the IC TLS key. */
    _G.ssl_ctx = ssl_ctx_new_tls(TLS_method(), tls_key, tls_cert,
                            SSL_VERIFY_PEER | SSL_VERIFY_FAIL_IF_NO_PEER_CERT,
                            &ic_verify_callback, &errbuf);
    if (!_G.ssl_ctx) {
        logger_fatal(&_G.logger, "cannot initialize IC TLS context: %*pM",
                     SB_FMT_ARG(&errbuf));
    }

    /* Other module initialization. */
    qm_init(ic, &_G.ics);
    qm_init(ic_hook_ctx, &_G.hook_ctxs);
    qv_init(&_G.traced_names);
    qh_init(u32, &_G.traced_cmds);
    ic_read_tracing();
    return 0;
}

static int ic_shutdown(void)
{
    if (qm_len(ic, &_G.ics)) {
        if (logger_is_traced(&_G.logger, 1)) {
            SB_1k(buf);

            ic_get_state(&buf);
            logger_trace(&_G.logger, 1, "%d ichannels are leaked:\n%*pM",
                         qm_len(ic, &_G.ics), SB_FMT_ARG(&buf));
        } else {
            logger_trace(&_G.logger, 0, "%d ichannels are leaked",
                         qm_len(ic, &_G.ics));
        }
    }

    if (_G.ic_hook_ctx) {
        ic_hook_ctx_t *ctx = _G.ic_hook_ctx;

        ic_hook_ctx_delete(&ctx);
    }

    qv_deep_wipe(&_G.traced_names, lstr_wipe);
    qh_wipe(u32, &_G.traced_cmds);
    qm_deep_wipe(ic_hook_ctx, &_G.hook_ctxs, IGNORE, ic_hook_ctx_delete);
    qm_wipe(ic, &_G.ics);
    SSL_CTX_free(_G.ssl_ctx);
    X509_free(_G.certificate);
    _G.certificate = NULL;
    return 0;
}

MODULE_BEGIN(ic)
    MODULE_DEPENDS_ON(el);
    MODULE_DEPENDS_ON(ssl);
    MODULE_IMPLEMENTS_VOID(print_state, &ic_print_state);
MODULE_END()

/* }}}*/

ic_msg_t *ic_msg_new_fd(int fd, int len)
{
    ic_msg_t *msg;

    assert (len >= 0);
    msg = p_new_extra(ic_msg_t, len);
    msg->fd = fd;
    msg = ic_msg_set_priority(msg, EV_PRIORITY_NORMAL);

    return msg;
}

ic_msg_t *ic_msg_new(int len)
{
    return ic_msg_new_fd(-1, len);
}

static void ic_blk_cb(ichannel_t *ic, ic_msg_t *msg, ic_status_t status,
                      void *res, void *exn)
{
    ic_msg_cb_b blk = *(ic_msg_cb_b *)msg->priv;

    blk(ic, status, res, exn);
    Block_release(blk);
}

ic_msg_t *ic_msg_new_blk(ic_msg_cb_b blk)
{
    ic_msg_t *msg = ic_msg_new(sizeof(blk));

    *(ic_msg_cb_b *)msg->priv = Block_copy(blk);
    msg->cb = &ic_blk_cb;
    return msg;
}

ic_msg_t *ic_msg_set_timeout(ic_msg_t *msg, uint32_t timeout)
{
    msg->timeout = timeout;

    return msg;
}

ic_msg_t *ic_msg_set_priority(ic_msg_t *msg, ev_priority_t priority)
{
    msg->priority = priority;
    return msg;
}

ic_msg_t *ic_msg_proxy_new(int fd, uint64_t slot, const ic__hdr__t *hdr)
{
    ic_msg_t *msg = p_new_extra(ic_msg_t, sizeof(slot));

    put_unaligned_le64(&msg->priv, slot);
    msg->fd  = fd;
    msg->hdr = hdr;

    /* XXX The +/- 1 is because of backward compatibility:
     * 0 means EV_PRIORITY_NORMAL on the wire. */
    msg->priority = ((slot & IC_MSG_PRIORITY_MASK)
                     >> IC_MSG_PRIORITY_SHIFT) + 1;
    return msg;
}

void ic_msg_delete(ic_msg_t **msgp)
{
    ic_msg_t *msg = *msgp;
    if (unlikely(!msg)) {
        return;
    }

    ic_msg_trace(msg, "delete message");
    if (msg->fd >= 0) {
        close(msg->fd);
    }
    if (msg->dlen) {
        assert (msg->dlen >= IC_MSG_HDR_LEN);
        p_delete(&msg->data);
    }

    el_unregister(&msg->timeout_timer);
    p_delete(msgp);
}

static void
ic_msg_init_for_reply(ichannel_t *ic, ic_msg_t *msg, uint64_t slot, int cmd)
{
#ifdef IC_DEBUG_REPLIES
    int32_t pos = qh_del_key(ic_replies, &ic->dbg_replies, slot);
    if (pos < 0) {
        logger_panic(&_G.logger,
                     "answering to slot %d twice or unexpected answer!",
                     (uint32_t)slot);
    }
#endif
    assert (ic->pending > 0);
    ic->pending--;
    msg->slot = slot & IC_MSG_SLOT_MASK;
    msg->trace = !!(slot & IC_MSG_IS_TRACED);

    /* XXX The +/- 1 is because of backward compatibility:
     * 0 means EV_PRIORITY_NORMAL on the wire. */
    msg->priority = ((slot & IC_MSG_PRIORITY_MASK)
                     >> IC_MSG_PRIORITY_SHIFT) + 1;

    msg->cmd  = -cmd;
}

static void ic_hook_ctx_save_current(void)
{
    if (_G.ic_hook_ctx) {
        IGNORE(expect(qm_add(ic_hook_ctx, &_G.hook_ctxs, _G.ic_hook_ctx->slot,
                      _G.ic_hook_ctx) >= 0));
        _G.ic_hook_ctx = NULL;
    }
}

ic_hook_ctx_t *ic_hook_ctx_new(uint64_t slot, ssize_t extra)
{
    if (_G.ic_hook_ctx) {
        assert (_G.ic_hook_ctx->slot != slot);
        ic_hook_ctx_save_current();
    }
    _G.ic_hook_ctx = p_new_extra_field(ic_hook_ctx_t, data, extra);
    _G.ic_hook_ctx->slot = slot;
    _G.ic_hook_ctx->rpc = _G.rpc;
    _G.ic_hook_ctx->post_hook = _G.post_hook;
    _G.ic_hook_ctx->post_hook_args = _G.post_args;

    return _G.ic_hook_ctx;
}

ic_hook_ctx_t *ic_hook_ctx_get(uint64_t slot)
{
    if (_G.ic_hook_ctx &&  _G.ic_hook_ctx->slot == slot) {
        return _G.ic_hook_ctx;
    } else {
        return qm_get_def(ic_hook_ctx, &_G.hook_ctxs, slot, NULL);
    }
}

void ic_hook_ctx_delete(ic_hook_ctx_t **pctx)
{
    if (*pctx) {
        ic_hook_ctx_t *ctx = *pctx;

        if (ctx == _G.ic_hook_ctx) {
            _G.ic_hook_ctx = NULL;
        } else {
            qm_del_key(ic_hook_ctx, &_G.hook_ctxs, ctx->slot);
        }
    }
    p_delete(pctx);
}

int
ic_query_do_pre_hook(ichannel_t *ic, uint64_t slot, const ic_cb_entry_t *e,
                     ic__hdr__t *hdr, bool *hdr_modified)
{
    if (e->pre_hook) {
        _G.post_hook = e->post_hook;
        _G.rpc = e->rpc;
        _G.post_args = e->post_hook_args;
        if (_G.ic_hook_ctx) {
            assert (_G.ic_hook_ctx->slot != slot);
            /* XXX Make sure "_G.ic_hook_ctx" is null or we won't be
             * able to detect errors in pre_hook.
             */
            ic_hook_ctx_save_current();
        }
        (*e->pre_hook)(ic, slot, hdr, e->pre_hook_args, hdr_modified);
        /* XXX: if we reply to the query during pre_hook then
         * _G.ic_hook_ctx will be NULL, and we mustn't call the implementation
         * of the RPC
         * TODO: it would be better to rely on a pre_hook return code than on
         * _G.ic_hook_ctx
         */
        if (!_G.ic_hook_ctx) {
            return -1;
        }
    }

    return 0;
}

void ic_query_do_post_hook(ichannel_t *ic, ic_status_t status, uint64_t slot,
                           const iop_struct_t *st, const void *value)
{
    ic_hook_ctx_t *ctx = ic_hook_ctx_get(slot);

    if (!ctx) {
        return;
    }
    if (ctx->post_hook) {
        (*ctx->post_hook)(ic, status, ctx, ctx->post_hook_args, st, value);
    }
    ic_hook_ctx_delete(&ctx);

    return;
}

static inline bool ic_can_reply(const ichannel_t *ic, uint64_t slot) {
    return likely(ic->elh || ic_is_local(ic)) && likely(ic->id == slot >> 32);
}

static void ic_watch_act_soft(el_t ev, data_t priv);

static void ic_reply_err2(ichannel_t *ic, uint64_t slot, int err,
                          const lstr_t *err_str);
static ichannel_t *ic_get_from_slot(uint64_t slot);
static void ic_queue(ichannel_t *ic, ic_msg_t *msg, uint32_t flags);
static void ic_queue_for_reply(ichannel_t *ic, ic_msg_t *msg);
static void ic_proxify(ichannel_t *pxy_ic, ic_msg_t *msg, int cmd,
                       const void *data, int dlen,
                       const ic_msg_t *unpacked_msg)
{
    uint64_t slot = get_unaligned_le64(msg->priv);
    ichannel_t *ic;

    cmd = -cmd;

    if (unlikely(ic_slot_is_http(slot))) {
        __ichttp_proxify(slot, cmd, data, dlen);
        return;
    }
    ic = ic_get_from_slot(slot);
    if (unlikely(!ic)) {
        return;
    }
    if (likely(ic_can_reply(ic, slot))) {
        ic_msg_t *tmp = ic_msg_new_fd(pxy_ic ? ic_get_fd(pxy_ic) : -1, 0);

        ic_query_do_post_hook(ic, cmd, slot, NULL, NULL);
        ic_msg_init_for_reply(ic, tmp, slot, cmd);
        if (unpacked_msg && (likely(cmd == IC_MSG_OK) || cmd == IC_MSG_EXN)) {
            const iop_struct_t *st;

            assert (msg->rpc);
            st = likely(cmd == IC_MSG_OK) ? msg->rpc->result : msg->rpc->exn;
            tmp->force_dup = msg->force_dup;
            __ic_msg_build(tmp, st, unpacked_msg->data, !ic_is_local(ic));
        } else {
            void *buf;

            assert (!unpacked_msg || dlen == 0 || cmd == IC_MSG_INVALID);

            if (ic_is_local(ic)) {
                tmp->force_pack = !unpacked_msg;
            }

            buf = __ic_get_buf(tmp, dlen);
            if (data) {
                memcpy(buf, data, dlen);
            } else {
                assert (dlen == 0);
            }
        }
        ic_queue_for_reply(ic, tmp);
    }
}

void __ic_msg_reply_err(ichannel_t *ic, ic_msg_t *msg, ic_status_t status)
{
    if (msg->canceled) {
        return;
    }

    if (msg->cb == IC_PROXY_MAGIC_CB) {
        ic_proxify(ic, msg, -status, NULL, 0, NULL);
    } else {
        (*msg->cb)(ic, msg, status, NULL, NULL);
    }
}

void __ic_forward_reply_to(ichannel_t *pxy_ic, uint64_t slot, int cmd,
                           const void *res, const void *exn)
{
    ichannel_t *ic;

    if (!pxy_ic) {
        logger_panic(&_G.logger,
                     "are you trying to forward a webservices answer?");
    }

    if (unlikely(ic_slot_is_http(slot))) {
        __ichttp_forward_reply(pxy_ic, slot, cmd, res, exn);
        return;
    }

    if (cmd != IC_MSG_OK && cmd != IC_MSG_EXN) {
        assert (!res);
        ic_reply_err2(NULL, slot, cmd, exn);
        return;
    }

    if (unlikely(!(ic = ic_get_from_slot(slot)))) {
        return;
    }
    if (likely(ic_can_reply(ic, slot))) {
        ic_msg_t *tmp = ic_msg_new_fd(ic_get_fd(pxy_ic), 0);
        const sb_t *buf = &pxy_ic->rbuf;
        const void *data = buf->data + IC_MSG_HDR_LEN;
        int dlen = get_unaligned_le32(buf->data + IC_MSG_DLEN_OFFSET);

        ic_query_do_post_hook(ic, cmd, slot, NULL, NULL);
        ic_msg_init_for_reply(ic, tmp, slot, cmd);
        if (ic_is_local(pxy_ic) && !get_unaligned_le32(buf->data)) {
            const ic_msg_t *msg_org = data;
            const iop_struct_t *st;

            assert (dlen == sizeof(ic_msg_t) && msg_org->rpc);

            if (likely(cmd == IC_MSG_OK)) {
                st = msg_org->rpc->result;
                data = res;
            } else {
                st = msg_org->rpc->exn;
                data = exn;
            }
            tmp->force_dup = msg_org->force_dup;
            __ic_msg_build(tmp, st, data, !ic_is_local(ic));
        } else {
            if (ic_is_local(ic)) {
                tmp->force_pack = true;
            }

            memcpy(__ic_get_buf(tmp, dlen), data, dlen);
        }
        ic_queue_for_reply(ic, tmp);
    }
}

static void ic_add_msg_tail(ichannel_t *ic, ic_msg_t *msg)
{
    htlist_add_tail(&ic->msg_list, &msg->msg_link);
    if (msg->priority == EV_PRIORITY_NORMAL) {
        ic->last_normal_prio_msg = ic->msg_list.head;
    }
}

static ic_msg_t *ic_pop_msg(ichannel_t *ic)
{
    ic_msg_t *msg = htlist_pop_entry(&ic->msg_list, ic_msg_t, msg_link);

    if (&msg->msg_link == ic->last_normal_prio_msg) {
        ic->last_normal_prio_msg = NULL;
    }
    return msg;
}

static void ic_cancel_all(ichannel_t *ic)
{
    ic_msg_t *msg;
    qm_t(ic_msg) h;

#ifndef NDEBUG
    ic->cancel_guard = true;
#endif

    while (!htlist_is_empty(&ic->iov_list)) {
        msg = htlist_pop_entry(&ic->iov_list, ic_msg_t, msg_link);
        if (msg->cmd <= 0 || msg->slot == 0) {
            ic_msg_delete(&msg);
        }
    }
    while (!htlist_is_empty(&ic->msg_list)) {
        msg = ic_pop_msg(ic);
        if (msg->cmd <= 0 || msg->slot == 0) {
            ic_msg_delete(&msg);
        }
    }

    while (!htlist_is_empty(&ic->local_async_queries)) {
        msg = htlist_pop_entry(&ic->local_async_queries, ic_msg_t, msg_link);
        __ic_msg_reply_err(ic, msg, IC_MSG_ABORT);
        if (msg->cmd <= 0 || msg->slot == 0) {
            ic_msg_delete(&msg);
        }
    }
    while (!htlist_is_empty(&ic->local_async_replies)) {
        msg = htlist_pop_entry(&ic->local_async_replies, ic_msg_t, msg_link);
        ic_msg_delete(&msg);
    }

    ic->last_normal_prio_msg = NULL;

    h = ic->queries;
    qm_init(ic_msg, &ic->queries);
    qm_for_each_pos(ic_msg, pos, &h) {
        qm_del_at(ic_msg, &h, pos);

        msg = h.values[pos];
        __ic_msg_reply_err(ic, msg, IC_MSG_ABORT);
        ic_msg_delete(&msg);
    }
    qm_wipe(ic_msg, &h);
    qv_deep_clear(&ic->fds, p_close);

    /* if that crashes, one of the IC_MSG_ABORT callback reenqueues directly in
     * that ichannel_t which is forbidden, fix the code
     */
    assert (qm_len(ic_msg, &ic->queries) == 0);

#ifndef NDEBUG
    ic->cancel_guard = false;
#endif
}

static void ic_choose_id(ichannel_t *ic)
{
    static uint32_t nextid = 0;
    do {
        if (unlikely(nextid == IC_ID_MAX)) {
            nextid = 0;
        }
    } while (unlikely(qm_add(ic, &_G.ics, ++nextid, ic) < 0));
    ic->id = nextid;
}

static void ic_drop_id(ichannel_t *ic)
{
    qm_del_key(ic, &_G.ics, ic->id);
    ic->id = 0;
}


/*----- binary protocol handling -----*/

static ic_msg_t *ic_query_take(ichannel_t *ic, uint32_t slot)
{
    int32_t pos = qm_del_key(ic_msg, &ic->queries, slot);

    if (pos < 0) {
        return NULL;
    } else {
        ic_msg_t *msg = ic->queries.values[pos];

        if (!msg->canceled) {
            ic->queue_len--;
        }
        return msg;
    }
}

static void ic_msg_take_and_delete(ic_msg_t *msg)
{
    if (msg->slot) {
        __unused__ ic_msg_t *tmp = ic_query_take(msg->ic, msg->slot);
        assert (tmp == msg);
    }
    ic_msg_delete(&msg);
}

static void ic_msg_abort(ichannel_t *ic, ic_msg_t *msg)
{
    if (msg->slot) {
        __unused__ ic_msg_t *tmp = ic_query_take(msg->ic, msg->slot);
        assert (tmp == msg);

        __ic_msg_reply_err(msg->ic, msg, IC_MSG_ABORT);
    }
    ic_msg_delete(&msg);
}

static void ic_msg_filter_on_bye(ichannel_t *ic)
{
    htlist_t l;

    htlist_move(&l, &ic->msg_list);
    ic->last_normal_prio_msg = NULL;

    while (!htlist_is_empty(&l)) {
        ic_msg_t *msg = htlist_pop_entry(&l, ic_msg_t, msg_link);

        if (msg->cmd > 0) {
            ic_msg_abort(ic, msg);
        } else {
            ic_add_msg_tail(ic, msg);
        }
    }
}

static int ic_write(ichannel_t *ic, int fd)
{
#define IC_MAX_FD  32
    char buf[CMSG_SPACE(sizeof(int[IC_MAX_FD]))]
        __attribute__((aligned(alignof(struct cmsghdr))));
    bool timer_restarted = false;

    /* TODO Reestablish
    assert (ic->is_connected);
    */

    do {
        struct cmsghdr *hdr = (struct cmsghdr *)buf;
        int *fdv = (int *)CMSG_DATA(hdr);
        int fdc = 0;
        struct msghdr msgh = { .msg_name = NULL };
        ssize_t res;
        ic_msg_t *msg;
        ic_msg_t *last_fd_msg = NULL;

        while (!htlist_is_empty(&ic->msg_list) && ic->iov_total_len < IC_PKT_MAX) {
            msg = ic_pop_msg(ic);

            if (msg->canceled) {
                ic_msg_take_and_delete(msg);
                continue;
            }

            if (unlikely(fdc == IC_MAX_FD && msg->fd >= 0)) {
                htlist_add(&ic->msg_list, &msg->msg_link);
                break;
            }

            ic_msg_trace(msg, "putting %d bytes in out vector", msg->dlen);
            htlist_add_tail(&ic->iov_list, &msg->msg_link);

            if (ic->is_seqpacket && ic->iov_total_len + msg->dlen > IC_PKT_MAX)
            {
                size_t to_send = IC_PKT_MAX - ic->iov_total_len;
                size_t remain = msg->dlen;

                while (remain) {
                    qv_append(&ic->iov,
                              MAKE_IOVEC((char *)msg->data + msg->dlen - remain,
                                         to_send));
                    remain -= to_send;
                    to_send = MIN(IC_PKT_MAX, remain);
                }
            } else {
                qv_append(&ic->iov, MAKE_IOVEC(msg->data, msg->dlen));
            }
            ic->iov_total_len += msg->dlen;

            if (msg->fd >= 0) {
                fdv[fdc++] = msg->fd;
                last_fd_msg = msg;
            }
        }

        if (!ic->iov_total_len) {
            break;
        }

        if (fdc > 0) {
            assert (ic->is_unix);
            hdr->cmsg_len = (char *)(fdv + fdc) - buf;
            hdr->cmsg_level = SOL_SOCKET;
            hdr->cmsg_type = SCM_RIGHTS;
            msgh.msg_control = hdr;
            msgh.msg_controllen = hdr->cmsg_len;
        } else {
            msgh.msg_control = NULL;
            msgh.msg_controllen = 0;
        }
        msgh.msg_iov = ic->iov.tab;
        msgh.msg_iovlen = ic->iov.len;
        if (ic->is_seqpacket && ic->iov_total_len > IC_PKT_MAX) {
            size_t total = ic->iov_total_len;

            while (total > IC_PKT_MAX) {
                msgh.msg_iovlen--;
                total -= msgh.msg_iov[msgh.msg_iovlen].iov_len;
            }
        }
        msgh.msg_iovlen = MIN(msgh.msg_iovlen, IOV_MAX);

        /* We can use ssl_writev because the msg control header is only used
         * with unix sockets (fdc > 0). */
        res = ic->ssl ?
            ssl_writev(fd, msgh.msg_iov, msgh.msg_iovlen, ic->ssl) :
            sendmsg(fd, &msgh, 0);

        if (res < 0) {
            return ERR_RW_RETRIABLE(errno) ? 0 : -1;
        }
        if (ic->timer && !timer_restarted) {
            el_timer_restart(ic->timer, 0);
            timer_restarted = true;
        }
        iovec_vector_kill_first(&ic->iov, res);
        ic->iov_total_len -= res;

        while (!htlist_is_empty(&ic->iov_list)) {
            msg = htlist_first_entry(&ic->iov_list, ic_msg_t, msg_link);

            if (msg->fd >= 0) {
                close(msg->fd);
                msg->fd = -1;
                ic_msg_trace(msg, "fd sent");

                if (msg == last_fd_msg) {
                    last_fd_msg = NULL;
                }
            }

            if (ic->iov.len != 0) {
                const struct iovec *iov = &ic->iov.tab[0];
                const char *msg_end = (char *)msg->data + msg->dlen;
                const char *iov_end = (char *)iov->iov_base + iov->iov_len;

                if (iov_end >= (const char *)msg->data && iov_end <= msg_end)
                {
                    /* The message is not fully sent */
                    break;
                }
            }

            htlist_pop(&ic->iov_list);
            ic_msg_trace(msg, "written on socket");
            if (msg->cmd <= 0 || msg->slot == 0) {
                ic_msg_delete(&msg);
            }
        }

        if (last_fd_msg) {
            htlist_for_each_entry(msg, &ic->iov_list, msg_link) {
                if (msg->fd >= 0) {
                    close(msg->fd);
                    msg->fd = -1;
                    ic_msg_trace(msg, "fd sent");

                    if (msg == last_fd_msg) {
                        break;
                    }
                }
            }
        }

        assert (htlist_is_empty(&ic->iov_list) || ic->iov_total_len);
    } while (ic->iov_total_len || !htlist_is_empty(&ic->msg_list));

    if (ic->elh) {
        el_fd_set_mask(ic->elh, POLLIN);
    }
    return 1;
}

static void ic_parse_cmsg(ichannel_t *ic, struct msghdr *msgh)
{
    struct cmsghdr *cmsg;

    for (cmsg = CMSG_FIRSTHDR(msgh); cmsg; cmsg = CMSG_NXTHDR(msgh, cmsg)) {
        if (cmsg->cmsg_level != SOL_SOCKET) {
            continue;
        }
        switch (cmsg->cmsg_type) {
          case SCM_RIGHTS: {
            int fd_count = (cmsg->cmsg_len - sizeof(*cmsg)) / sizeof(int);
            int *fds = acast(int, CMSG_DATA(cmsg));

            p_copy(qv_growlen(&ic->fds, fd_count), fds, fd_count);
          } break;
        }
    }
}

static int
t_get_value_of_st(const iop_struct_t *, const ic_msg_t *unpacked_msg,
                  pstream_t, unsigned flags, void **value);

static ALWAYS_INLINE int
ic_read_process_answer(ichannel_t *ic, int cmd, uint32_t slot,
                       const void *data, int dlen,
                       const ic_msg_t *unpacked_msg)
{
    ic_msg_t *tmp = ic_query_take(ic, slot);
    const iop_struct_t *st;

    if (unlikely(!tmp)) {
        errno = 0;
        return -1;
    }

    ic_msg_trace(tmp, "processing answer");

    if (tmp->canceled) {
        goto wipe;
    }

    if (ic_is_local(ic)) {
        sb_reset(&ic->rbuf);
        sb_addnc(&ic->rbuf, IC_MSG_HDR_LEN, 0);
        put_unaligned_le32(ic->rbuf.data + IC_MSG_CMD_OFFSET, cmd);
        if (data) {
            put_unaligned_le32(ic->rbuf.data, slot);
            put_unaligned_le32(ic->rbuf.data + IC_MSG_DLEN_OFFSET, dlen);
            sb_add(&ic->rbuf, data, dlen);
        } else
        if (unpacked_msg) {
            put_unaligned_le32(ic->rbuf.data + IC_MSG_DLEN_OFFSET,
                                sizeof(ic_msg_t));
            sb_add(&ic->rbuf, unpacked_msg, sizeof(ic_msg_t));
            ((ic_msg_t *)(ic->rbuf.data + IC_MSG_HDR_LEN))->rpc = tmp->rpc;
        }
    }

    tmp->raw_res = ps_init(data, dlen);
    if (tmp->cb == IC_PROXY_MAGIC_CB) {
        ic_proxify(ic, tmp, cmd, data, dlen, unpacked_msg);
        goto wipe;
    }

    cmd = -cmd;
    if (likely(cmd == IC_MSG_OK)) {
        st = tmp->rpc->result;
    } else
    if (cmd == IC_MSG_EXN) {
        st = tmp->rpc->exn;
    } else {
        assert (dlen == 0 || cmd == IC_MSG_INVALID);
        if (dlen > 0) {
            lstr_t err = LSTR_INIT_V(data, dlen - 1);
            iop_set_err2(&err);
            ic_msg_trace(tmp, "%s %*pM", ic_status_to_string(cmd),
                        LSTR_FMT_ARG(err));
            (*tmp->cb)(ic, tmp, cmd, NULL, &err);
        } else {
            iop_clear_err();
            ic_msg_trace(tmp, "%s", ic_status_to_string(cmd));
            (*tmp->cb)(ic, tmp, cmd, NULL, NULL);
        }
        goto wipe;
    }
    if (!tmp->raw) {
        t_scope;
        void *value = NULL;
        pstream_t ps = tmp->raw_res;
        unsigned unpack_flags = ic->is_public ? IOP_UNPACK_FORBID_PRIVATE : 0;

        if (unlikely(t_get_value_of_st(st, unpacked_msg, ps,
                                       unpack_flags, &value) < 0))
        {
            if (tmp->trace) {
                const char *err = iop_get_err();

                if (err) {
                    ic_msg_trace(tmp, "rpc(%04x:%04x):%*pM: %s",
                                 (tmp->cmd >> 16) & 0x7fff, tmp->cmd & 0x7fff,
                                 LSTR_FMT_ARG(tmp->rpc->name), err);
                } else {
                    ic_msg_trace(tmp, "rpc(%04x:%04x):%*pM: answer with "
                                 "invalid encoding",
                                 (tmp->cmd >> 16) & 0x7fff, tmp->cmd & 0x7fff,
                                 LSTR_FMT_ARG(tmp->rpc->name));
                }
            }
            t_seal();
            (*tmp->cb)(ic, tmp, IC_MSG_INVALID, NULL, NULL);
        } else
        if (cmd == IC_MSG_OK) {
            t_seal();
            ic_msg_trace(tmp, "OK");
            (*tmp->cb)(ic, tmp, cmd, value, NULL);
        } else {
            t_seal();
            ic_msg_trace(tmp, "%s", ic_status_to_string(cmd));
            (*tmp->cb)(ic, tmp, cmd, NULL, value);
        }
    } else {
        (*tmp->cb)(ic, tmp, cmd, NULL, NULL);
    }

  wipe:
    ic_msg_delete(&tmp);
    if (ic_is_local(ic)) {
        sb_reset(&ic->rbuf);
    }
    return 0;
}

lstr_t ic_get_client_addr(ichannel_t *ic)
{
    if (!ic->client_addr.s) {
        t_scope;
        socklen_t saddr_len = sizeof(ic->su.ss);

        if (getpeername(el_fd_get_fd(ic->elh), &ic->su.sa, &saddr_len) < 0) {
            logger_error(&_G.logger, "unable to get peer name: %m");
            ic->client_addr = LSTR_EMPTY_V;
        } else {
            ic->client_addr = lstr_dup(t_addr_fmt_lstr(&ic->su));
        }
    }
    return ic->client_addr.len ? lstr_dupc(ic->client_addr) : LSTR_NULL_V;
}

static inline void ic_update_pending(ichannel_t *ic, uint32_t slot)
{
    if (slot) {
        ic->pending++;
#ifndef NDEBUG
        /*
         * This code prints a warning when the amount of pending
         * request peaks more than 10% higher than before.
         *
         * If 10% is too low, feel free to make it higher, though keep
         * it low enough so that real bugs can be seen, even for
         * queries made only once per second.
         *
         */
        if (ic->pending >= ic->pending_max * 9 / 8) {
            logger_trace(&_G.logger, 0,
                         "warning: %p peaked at %d pending requests (cb %p)",
                         ic, ic->pending, ic->on_event);
            ic->pending_max = ic->pending;
        }
#endif
#ifdef IC_DEBUG_REPLIES
        qh_add(ic_replies, &ic->dbg_replies, MAKE64(ic->id, slot));
#endif
    }
}

static int
t_get_hdr_of_query(const ic_msg_t *unpacked_msg, pstream_t *ps,
                   unsigned flags, ic__hdr__t **hdr)
{
    if (unpacked_msg) {
        RETHROW(iop_check_constraints(ic__hdr, unpacked_msg->hdr));
        if (unpacked_msg->force_dup) {
            *hdr = t_iop_dup(ic__hdr, unpacked_msg->hdr);
        } else {
            *hdr = (ic__hdr__t *)unpacked_msg->hdr;
        }
    } else {
        *hdr = t_new_raw(ic__hdr__t, 1);
        RETHROW(iop_bunpack_multi_flags(t_pool(), &ic__hdr__s, *hdr, ps,
                                        flags));
    }
    return 0;
}

static int
t_get_value_of_st(const iop_struct_t *st, const ic_msg_t *unpacked_msg,
                  pstream_t ps, unsigned flags, void **value)
{
    if (unpacked_msg) {
        RETHROW(iop_check_constraints_desc(st, unpacked_msg->data));
        if (unpacked_msg->force_dup) {
            *value = mp_iop_dup_desc_sz(t_pool(), st, unpacked_msg->data,
                                        NULL);
        } else {
            *value = unpacked_msg->data;
        }
    } else {
        RETHROW(iop_bunpack_ptr_flags(t_pool(), st, value, ps, flags));
    }
    return 0;
}

static int
t_get_hdr_value_of_query(ichannel_t *ic, int cmd,
                         uint32_t slot, uint32_t flags,
                         const void *data, int dlen,
                         const ic_msg_t *unpacked_msg, const iop_struct_t *st,
                         int *packed_hdr_len, ic__hdr__t **hdr, void **value)
{
    pstream_t ps = ps_init(data, dlen);
    unsigned unpack_flags = ic->is_public ? IOP_UNPACK_IGNORE_UNKNOWN : 0;

#define QUERY_FMT  "query %04x:%04x, type %s: "
#define QUERY_FMT_ARG  \
    (cmd >> 16) & 0x7fff, cmd & 0x7fff, (st ? st->fullname.s : "<nil>")

    if (ic_is_local(ic) && !unpacked_msg) {
        /* IOP payload comes from a volatile ic_msg_t that will be destroy
         * with ic_reply(), thus we need to duplicate strings */
        unpack_flags |= IOP_UNPACK_COPY_STRINGS;
    }

    if (unlikely(flags & IC_MSG_HAS_HDR)) {
        if (unlikely(t_get_hdr_of_query(unpacked_msg, &ps,
                                        unpack_flags, hdr) < 0))
        {
            logger_warning(&_G.logger, QUERY_FMT "invalid header encoding",
                           QUERY_FMT_ARG);
            return -1;
        }
        /* XXX on simple header we write the payload size of the iop query */
        if (unlikely(IOP_UNION_IS(ic__hdr, *hdr, simple))) {
            ic__simple_hdr__t *shdr = &(*hdr)->simple;

            if (shdr->payload < 0) {
                shdr->payload = dlen;
            }

            if (!shdr->host.len) {
                shdr->host = ic_get_client_addr(ic);
            } else {
                sockunion_t out;
                pstream_t host;
                in_port_t port;

                if (addr_parse(ps_initlstr(&shdr->host), &host, &port, 0) < 0
                ||  addr_info(&out, AF_UNSPEC, host, port) < 0)
                {
                    shdr->host = LSTR_NULL_V;
                }
            }
        }
        if (unlikely(ic_slot_is_traced(slot, flags)
                  && logger_is_traced(&_G.tracing_logger, 2)))
        {
            SB_1k(sb);

            sb_addf(&sb, "[slot:%x]; unpacked header: ",
                    (uint32_t)(slot & IC_MSG_SLOT_MASK));
            iop_sb_jpack(&sb, &ic__hdr__s, *hdr, IOP_JPACK_SHORTEN_DATA);
            logger_trace(&_G.tracing_logger, 2, "%*pM", SB_FMT_ARG(&sb));
        }
    }

    if (packed_hdr_len) {
        *packed_hdr_len = dlen - ps_len(&ps);
    }

    if (value) {
        if (unlikely(t_get_value_of_st(st, unpacked_msg, ps,
                                       unpack_flags, value) < 0))
        {
            const char *err = iop_get_err();

            if (err) {
                /* Constraints violation */
                logger_trace(&_G.logger, 0, QUERY_FMT "%s",
                             QUERY_FMT_ARG, err);
            } else {
                logger_warning(&_G.logger, QUERY_FMT "invalid encoding",
                               QUERY_FMT_ARG);
            }
            return -1;
        }
        if (unlikely(ic_slot_is_traced(slot, flags)
                  && logger_is_traced(&_G.tracing_logger, 1)))
        {
            SB_1k(sb);

            sb_addf(&sb, "[slot:%x]; unpacked %*pM: ",
                    (uint32_t)(slot & IC_MSG_SLOT_MASK),
                    LSTR_FMT_ARG(st->fullname));
            iop_sb_jpack(&sb, st, *value, IOP_JPACK_SHORTEN_DATA);
            logger_trace(&_G.tracing_logger, 1, "%*pM", SB_FMT_ARG(&sb));
        }
    }

    return 0;
#undef QUERY_FMT
#undef QUERY_FMT_ARG
}

static void ic_report_unimplemented_rpc(int cmd)
{
    uint32_t icmd = cmd >> 16 & 0x7fff;
    uint32_t rcmd = cmd & 0x7fff;
    SB_1k(sb);
    __block sb_t *psb = &sb;

    iop_for_each_registered_pkgs(^(const iop_pkg_t *pkg) {
        for (const iop_mod_t *const *m = pkg->mods; *m; m++) {
            const iop_mod_t *mod = *m;

            for (int ia = 0; ia < mod->ifaces_len; ia++) {
                const iop_iface_alias_t *iface_alias = mod->ifaces + ia;
                const iop_iface_t *iface;

                if (iface_alias->tag != icmd) {
                    continue;
                }
                iface = iface_alias->iface;
                for (int i = 0; i < iface->funs_len; i++) {
                    const iop_rpc_t *rpc = &iface->funs[i];

                    if (rpc->tag != rcmd) {
                        continue;
                    }
                    if (psb->len) {
                        sb_adds(psb, ", ");
                    } else {
                        sb_adds(psb, " so potentially ");
                    }
                    sb_add_lstr(psb, mod->fullname);
                    sb_adds(psb, "::");
                    sb_add_lstr(psb, iface_alias->name);
                    sb_adds(psb, "::");
                    sb_add_lstr(psb, rpc->name);
                }
            }
        }
    });
    logger_trace(&_G.logger, 0, "received query for unimplemented RPC "
                 "(%04x:%04x%*pM)", icmd, rcmd, SB_FMT_ARG(&sb));
}

static int
t_get_details_of_query(ichannel_t *ic, int cmd, uint32_t slot,
                       uint32_t flags, const void *data, int dlen,
                       const ic_msg_t * nullable unpacked_msg,
                       const iop_struct_t * nonnull st,
                       const ic_cb_entry_t * nonnull e,
                       int * nonnull hlen,
                       ic__hdr__t * nullable * nonnull hdr,
                       void * nullable * nonnull value)
{
    switch (e->cb_type) {
      case IC_CB_NORMAL:
      case IC_CB_NORMAL_BLK:
      case IC_CB_WS_SHARED:
        return t_get_hdr_value_of_query(ic, cmd, slot, flags, data, dlen,
                                        unpacked_msg, st, NULL, hdr,
                                        value);

      case IC_CB_PROXY_P:
      case IC_CB_PROXY_PP:
        /* need the hdr for the pre hook */
        if (e->pre_hook) {
            return t_get_hdr_value_of_query(ic, cmd, slot, flags, data, dlen,
                                            unpacked_msg, st, hlen, hdr,
                                            NULL);
        }
        return 0;

      case IC_CB_DYNAMIC_PROXY:
        return t_get_hdr_value_of_query(ic, cmd, slot, flags, data, dlen,
                                        unpacked_msg, st, hlen, hdr, NULL);

      default:
        logger_panic(&_G.logger, "should not happen");
        return 0;
    }
}

/* Returns an error if the ic must be closed with ic_mark_disconnected. */
static ALWAYS_INLINE __must_check__ int
ic_read_process_query(ichannel_t *ic, int cmd, uint32_t slot,
                      uint32_t flags, const void *data, int dlen,
                      const ic_msg_t * nullable unpacked_msg)
{
    t_scope;
    const ic_cb_entry_t *e;
    const iop_struct_t *st;
    ic__hdr__t *hdr = NULL;
    int hlen = -1;
    ichannel_t *pxy;
    ic__hdr__t *pxy_hdr = NULL;
    bool take_pxy_hdr = false;
    bool hdr_modified = false;
    uint64_t query_slot;
    ic_msg_t *tmp;
    int pos;
    void *value = NULL;

    pos = likely(ic->impl) ? qm_find_safe(ic_cbs, ic->impl, cmd) : -1;
    if (unlikely(pos < 0)) {
        if (logger_is_traced(&_G.logger, 0)) {
            ic_report_unimplemented_rpc(cmd);
        }
        if (slot) {
            ic_reply_err(ic, MAKE64(ic->id, slot), IC_MSG_UNIMPLEMENTED);
        }
        return 0;
    }
    e = ic->impl->values + pos;
    st = e->rpc ? e->rpc->args : NULL;

#ifndef NDEBUG
    /* Flag as traced incoming queries that are not traced but should be in
     * our process. */
    if (!ic_slot_is_traced(slot, flags) && unlikely(ic_cmd_is_traced(cmd))) {
        flags |= IC_MSG_IS_TRACED;
    }
#endif
    query_slot = MAKE64(ic->id, slot | flags);
    ic_slot_trace(slot, flags, "received traced query");

    /* get details from the data of the msg. Each type of callback has
     * different details to retrieve. */
    if (t_get_details_of_query(ic, cmd, slot ,flags, data, dlen, unpacked_msg,
                               st, e, &hlen, &hdr, &value) < 0)
    {
         goto invalid_iop;
    }

    if (e->pre_hook) {
        t_seal();
        ic->cmd = cmd;
        if (ic_query_do_pre_hook(ic, query_slot, e, hdr, &hdr_modified) < 0) {
            ic->cmd = 0;
            return 0;
        }
        ic->cmd = 0;
        t_unseal();
    }

    switch (e->cb_type) {
      case IC_CB_NORMAL:
      case IC_CB_NORMAL_BLK:
      case IC_CB_WS_SHARED: {
        bool is_async = e->rpc->async;

        t_seal();
        ic->desc = e->rpc;
        ic->cmd  = cmd;
        assert (value);
        if (e->cb_type == IC_CB_NORMAL_BLK) {
            (e->u.blk.cb)(ic, query_slot, value, hdr);
        } else {
            (*e->u.cb.cb)(ic, query_slot, value, hdr);
        }
        if (is_async) {
            ic_query_do_post_hook(ic, cmd, query_slot, NULL, NULL);
        }
        ic->desc = NULL;
        ic->cmd  = 0;
        return 0;
      }

      case IC_CB_PROXY_P:
        pxy     = e->u.proxy_p.ic_p;
        pxy_hdr = e->u.proxy_p.hdr_p;
        break;
      case IC_CB_PROXY_PP:
        pxy     = *e->u.proxy_pp.ic_pp;
        if (e->u.proxy_pp.hdr_pp) {
            pxy_hdr = *e->u.proxy_pp.hdr_pp;
        }
        break;
      case IC_CB_DYNAMIC_PROXY:
        {
            ic_dynproxy_t dynproxy;

            /* XXX dynproxy are allowed to return memory allocated on the
             * t_pool() and thus mustn't be wrapped in a local t_scope */
            dynproxy = (*e->u.dynproxy.get_ic)(hdr, e->u.dynproxy.priv);
            pxy      = dynproxy.ic;
            pxy_hdr  = dynproxy.hdr;
            /* check for header replacement forcing */
            if (pxy_hdr && hdr) {
                take_pxy_hdr = true;
            }
        }
        break;
      default:
        logger_panic(&_G.logger, "should not happen");
        break;
    }

    if (unlikely(!pxy || !ic_is_ready(pxy))) {
        if (slot) {
            ic_reply_err(ic, query_slot, IC_MSG_PROXY_ERROR);
        }
        return 0;
    }

    /* do post hook for proxied async RPCs */
    if (e->pre_hook && !slot) {
        t_seal();
        ic->cmd = cmd;
        ic_query_do_post_hook(ic, cmd, query_slot, NULL, NULL);
        ic->cmd = 0;
        t_unseal();
    }

    /* if the hdr has been modified, we have to force a repacking, to
     * ensure that the new hdr is properly saved in the proxied msg */
    if (hdr_modified && expect(hdr)) {
        /* if take_pxy_hdr is set, we have to use pxy_hdr instead of hdr, but
         * the pxy_hdr has been built using the modified hdr, so it can be
         * kept. */
        pxy_hdr = take_pxy_hdr ? pxy_hdr : hdr;
        take_pxy_hdr = true;
    }

    take_pxy_hdr |= !(flags & IC_MSG_HAS_HDR) && pxy_hdr;
    tmp = ic_msg_proxy_new(ic_get_fd(ic), slot, NULL);
    if (slot) {
        tmp->cb = IC_PROXY_MAGIC_CB;
    } else {
        tmp->async = true;
    }
    tmp->cmd = cmd;
    put_unaligned_le64(tmp->priv, query_slot);

    /* XXX We do not support header replacement with static proxyfication.
     */

    if (unpacked_msg) {
        tmp->hdr = take_pxy_hdr ? pxy_hdr : unpacked_msg->hdr;
        if (ic_is_local(pxy)) {
            tmp->force_dup = unpacked_msg->force_dup;
            tmp->rpc = unpacked_msg->rpc;
        }
        __ic_msg_build(tmp, st, unpacked_msg->data, !ic_is_local(pxy));
    } else {
        if (ic_is_local(pxy)) {
            tmp->force_pack = true;
        }

        if (take_pxy_hdr) {
            qv_t(i32) szs;
            uint8_t *buf;

            /* skip the original hdr inside the data */
            if (hlen < 0) {
                assert (!(flags & IC_MSG_HAS_HDR));
                hlen = 0;
            }
            data = (const char *)data + hlen;
            dlen -= hlen;

            /* Pack the given header in proxyfied request */
            qv_inita(&szs, 128);
            hlen = iop_bpack_size(&ic__hdr__s, pxy_hdr, &szs);
            buf = __ic_get_buf(tmp, hlen + dlen);
            iop_bpack(buf, &ic__hdr__s, pxy_hdr, szs.tab);
            qv_wipe(&szs);
            memcpy(buf + hlen, data, dlen);
        } else {
            memcpy(__ic_get_buf(tmp, dlen), data, dlen);
        }
    }

    if (take_pxy_hdr) {
        flags |= IC_MSG_HAS_HDR;
    }
    __ic_query_flags(pxy, tmp, flags);
    return 0;

  invalid_iop:
    if (slot) {
        lstr_t err_str = iop_get_err_lstr();
        ic_reply_err2(ic, query_slot, IC_MSG_INVALID, &err_str);
    }

    /* Close connection unless we just had a constraint violation */
    THROW_ERR_UNLESS(iop_get_err());
    return 0;
}

static int ic_check_msg_hdr_flags(const ichannel_t *ic, uint32_t slot,
                                  int flags)
{
    if (!ic->is_unix && (flags & IC_MSG_HAS_FD)) {
        ic_slot_trace(slot, flags, "invalid flags HAS_FD on stream ic %p",
                      ic);
        assert (!ic->is_trusted);
        return -1;
    }
    if (flags & ~(IC_MSG_HAS_FD | IC_MSG_HAS_HDR | IC_MSG_IS_TRACED
                  | IC_MSG_PRIORITY_MASK))
    {
        ic_slot_trace(slot, flags, "unexpected flags value %x on ic %p",
                      flags, ic);
        assert (!ic->is_trusted);
        return -1;
    }
    return 0;
}

static int ic_check_msg_hdr(ichannel_t *ic)
{
    const byte *hdr;
    uint32_t slot;
    uint32_t flags;
    int cmd;
    int dlen;

    if (ic->hdr_checked) {
        return 0;
    }

    hdr = (const byte *)ic->rbuf.data;
    slot = get_unaligned_le32(hdr);
    flags = slot & ~IC_MSG_SLOT_MASK;
    slot &= IC_MSG_SLOT_MASK;
    cmd = get_unaligned_le32(hdr + IC_MSG_CMD_OFFSET);
    dlen = get_unaligned_le32(hdr + IC_MSG_DLEN_OFFSET);

    if (dlen < 0 || (uint32_t)dlen > MEM_ALLOC_MAX) {
        /* length is invalid */
        goto reject;
    }

    RETHROW(ic_check_msg_hdr_flags(ic, slot, flags));

    if (cmd == IC_MSG_STREAM_CONTROL) {
        switch (slot) {
          case IC_SC_BYE:
          case IC_SC_NOP:
            if (ic->peer_version <= IC_VERSION && dlen != 0) {
                goto reject;
            }
            break;
          case IC_SC_VERSION:
            if (ic->peer_version <= 0) {
                goto reject;
            }
            if (ic->peer_version <= IC_VERSION && dlen != 4) {
                goto reject;
            }
            if (dlen < 4) {
                goto reject;
            }
            break;
          default:
            if (ic->peer_version <= IC_VERSION) {
                goto reject;
            }
        }
    } else
    if (cmd <= 0) {
        switch (-cmd) {
          case IC_MSG_OK:
          case IC_MSG_EXN:
          case IC_MSG_INVALID:
            break;

          case IC_MSG_RETRY:
          case IC_MSG_ABORT:
          case IC_MSG_UNIMPLEMENTED:
          case IC_MSG_SERVER_ERROR:
          case IC_MSG_PROXY_ERROR:
            /* no data are expected with those reply codes */
            if (ic->peer_version <= IC_VERSION && dlen != 0) {
                goto reject;
            }
            break;

          default:
            /* unkown reply code */
            if (ic->peer_version <= IC_VERSION) {
                goto reject;
            }
        }
        if (dlen < 10 << 20) {
            /* don't lose time validating small messages, the correct checks
             * will be performed when treating the message. */
            goto accept;
        }
        /* reject messages that reply to unkown slot. */
        RETHROW(qm_find_safe(ic_msg, &ic->queries, slot));
    } else {
        if (!ic->impl) {
            /* no implementation, so nothing to reply */
            goto reject;
        }
        if (dlen < 10 << 20) {
            /* don't lose time validating small messages, the correct checks
             * will be performed when treating the message. */
            goto accept;
        }
        if (!ic->is_trusted) {
            /* unimplemented command */
            RETHROW(qm_find_safe(ic_cbs, ic->impl, cmd));
        }
    }
  accept:
    ic->hdr_checked = true;
    return 0;

  reject:
    assert (!ic->is_trusted);
    return -1;
}

/* Return -1 on error, 0 on EAGAIN, the number of bytes read otherwise.  */
static ssize_t _ic_read(ichannel_t *ic, short events, int sock, int to_read)
{
    ssize_t res;
    sb_t *buf = &ic->rbuf;
    char cmsgbuf[BUFSIZ];
    struct iovec iov;
    struct msghdr msgh = {
        .msg_iov        = &iov,
        .msg_iovlen     = 1,
        .msg_control    = cmsgbuf,
        .msg_controllen = sizeof(cmsgbuf),
    };

    if (!ic->is_unix) {
        res = ic->ssl ?
            ssl_sb_read(buf, ic->ssl, to_read) :
            sb_read(buf, sock, to_read);
    } else {
        iov = (struct iovec){
                .iov_base = sb_grow(buf, to_read),
                .iov_len  = to_read,
        };
        res = recvmsg(sock, &msgh, 0);
    }

    if (res < 0) {
        /* XXX: Workaround linux < 2.6.24 bug: it returns -EAGAIN *
         * instead of 0 in the hangup case for SOCK_SEQPACKETS    */
        if ((events & POLLHUP) || !ERR_RW_RETRIABLE(errno)) {
            return -1;
        }
        return 0;
    }
    if (res == 0) {
        /* Graceful exit, errno was unchanged: give him a meaningful value. */
        errno = 0;
        return -1;
    }

    if (ic->wa_soft > 0) {
        if (!ic->wa_soft_timer) {
            ic->on_event(ic, IC_EVT_ACT);
            ic->wa_soft_timer = el_timer_register(ic->wa_soft, 0, 0,
                                                  ic_watch_act_soft, ic);
            el_unref(ic->wa_soft_timer);
        } else {
            el_timer_restart(ic->wa_soft_timer, 0);
        }
    }

    if (ic->is_unix) {
        __sb_fixlen(buf, buf->len + res);
        ic_parse_cmsg(ic, &msgh);

        /* XXX fd_overflow is set when the kernel decided that it cannot
         * transfer some ancillary data. In our case, this means we didn't
         * properly receive the expected file descriptor, probably because
         * there is no file descriptor available anymore on our side of
         * the channel.
         */
        ic->fd_overflow |= !!(msgh.msg_flags & MSG_CTRUNC);
    }

    return res;
}

static int ic_read(ichannel_t *ic, short events, int sock)
{
    sb_t *buf = &ic->rbuf;
    ssize_t seqpkt_at_least = IC_PKT_MAX;
    int to_read = IC_PKT_MAX;
    bool starves = false;
    int write_errno = 0;
    bool try_write = true;
    ssize_t res;

    if (likely(events & POLLIN)) {
        if (buf->len >= IC_MSG_HDR_LEN) {
            errno = 0;
            RETHROW(ic_check_msg_hdr(ic));
            to_read  = get_unaligned_le32(buf->data + IC_MSG_DLEN_OFFSET);
            to_read += IC_MSG_HDR_LEN;
            to_read -= buf->len;
        }

      again:
        to_read = MAX(to_read, IC_PKT_MAX);
        res = _ic_read(ic, events, sock, to_read);
        if (res <= 0) {
            return res;
        }
        if (!ic->is_unix) {
            starves = (sb_avail(buf) == 0);
        }
        if (ic->is_seqpacket) {
            seqpkt_at_least -= res;
        }
    }

    while (buf->len >= IC_MSG_HDR_LEN) {
        void *data = buf->data + IC_MSG_HDR_LEN;
        int slot, dlen, cmd;
        int flags;

        slot  = get_unaligned_le32(buf->data);
        flags = slot & ~IC_MSG_SLOT_MASK;
        slot &= IC_MSG_SLOT_MASK;
        cmd   = get_unaligned_le32(buf->data + IC_MSG_CMD_OFFSET);
        dlen  = get_unaligned_le32(buf->data + IC_MSG_DLEN_OFFSET);

        if (dlen < 0 || (uint32_t)dlen > MEM_ALLOC_MAX) {
            return -1;
        }
        if (IC_MSG_HDR_LEN + dlen > buf->len) {
            errno = 0;
            /* Early checks to drop malformed messages before trying
             * to read again. */
            RETHROW(ic_check_msg_hdr(ic));
            to_read = IC_MSG_HDR_LEN + dlen - buf->len;
            break;
        }

        starves = true;
        errno = 0;
        RETHROW(ic_check_msg_hdr_flags(ic, slot, flags));
        if (unlikely(flags & IC_MSG_HAS_FD)) {
            if (ic->fds.len < 1) {
                assert (ic->fd_overflow);
                return -1;
            } else {
                ic->current_fd = ic->fds.tab[0];
                qv_pop(&ic->fds);
            }
            if (unlikely(ic->current_fd < 0)) {
                logger_warning(&_G.logger, "file descriptor table overflow");
            }
            flags &= ~IC_MSG_HAS_FD;
        }

        if (unlikely(cmd == IC_MSG_STREAM_CONTROL)) {
            ic->is_closing |= slot == IC_SC_BYE;
        } else
        if (cmd <= 0) {
            RETHROW(ic_read_process_answer(ic, cmd, slot, data, dlen, NULL));
        } else {
            /* deal with queries */
            ic_update_pending(ic, slot);

            if (unlikely(ic->is_closing)) {
                if (slot) {
                    ic_reply_err(ic, MAKE64(ic->id, slot | flags),
                                 IC_MSG_RETRY);
                }
            } else {
                if (ic_read_process_query(ic, cmd, slot, flags, data, dlen,
                                          NULL) < 0)
                {
                    errno = 0;
                    return -1;
                }
            }
        }

        if (unlikely(ic->current_fd >= 0)) {
            close(ic->current_fd);
            ic->current_fd = -1;
        }

        if (unlikely(!ic->elh)) {
            assert (buf->len == 0);
            /* a problem occured and the ichannel has been closed */
            errno = 0;
            return -1;
        }
        sb_skip(buf, IC_MSG_HDR_LEN + dlen);
        ic->hdr_checked = false;

        if (try_write) {
            int ret = ic_write(ic, sock);

            if (ret <= 0) {
                /* Stop writing */
                try_write = false;
                if (ret < 0) {
                    /* XXX don't raise an error _now_ since we want to read
                     * a potential pending IC_BYE on the channel.
                     */
                    write_errno = errno ?: EINVAL;
                }
            }
        }
    }

    if (buf->len < IC_MSG_HDR_LEN) {
        to_read = IC_MSG_HDR_LEN;
    }

    if (ic->is_seqpacket && seqpkt_at_least > 0) {
        goto again;
    }
    if (!ic->is_seqpacket && !starves) {
        goto again;
    }
    if (write_errno) {
        errno = write_errno;
        return -1;
    }
    return 0;
}

static void ic_reconnect(el_t ev, data_t priv)
{
    ichannel_t *ic = priv.ptr;

    /* XXX: ic->timer can be either the watch_activity or the reconnection
     * timer. This code ensure the watch_activity timer is properly
     * unregistered and that it will not be leaked in the event-loop.
     */
    el_unregister(&ic->timer);
    if (ic_connect(ic) < 0) {
        ic->timer = el_timer_register(ic->retry_delay, 0, 0, ic_reconnect,
                                      ic);
        el_unref(ic->timer);
    }
}

void ic_disconnect(ichannel_t *ic)
{
    ic->queuable = false;
    ic->is_connected = false;

    if (ic->ssl) {
        SSL_free(ic->ssl);
        ic->ssl = NULL;
    }
    if (ic->elh) {
        el_unregister(&ic->elh);
        ic_cancel_all(ic);
#ifdef IC_DEBUG_REPLIES
        qh_wipe(ic_replies, &ic->dbg_replies);
        qh_init(ic_replies, &ic->dbg_replies);
#endif
        ic->on_event(ic, IC_EVT_DISCONNECTED);
    }
    el_unregister(&ic->timer);
    el_unregister(&ic->wa_soft_timer);
    ic_drop_id(ic);

    if (!ic->is_closing && ic->is_spawned && !ic->no_autodel) {
        ic_delete(&ic);
    } else {
        ic_choose_id(ic);
        qv_clear(&ic->iov);
        ic->is_closing = false;
        ic->fd_overflow = false;
        ic->iov_total_len = 0;
        sb_reset(&ic->rbuf);
    }
}

void ic_wipe(ichannel_t *ic)
{
    ic->is_closing = true;
    ic_disconnect(ic);
    ic_cancel_all(ic);

    if (ic->owner) {
        *ic->owner = NULL;
    }
    if (ic->on_wipe) {
        (*ic->on_wipe)(ic);
    }
    ic_drop_id(ic);
    qm_wipe(ic_msg, &ic->queries);
#ifdef IC_DEBUG_REPLIES
    qh_init(ic_replies, &ic->dbg_replies);
#endif
    qv_wipe(&ic->iov);
    sb_wipe(&ic->rbuf);
    qv_wipe(&ic->fds);
    p_close(&ic->current_fd);
    lstr_wipe(&ic->name);
    lstr_wipe(&ic->remote_addr);
    lstr_wipe(&ic->client_addr);
    ic->is_wiped   = true;
    el_unregister(&ic->local_async_el);
}

static int ic_event(el_t ev, int fd, short events, data_t priv)
{
    bool do_parse;
    ichannel_t *ic = priv.ptr;

    if (events == EL_EVENTS_NOACT) {
        goto close;
    }

    /* On unsecure connections, the `read` performed with the version
     * handshake may have capture data which must be parsed. */
    do_parse = unlikely(ic->rbuf.len >= IC_MSG_HDR_LEN && !ic->hdr_checked);
    if (((events & POLLIN) || do_parse) && ic_read(ic, events, fd) < 0) {
        if (errno) {
            logger_trace(&_G.logger, 1, "ic_read error: %m");
        }
        goto close;
    }
    if (unlikely(ic->is_closing)) {
        ic_msg_filter_on_bye(ic);
    }
    if (!ic->elh) {
        return 0;
    }
    if (ic_write(ic, fd) < 0) {
        if (errno) {
            logger_trace(&_G.logger, 1, "ic_write error: %m");
        }
        goto close;
    }
    if (ic->is_closing && ic_is_empty(ic)) {
        goto close;
    }
    return 0;

close:
    if (ic->is_spawned && !ic->no_autodel) {
        ic_delete(&ic);
    } else {
        ic_mark_disconnected(ic);
    }
    return 0;
}


/*----- queries and answers handling -----*/

static ichannel_t *ic_get_from_slot(uint64_t slot)
{
#ifndef NDEBUG
    if (!(slot >> 32)) {
        logger_panic(&_G.logger, "slot truncated at some point: "
                     "ic->id bits are missing");
    }
#endif
    return qm_get_def(ic, &_G.ics, slot >> 32, NULL);
}

void *__ic_get_buf(ic_msg_t *msg, int len)
{
    msg->data = p_new_raw(char, IC_MSG_HDR_LEN + len);
    msg->dlen = IC_MSG_HDR_LEN + len;
    return (char *)msg->data + IC_MSG_HDR_LEN;
}

static void ic_msg_update_flags(const ic_msg_t *msg, uint32_t *flags)
{
    if (msg->fd >= 0) {
        *flags |= IC_MSG_HAS_FD;
    }
    if (msg->hdr) {
        *flags |= IC_MSG_HAS_HDR;
    }
    if (msg->trace) {
        *flags |= IC_MSG_IS_TRACED;
    }

    /* XXX The +/- 1 is because of backward compatibility:
     * 0 means EV_PRIORITY_NORMAL on the wire. */
    *flags |= IC_MSG_PRIORITY_MASK
              & ((msg->priority - 1) << IC_MSG_PRIORITY_SHIFT);
}

static void ic_queue(ichannel_t *ic, ic_msg_t *msg, uint32_t flags)
{
    char *buffer = msg->data;

    assert (!ic->is_wiped);
    assert (msg->dlen >= IC_MSG_HDR_LEN && msg->data);

    flags |= msg->slot;
    ic_msg_update_flags(msg, &flags);
    put_unaligned_le32(buffer, flags);
    put_unaligned_le32(buffer + IC_MSG_CMD_OFFSET, msg->cmd);
    put_unaligned_le32(buffer + IC_MSG_DLEN_OFFSET,
                       msg->dlen - IC_MSG_HDR_LEN);
    if (htlist_is_empty(&ic->msg_list) && ic->elh) {
        el_fd_set_mask(ic->elh, POLLINOUT);
    }

    ic_msg_trace(msg, "queueing message on ic %p with cmd %x", ic, msg->cmd);

    if (htlist_is_empty(&ic->msg_list)
    ||  msg->priority <= htlist_last_entry(&ic->msg_list, ic_msg_t,
                                           msg_link)->priority)
    {
        htlist_add_tail(&ic->msg_list, &msg->msg_link);
    } else
    if (msg->priority > htlist_first_entry(&ic->msg_list, ic_msg_t,
                                           msg_link)->priority) {
        htlist_add(&ic->msg_list, &msg->msg_link);
    } else
    if (msg->priority == EV_PRIORITY_NORMAL && ic->last_normal_prio_msg) {
        htlist_add_after(&ic->msg_list, ic->last_normal_prio_msg,
                         &msg->msg_link);
    } else {
        ic_msg_t *curr;
        ic_msg_t *prev = NULL;

        htlist_for_each_entry(curr, &ic->msg_list, msg_link) {
            if (curr->priority != EV_PRIORITY_HIGH) {
                break;
            }
            prev = curr;
        }
        htlist_add_after(&ic->msg_list, &prev->msg_link,
                         &msg->msg_link);
    }

    if (msg->priority == EV_PRIORITY_NORMAL) {
        ic->last_normal_prio_msg = &msg->msg_link;
    }
}

static void __ic_flush(ichannel_t *ic, int fd)
{
    if (ic_write(ic, fd) < 0) {
        if (ic->is_spawned && !ic->no_autodel) {
            ic_delete(&ic);
        } else {
            ic_mark_disconnected(ic);
        }
    }
}

void ic_flush(ichannel_t *ic)
{
    int fd = el_fd_get_fd(ic->elh);

    if (ic_is_local(ic) /* TODO Reestablish: || !expect(ic->is_connected) */)
    {
        return;
    }

    fd_unset_features(fd, O_NONBLOCK);
    __ic_flush(ic, fd);
    fd_set_features(fd, O_NONBLOCK);
}

void ic_msg_cancel(ic_msg_t *msg)
{
    assert (!msg->canceled);
    if (expect(!msg->async)) {
        __ic_msg_reply_err(msg->ic, msg, IC_MSG_CANCELED);
    }
    msg->canceled = true;
    msg->ic->queue_len--;
}

static void ic_msg_on_timeout(el_t ev, el_data_t data)
{
    ic_msg_t *msg = data.ptr;
    ichannel_t *ic = msg->ic;
    htlist_t *queue = &ic->msg_list;

    if (!msg->async) {
        __ic_msg_reply_err(msg->ic, msg, IC_MSG_TIMEDOUT);
    }

    msg->timeout_timer = NULL;
    msg->canceled = true;
    msg->ic->queue_len--;

    while (!htlist_is_empty(queue)
    &&    (htlist_first_entry(queue, ic_msg_t, msg_link)->canceled))
    {
        ic_msg_take_and_delete(ic_pop_msg(ic));
    }
}

static void
ic_query_local_flags(ichannel_t *ic, ic_msg_t *msg, uint32_t flags)
{
    const void *data;
    int dlen;
    const ic_msg_t *unpacked_msg;
    bool async = msg->async;

    ic_msg_update_flags(msg, &flags);
    ic_update_pending(ic, msg->slot);
    assert (msg->force_pack == !!msg->dlen);
    if (msg->force_pack) {
        data = (char *)msg->data + IC_MSG_HDR_LEN;
        dlen = msg->dlen - IC_MSG_HDR_LEN;
        assert (dlen >= 0);
        unpacked_msg = NULL;
    } else {
        data = NULL;
        dlen = 0;
        unpacked_msg = msg;
    }
    if (ic_read_process_query(ic, msg->cmd, msg->slot, flags, data, dlen,
                              unpacked_msg) < 0)
    {
        logger_panic(&_G.logger, "invalid query for local ic");
    }
    /* XXX: we can't use the msg here because if async is false, msg will be
     * deleted when calling ic_reply.
     */
    if (async) {
        ic_msg_delete(&msg);
    }
}

static void ic_local_reply(ichannel_t *ic, ic_msg_t *msg);

static void
ic_local_async_flush(el_t el, data_t data)
{
    ichannel_t *ic = data.ptr;
    htlist_t replies;
    htlist_t queries;

    el_unregister(&ic->local_async_el);
    /* XXX: We do not iterate directly on ichannel queries and replies list.
     * The reason is to ensure that handling queries and replies could
     * trigger new queries which would then be handled synchronously.
     * Moving the current list of queries and replies to separate variables
     * ensure that those new queries will not be handled right away.
     */
    replies = ic->local_async_replies;
    htlist_init(&ic->local_async_replies);
    queries = ic->local_async_queries;
    htlist_init(&ic->local_async_queries);

    while (!htlist_is_empty(&replies)) {
        ic_msg_t *msg;

        msg = htlist_pop_entry(&replies, ic_msg_t, msg_link);
        ic_local_reply(ic, msg);
    }

    while (!htlist_is_empty(&queries)) {
        ic_msg_t *msg;

        msg = htlist_pop_entry(&queries, ic_msg_t, msg_link);
        /* FIXME: handle flags */
        ic_query_local_flags(ic, msg, 0);
    }
}

static void ic_local_async_schedule_flush(ichannel_t *ic)
{
    if (!ic->local_async_el) {
        ic->local_async_el = el_before_register(ic_local_async_flush, ic);
    }
}

static void
ic_query_local_async_flags(ichannel_t *ic, ic_msg_t *msg, uint32_t flags)
{
    __ic_bpack(msg, msg->rpc->args, msg->data);
    msg->force_pack = true;

    /* flags are not supported in local async mode for the moment. */
    assert(!flags);
    htlist_add_tail(&ic->local_async_queries, &msg->msg_link);
    ic_local_async_schedule_flush(ic);
}

void __ic_query_flags(ichannel_t *ic, ic_msg_t *msg, uint32_t flags)
{
    /* if that crashes, one of the IC_MSG_ABORT callback reenqueues directly in
     * that ichannel_t which is forbidden, fix the code
     */
    assert (ic->cancel_guard == false);

    msg->ic = ic;

    if (msg->timeout > 0 && !ic->is_local_async) {
        msg->timeout_timer = el_timer_register(msg->timeout, 0,
                                               EL_TIMER_LOWRES,
                                               ic_msg_on_timeout, msg);
        el_unref(msg->timeout_timer);
    }

    if (!msg->async) {
        unsigned start = ic->nextslot;

        do {
            if (ic->nextslot == IC_MSG_SLOT_MASK) {
                ic->nextslot = 1;
            } else {
                ic->nextslot++;
            }
            if (unlikely(ic->nextslot == start)) {
                /* can't find a free slot, abort this query */
                __ic_msg_reply_err(ic, msg, IC_MSG_ABORT);
                ic_msg_delete(&msg);
                return;
            }
            msg->slot = ic->nextslot;
        } while (qm_add(ic_msg, &ic->queries, msg->slot, msg) < 0);
        ic->queue_len++;
    }
    if (ic_is_local(ic)) {
        if (ic->is_local_async) {
            ic_query_local_async_flags(ic, msg, flags);
        } else {
            ic_query_local_flags(ic, msg, flags);
        }
    } else {
        ic_queue(ic, msg, flags);
    }
}

void __ic_query(ichannel_t *ic, ic_msg_t *msg)
{
    __ic_query_flags(ic, msg, 0);
}

/**
 * XXX: __ic_query_sync() insures that the message has effectively been
 * written on the socket (and does not wait for the answer). The message is
 * queued, then all pending queries are flushed. This may causing slowdowns,
 * that's why this function may be used only in some very special cases.
 */
void __ic_query_sync(ichannel_t *ic, ic_msg_t *msg)
{
    __ic_query_flags(ic, msg, 0);
    ic_flush(ic);
}

void __ic_bpack(ic_msg_t *msg, const iop_struct_t *st, const void *arg)
{
    qv_t(i32) szs;
    uint8_t *buf;
    int len;
    unsigned bpack_flags = 0;

    if (msg->ic && msg->ic->is_public) {
        bpack_flags = IOP_BPACK_SKIP_PRIVATE;
    }

    qv_inita(&szs, 1024);
    if (msg->hdr) {
        int hlen, szpos;

        hlen  = iop_bpack_size_flags(&ic__hdr__s, msg->hdr,
                                     bpack_flags, &szs);
        szpos = szs.len;
        len   = iop_bpack_size_flags(st, arg,
                                     IOP_BPACK_SKIP_DEFVAL | bpack_flags,
                                     &szs);
        buf   = __ic_get_buf(msg, hlen + len);

        iop_bpack(buf, &ic__hdr__s, msg->hdr, szs.tab);
        iop_bpack(buf + hlen, st, arg, szs.tab + szpos);

        if (unlikely(msg->trace && logger_is_traced(&_G.tracing_logger, 2))) {
            SB_1k(sb);

            sb_addf(&sb, "[msg:%p/slot:%x]; packed header: ", msg, msg->slot);
            iop_sb_jpack(&sb, &ic__hdr__s, msg->hdr, IOP_JPACK_SHORTEN_DATA);
            logger_trace(&_G.tracing_logger, 2, "%*pM", SB_FMT_ARG(&sb));
        }
    } else {
        len   = iop_bpack_size_flags(st, arg,
                                     IOP_BPACK_SKIP_DEFVAL | bpack_flags,
                                     &szs);
        buf   = __ic_get_buf(msg, len);
        iop_bpack(buf, st, arg, szs.tab);

    }

    if (unlikely(msg->trace && logger_is_traced(&_G.tracing_logger, 1))) {
        SB_1k(sb);

        sb_addf(&sb, "[msg:%p/slot:%x]; packed %*pM: ", msg, msg->slot,
                LSTR_FMT_ARG(st->fullname));
        iop_sb_jpack(&sb, st, arg, IOP_JPACK_SHORTEN_DATA);
        logger_trace(&_G.tracing_logger, 1, "%*pM", SB_FMT_ARG(&sb));
    }

    qv_wipe(&szs);
}

void
__ic_msg_build(ic_msg_t *msg, const iop_struct_t *st, const void *arg,
               bool do_bpack)
{
    if (do_bpack) {
        __ic_bpack(msg, st, arg);
    } else {
        msg->dlen = 0;
        msg->data = (void *)arg;
    }
}

void
__ic_msg_build_from(ic_msg_t *msg, const ic_msg_t *msg_src)
{
    assert (msg_src->force_pack);
    p_copy((byte *)__ic_get_buf(msg, msg_src->dlen - IC_MSG_HDR_LEN),
           (byte *)msg_src->data + IC_MSG_HDR_LEN,
           msg_src->dlen - IC_MSG_HDR_LEN);
}

static ic_msg_t *
ic_msg_new_for_reply(ichannel_t **ic, uint64_t slot, int cmd)
{
    assert (!(slot & IC_SLOT_FOREIGN_MASK));

    if (unlikely(!*ic)) {
        *ic = ic_get_from_slot(slot);
        if (unlikely(!*ic)) {
            ic_slot_trace(slot, 0, "no more associated ic");
            return NULL;
        }
    }
    if (likely(ic_can_reply(*ic, slot))) {
        ic_msg_t *msg = ic_msg_new(0);

        ic_msg_init_for_reply(*ic, msg, slot, cmd);
        ic_msg_trace(msg, "build reply message");
        return msg;
    }
    return NULL;
}

static void ic_local_reply(ichannel_t *ic, ic_msg_t *msg)
{
    const void *data = NULL;
    int dlen = 0;

    if (msg->dlen) {
        assert (msg->force_pack
                || (-msg->cmd != IC_MSG_OK && -msg->cmd != IC_MSG_EXN));

        data = (char *)msg->data + IC_MSG_HDR_LEN;
        dlen = msg->dlen - IC_MSG_HDR_LEN;
        assert (dlen >= 0);
    }
    ic_read_process_answer(ic, msg->cmd, msg->slot, data, dlen,
                           msg->force_pack ? NULL : msg);
    ic_msg_delete(&msg);
}

static void ic_queue_for_reply(ichannel_t *ic, ic_msg_t *msg)
{
    if (ic_is_local(ic)) {
        if (ic->is_local_async) {
            htlist_add_tail(&ic->local_async_replies, &msg->msg_link);
            ic_local_async_schedule_flush(ic);
        } else {
            ic_local_reply(ic, msg);
        }
    } else {
        ic_queue(ic, msg, 0);
    }
}

size_t __ic_reply(ichannel_t *ic, uint64_t slot, int cmd, int fd,
                  const iop_struct_t *st, const void *arg)
{
    ic_msg_t *msg;
    int res;

    assert (slot & IC_MSG_SLOT_MASK);

    if (unlikely(ic_slot_is_http(slot))) {
        assert (fd < 0);
        __ichttp_reply(slot, cmd, st, arg);
        return 0;
    }

    ic_query_do_post_hook(ic, cmd, slot, st, arg);

    msg = ic_msg_new_for_reply(&ic, slot, cmd);
    if (!msg) {
        return 0;
    }

    if (ic_is_local(ic)) {
        int32_t pos = qm_find(ic_msg, &ic->queries, slot & IC_MSG_SLOT_MASK);

        if (likely(pos >= 0)) {
            if (unlikely(ic->queries.values[pos]->force_pack)) {
                msg->force_pack = true;
            } else {
                msg->force_dup = unlikely(ic->queries.values[pos]->force_dup);
            }
        }
        if (unlikely(msg->trace && logger_is_traced(&_G.tracing_logger, 1))) {
            SB_1k(sb);

            sb_addf(&sb, "[msg:%p/slot:%x]; locally reply %*pM: ",
                    msg, msg->slot, LSTR_FMT_ARG(st->fullname));
            iop_sb_jpack(&sb, st, arg, IOP_JPACK_SHORTEN_DATA);
            logger_trace(&_G.tracing_logger, 1, "%*pM", SB_FMT_ARG(&sb));
        }
    }
    msg->fd = fd;
    __ic_msg_build(msg, st, arg, !ic_is_local(ic) || msg->force_pack);
    res = msg->dlen;
    ic_queue_for_reply(ic, msg);
    return res;
}

static void ic_reply_err2(ichannel_t *ic, uint64_t slot, int err,
                          const lstr_t *err_str)
{
    ic_msg_t *msg;

    assert (slot & IC_MSG_SLOT_MASK);

    if (unlikely(ic_slot_is_http(slot))) {
        __ichttp_reply_err(slot, err, err_str);
        return;
    }

    if (unlikely(slot & IC_MSG_IS_TRACED)) {
        if (err_str) {
            ic_slot_trace(slot, 0, "replying error %s: %*pM",
                          ic_status_to_string(err), LSTR_FMT_ARG(*err_str));
        } else {
            ic_slot_trace(slot, 0, "replying error %s",
                          ic_status_to_string(err));
        }
    }

    ic_query_do_post_hook(ic, err, slot, NULL, NULL);

    msg = ic_msg_new_for_reply(&ic, slot, err);
    if (!msg) {
        return;
    }

    if (err_str && err_str->len) {
        msg->data = p_new_raw(char, IC_MSG_HDR_LEN + err_str->len + 1);
        msg->dlen = IC_MSG_HDR_LEN + err_str->len + 1;
        memcpyz((char *)msg->data + IC_MSG_HDR_LEN, err_str->s, err_str->len);
    } else {
        msg->data = p_new_raw(char, IC_MSG_HDR_LEN);
        msg->dlen = IC_MSG_HDR_LEN;
    }
    ic_queue_for_reply(ic, msg);
}

void ic_reply_err(ichannel_t *ic, uint64_t slot, int err)
{
    ic_reply_err2(ic, slot, err, NULL);
}

static void ic_sc_do(ichannel_t *ic, int sc_op, const char * nullable payload,
                     int len)
{
    if (!ic->is_closing && !ic_is_local(ic)) {
        ic_msg_t *msg = ic_msg_new(0);
        msg->data = p_new_raw(char, IC_MSG_HDR_LEN  + len);
        msg->dlen = IC_MSG_HDR_LEN + len;
        msg->cmd  = IC_MSG_STREAM_CONTROL;
        msg->slot = sc_op;
        if (payload) {
            memcpy((char *)msg->data + IC_MSG_HDR_LEN, payload, len);
        }
        ic_queue(ic, msg, 0);
    }
}

void ic_bye(ichannel_t *ic)
{
    if (ic->elh) {
        ic_sc_do(ic, IC_SC_BYE, NULL, 0);
    } else {
        el_unregister(&ic->timer);
        el_unregister(&ic->wa_soft_timer);
    }
    ic->is_closing  = true;
    ic->auto_reconn = false;
}

void ic_nop(ichannel_t *ic)
{
    ic_sc_do(ic, IC_SC_NOP, NULL, 0);
}

static bool ic_is_tls_enabled(ichannel_t *ic)
{
    return ic->tls_required && !_G.tls_disabled;
}

bool ic_set_tls_disabled(bool val)
{
    bool prev = _G.tls_disabled;

    _G.tls_disabled = val;

    return prev;
}

/* The version message is only sent at startup. We don't want to use ic_write
 * because some process are queuing queries even if the IC is not queuable.
 *
 * Partial write is unlikely (interruption) because the send buffer should be
 * empty at this stage, so consider it's a failure, and retry the whole
 * connection if you need. */
static int ic_version_write(ichannel_t *ic, int fd)
{
    char buffer[16];
    uint16_t flags = 0;

    if (ic_is_tls_enabled(ic)) {
        flags |= 0x8000;
    }

    put_unaligned_le32(buffer, IC_SC_VERSION);
    put_unaligned_le32(buffer + IC_MSG_CMD_OFFSET, IC_MSG_STREAM_CONTROL);
    put_unaligned_le32(buffer + IC_MSG_DLEN_OFFSET, 4);
    put_unaligned_le16(buffer + IC_MSG_HDR_LEN, IC_VERSION);
    put_unaligned_le16(buffer + IC_MSG_HDR_LEN + 2, flags);
    return (write(fd, buffer, sizeof(buffer)) != sizeof(buffer)) ? -1 : 0;
}

/*----- ichannel life cycle API -----*/

ichannel_t *ic_get_by_id(uint32_t id)
{
    return qm_get_def(ic, &_G.ics, id, NULL);
}

ichannel_t *ic_init(ichannel_t *ic)
{
    /* ic_initialize() should be called before ic_init() */
    assert (_G.ics.k_size);

    p_clear(ic, 1);
    htlist_init(&ic->msg_list);
    htlist_init(&ic->iov_list);
    ic->current_fd  = -1;
    ic->auto_reconn = true;
    ic->tls_required = true;
    ic->priority    = EV_PRIORITY_NORMAL;
    qm_init(ic_msg, &ic->queries);
    sb_init(&ic->rbuf);
    ic_choose_id(ic);
#ifdef IC_DEBUG_REPLIES
    qh_init(ic_replies, &ic->dbg_replies);
#endif
#ifndef NDEBUG
    ic->pending_max = 128;
#endif
    ic->retry_delay = 1000;

    return ic;
}

static int ic_mark_connected(ichannel_t *ic, int fd)
{
    ic->queuable = true;
    el_fd_set_hook(ic->elh, ic_event);
    ic->is_connected = true;
    ic->on_event(ic, IC_EVT_CONNECTED);
    if (ic->on_creds && ic->is_unix) {
        ic_creds_t creds;
        struct ucred ucred;
        socklen_t len = sizeof(ucred);

        RETHROW(getsockopt(fd, SOL_SOCKET, SO_PEERCRED, &ucred, &len));
        creds = (ic_creds_t){ .uid = ucred.uid, .gid = ucred.gid, .pid = ucred.pid };
        RETHROW((*ic->on_creds)(ic, &creds));

    }
    /* force an exchange at connect time, so force NOP if queue is empty */
    if (htlist_is_empty(&ic->msg_list)) {
        ic_nop(ic);
    }
    /* We want to run ic_event and it's obvious that OUT is ready, but let the
     * event loop calls it. */
    el_fd_set_mask(ic->elh, POLLINOUT);
    return 0;
}

void ic_mark_disconnected(ichannel_t *ic)
{
    ic->is_closing = true;
    ic_disconnect(ic);
    if (!ic->is_spawned && ic->auto_reconn) {
        assert (ic->timer == NULL);
        ic->timer = el_timer_register(ic->retry_delay, 0, 0, ic_reconnect,
                                      ic);
        el_unref(ic->timer);
    }
}

/* Blocking is assumed if ev == NULL. Returns -1 on error, 0 on success or on
 * partial reading (for non blocking sockets). */
static int ic_tls_handshake(el_t ev, int fd, short events, data_t priv)
{
    ichannel_t *ic = priv.ptr;
    X509* cert;

    switch (ssl_do_handshake(ic->ssl, ev, fd, &ic->rbuf)) {
      case SSL_HANDSHAKE_SUCCESS:
        /* Handshake completed. Double check that the certificate is correct
         * (see ic_verify_callback above for more context). */
        cert = SSL_get_peer_certificate(ic->ssl);
        if (unlikely(!cert)) {
            goto error;
        }
        if (unlikely(X509_cmp(cert, _G.certificate) != 0)) {
            X509_free(cert);
            goto error;
        }
        X509_free(cert);

        if (ic_mark_connected(ic, fd) < 0) {
            goto error;
        }
        assert (ic->rbuf.len == 0);
        break;
      case SSL_HANDSHAKE_PENDING:
        break;
      case SSL_HANDSHAKE_CLOSED:
        ic_mark_disconnected(ic);
        break;
      case SSL_HANDSHAKE_ERROR:
        goto error;
    }

    return 0;

  error:
    ic_mark_disconnected(ic);
    return -1;
}

/* Blocking is assumed if ev == NULL. Returns -1 on error, 0 on success or on
 * partial (or insufficient) reading (for non blocking sockets).
 *
 * XXX: Changes may need to be propagated to ic_bypass_version_handshake.
 */
static int ic_version_handshake(el_t ev, int fd, short events, data_t priv)
{
    ichannel_t *ic = priv.ptr;
    sb_t *buf = &ic->rbuf;
    ssize_t res;
    int slot, dlen, cmd;

    if (events == EL_EVENTS_NOACT) {
        goto error;
    }

    /* Get and parse the version header; determine the peer version. */
  again_blocking:
    res = _ic_read(ic, events, fd, BUFSIZ);
    if (res < 0) {
        goto error;
    }
    if (res == 0) {
        if (ev == NULL) {
            logger_error(&_G.logger,
                         "blocking IC connection failed (timeout)");
            return -1;
        }
        return 0;
    }

    if (buf->len < IC_MSG_HDR_LEN) {
        if (ev == NULL) {
            goto again_blocking;
        }
        return 0;
    }

    slot = get_unaligned_le32(buf->data);
    cmd = get_unaligned_le32(buf->data + IC_MSG_CMD_OFFSET);
    dlen = get_unaligned_le32(buf->data + IC_MSG_DLEN_OFFSET);
    if (dlen < 0 || (uint32_t)dlen > MEM_ALLOC_MAX) {
        goto error;
    }
    if (cmd == IC_MSG_STREAM_CONTROL && slot == IC_SC_VERSION) {
        char *data = buf->data + IC_MSG_HDR_LEN;
        uint16_t version;
        uint16_t vflags;

        if (dlen < 4) {
            goto error;
        }
        if (buf->len < IC_MSG_HDR_LEN + 4) {
            if (ev == NULL) {
                goto again_blocking;
            }
            return 0;
        }
        version = get_unaligned_le16(data);
        vflags = get_unaligned_le16(data + 2);
        ic->peer_version = version;
        if (vflags & 0x8000) {
            if (_G.tls_disabled) {
                logger_warning(&_G.logger, "peer asked for TLS activation, "
                               "but it is disabled globally");
            }
            ic->tls_required = true;
        }
        sb_skip(buf, IC_MSG_HDR_LEN + dlen);
    } else {
        ic->peer_version = 0;
    }

    /* Compatibility checks. */
    if (ic_is_tls_enabled(ic)) {
        assert (!ic->is_unix);
        if (ic->peer_version < 1) {
            if (ic->is_spawned) {
                logger_trace(&_G.logger, 0, "an outdated client has been "
                             "disconnected because it cannot use TLS");
            } else {
                logger_error(&_G.logger, "IC connection failed: the remote "
                             "server is too old and cannot use TLS");
            }
            goto error;
        }
        ic->ssl = SSL_new(_G.ssl_ctx);
        if (ev) {
            el_fd_set_hook(ev, &ic_tls_handshake);
        }

        if (ic->is_spawned) {
            assert (ev);
            SSL_set_accept_state(ic->ssl);
            el_fd_set_mask(ev, POLLIN);
            if (buf->len > 0) {
                /* Trailing data is the beginning of the TLS handshake. We
                 * must give it to openSSL. */
                BIO *rbio_null = BIO_new(BIO_f_null());
                BIO *rbio_buf = BIO_new_mem_buf(buf->data, buf->len);
                BIO *wbio = BIO_new_fd(fd, BIO_NOCLOSE);

                BIO_set_mem_eof_return(rbio_buf, -1);
                BIO_push(rbio_null, rbio_buf);
                SSL_set_bio(ic->ssl, rbio_null, wbio);
                return ic_tls_handshake(ev, fd, events, priv);
            } else {
                SSL_set_fd(ic->ssl, fd);
            }
        } else {
            if (buf->len > 0) {
                /* We have received data from the server, but the TLS hanshake
                 * should be initiated by the client! */
                logger_error(&_G.logger, "data received from server (version "
                             "%d) at TLS handshake initialization",
                             ic->peer_version);
                goto error;
            }
            SSL_set_connect_state(ic->ssl);
            SSL_set_fd(ic->ssl, fd);
            return ic_tls_handshake(ev, fd, events, priv);
        }

        return 0;
    }

    if (ic_mark_connected(ic, fd) < 0) {
        goto error;
    }
    return 0;

  error:
    ic_mark_disconnected(ic);
    return -1;
}

/* This function is used by Unix socket because it's assumed that processes on
 * the same host have the same version. */
static void ic_bypass_version_handshake(ichannel_t *ic, int fd)
{
    assert (ic->is_unix);
    ic->tls_required = false;
    ic->peer_version = IC_VERSION;
    IGNORE(expect(ic_mark_connected(ic, fd) >= 0));
}

static int ic_connecting(el_t ev, int fd, short events, data_t priv)
{
    ichannel_t *ic = priv.ptr;
    int res;

    if (events == EL_EVENTS_NOACT) {
        goto error;
    }

    res = socket_connect_status(fd);
    if (res < 0) {
        goto error;
    }
    if (res == 0) {
        return 0;
    }

    if (ic_version_write(ic, fd) < 0) {
        goto error;
    }
    el_fd_set_hook(ev, ic_version_handshake);
    el_fd_set_mask(ev, POLLIN);

    return 0;

  error:
    ic_mark_disconnected(ic);
    return -1;
}

static void ic_watch_act_soft(el_t ev, data_t priv)
{
    ichannel_t *ic = priv.ptr;

    ic->on_event(ic, IC_EVT_NOACT);
    el_unregister(&ic->wa_soft_timer);
}

static void ic_watch_act_nop(el_t ev, data_t priv)
{
    ic_nop(priv.ptr);
    el_timer_restart(ev, 0);
}

static void __ic_watch_activity(ichannel_t *ic)
{
    int wa = ic->wa_hard;

    if (!ic->elh) {
        return;
    }

    el_fd_watch_activity(ic->elh, POLLIN, wa);
    el_unregister(&ic->timer);
    el_unregister(&ic->wa_soft_timer);

    if (ic->wa_soft > 0) {
        if (wa > 0) {
            wa = MIN(wa, ic->wa_soft);
        } else {
            wa = ic->wa_soft;
        }
    }

    if (wa <= 0) {
        return;
    }

    ic->timer = el_timer_register(wa / 3, 0, 0, ic_watch_act_nop, ic);
    el_unref(ic->timer);
}

static int __ic_connect(ichannel_t *ic, int flags, int timeout)
{
    int type, sock;

    if (ic_is_local(ic)) {
        logger_fatal(&_G.logger, "cannot connect a local ic");
    }

    assert (!ic->elh);

    ic->is_spawned = false;
    ic->is_unix = (ic->su.family == AF_UNIX);

    if (ic->is_unix) {
        ic->tls_required = false;
        flags &= ~O_NONBLOCK;
        type = SOCK_SEQPACKET;
        ic->is_seqpacket = true;
    } else {
        type = SOCK_STREAM;
        flags |= FD_FEAT_TCP_NODELAY;
        ic->is_seqpacket = false;

        if (ic->remote_addr.s) {
            SB_1k(err);

            if (addr_resolve_with_err(ic->name.s, ic->remote_addr, &ic->su,
                                      &err) < 0)
            {
                logger_warning(&_G.logger, "%pL", &err);
                if (ic->auto_reconn) {
                    ic_mark_disconnected(ic);
                    return 0;
                } else {
                    return -1;
                }
            }
        }
    }

    sock = connectx_as(-1, &ic->su, 1, NULL, type, ic->protocol, flags,
                       timeout);
    if (sock < 0) {
        return -1;
    }
    if (flags & O_NONBLOCK) {
        ic->elh = el_fd_register(sock, true, POLLOUT, &ic_connecting, ic);
        ic->queuable = true;
    } else
    if (ic->is_unix) {
        ic->elh = el_fd_register(sock, true, POLLINOUT, &ic_version_handshake,
                                 ic);
        if (ic_version_write(ic, sock) < 0) {
            ic_mark_disconnected(ic);
            return -1;
        }

        fd_set_features(sock, O_NONBLOCK);
        ic->queuable = true;
    } else {
        data_t priv;
        struct timeval tv = { .tv_sec = 0 };

        ic->elh = el_fd_register(sock, true, POLLINOUT, &ic_event, ic);
        if (ic_version_write(ic, sock) < 0) {
            ic_mark_disconnected(ic);
            return -1;
        }
        priv.ptr = ic;
        if (ic_version_handshake(NULL, sock, POLLIN, priv) < 0) {
            ic_mark_disconnected(ic);
            return -1;
        }

        /* Remove the timeout set by connectx. */
        setsockopt(sock, SOL_SOCKET, SO_RCVTIMEO, &tv, sizeof(tv));
        fd_set_features(sock, O_NONBLOCK);
    }
    (el_fd_set_priority)(ic->elh, ic->priority);
    __ic_watch_activity(ic);
    if (ic->do_el_unref) {
        el_unref(ic->elh);
    }
    return 0;
}

void ic_watch_activity(ichannel_t *ic, int timeout_soft, int timeout_hard)
{
    if (ic_is_local(ic)) {
        return;
    }

    ic->wa_soft = timeout_soft;
    ic->wa_hard = timeout_hard;
    __ic_watch_activity(ic);
}

ev_priority_t ic_set_priority(ichannel_t *ic, ev_priority_t prio)
{
    ev_priority_t prev = ic->priority;

    ic->priority = prio;

    if (ic->elh) {
        ev_priority_t elprev = (el_fd_set_priority)(ic->elh, prio);
        assert (elprev == prev);
    }

    return prev;
}

int ic_connect(ichannel_t *ic)
{
    return __ic_connect(ic, O_NONBLOCK, 0);
}

int ic_connect_blocking(ichannel_t *ic, int timeout)
{
    return __ic_connect(ic, 0, timeout > 0 ? timeout : 60);
}

void ic_spawn(ichannel_t *ic, int fd, ic_creds_f *creds_fn)
{
    int type = 0;
    sockunion_t su;
    socklen_t len = sizeof(su);

    if (!expect(!ic_is_local(ic))) {
        return;
    }

    ic->is_spawned = true;
    ic->on_creds   = creds_fn;

    if (getsockname(fd, &su.sa, &len) < 0) {
        logger_panic(&_G.logger,
                     "getsockname failed in ic_spawn on fd %d: %m", fd);
    }
    ic->is_unix = su.family == AF_UNIX;

    if (getsockopt(fd, SOL_SOCKET, SO_TYPE, (void *)&type, &len)) {
        logger_panic(&_G.logger, E_UNIXERR("getsockopt"));
    }
    assert (type == SOCK_STREAM || type == SOCK_SEQPACKET);
    ic->is_seqpacket = type == SOCK_SEQPACKET;

    ic->elh = el_fd_register(fd, true, POLLIN, &ic_version_handshake, ic);

    if (ic->is_unix) {
        ic_bypass_version_handshake(ic, fd);
    } else {
        if (type == SOCK_STREAM) {
            fd_set_features(fd, FD_FEAT_TCP_NODELAY);
        }
        if (ic_version_write(ic, fd) < 0) {
            ic_mark_disconnected(ic);
            return;
        }
    }

    (el_fd_set_priority)(ic->elh, ic->priority);
    __ic_watch_activity(ic);
    if (ic->do_el_unref) {
        el_unref(ic->elh);
    }
}

static int ic_accept(el_t ev, int fd, short events, data_t priv)
{
    int (*on_accept)(el_t ev, int fd) = priv.ptr;
    int sock;

    while ((sock = acceptx(fd, O_NONBLOCK)) >= 0) {
        if ((*on_accept)(ev, sock)) {
            p_close(&sock);
        }
    }
    return 0;
}

el_t ic_listento(const sockunion_t *su, int type, int proto,
                 int (*on_accept)(el_t ev, int fd))
{
    int sock;

    sock = RETHROW_NP(listenx(-1, su, 1, type, proto, O_NONBLOCK));
    return el_unref(el_fd_register(sock, true, POLLIN, &ic_accept,
                                   (void *)on_accept));
}

void ic_drop_ans_cb(ichannel_t *ic, ic_msg_t *msg,
                    ic_status_t res, void *arg, void *exn)
{
}

opt_bool_t ic_hdr_get_dealias(const ic__hdr__t *hdr)
{
    if (!hdr || !IOP_UNION_IS(ic__hdr, hdr, simple)) {
        return (opt_bool_t)OPT_NONE;
    }

    return hdr->simple.dealias;
}

int ic_hdr_set_dealias(ic__hdr__t * nullable hdr, bool dealias)
{
    RETHROW_PN(hdr);

    if (IOP_UNION_IS(ic__hdr, hdr, simple)) {
        OPT_SET(hdr->simple.dealias, dealias);
        return 0;
    }

    return -1;
}
