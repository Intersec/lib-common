/***************************************************************************/
/*                                                                         */
/* Copyright 2025 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include <lib-common/unix.h>
#include "iopc.h"
#include "iopc-internal.h"

/* {{{ Helpers */

#define STUB_HEADER \
    "#***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****\n"     \
    "# pylint: disable=all\n"                                                \
    "\n"                                                                     \
    "import typing\n"                                                        \
    "import typing_extensions\n"                                             \
    "import iopy\n"                                                          \
    "\n"

static void iopc_pystub_dump_py_mod_name(sb_t *buf, const iopc_path_t *path)
{
    tab_for_each_entry(bit, &path->bits) {
        sb_addf(buf, "%s_", bit);
    }
    sb_adds(buf, "_iop");
}

static void iopc_pystup_dump_fold_begin(sb_t *buf, const char *fold_name)
{
    sb_addf(buf, "# {""{{ %s\n", fold_name);
}

static void iopc_pystup_dump_fold_begin_extra(sb_t *buf,
                                              const char *fold_name)
{
    iopc_pystup_dump_fold_begin(buf, fold_name);
    sb_adds(buf, "\n\n");
}

static void iopc_pystup_dump_fold_end(sb_t *buf)
{
    sb_adds(buf, "# }""}}\n");
}

static void iopc_pystup_dump_fold_end_extra(sb_t *buf)
{
    sb_adds(buf, "\n\n");
    iopc_pystup_dump_fold_end(buf);
}

static void iopc_pystub_dump_package_member(sb_t *buf, const iopc_pkg_t *pkg,
                                            const iopc_pkg_t *member_pkg,
                                            const iopc_path_t *member_path,
                                            const char *member_name)
{
    if (pkg != member_pkg) {
        assert(member_path->bits.len);
        iopc_pystub_dump_py_mod_name(buf, member_path);
        sb_addc(buf, '.');
    }
    sb_adds(buf, member_name);
}

/* }}} */
/* {{{ Enum */

static void iopc_pystub_dump_enum(sb_t *buf, const iopc_pkg_t *pkg,
                                  const iopc_enum_t *en)
{
    iopc_pystup_dump_fold_begin_extra(buf, en->name);

    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s(iopy.Enum):\n", en->name);
    sb_adds(buf, "    pass\n");

    sb_addf(buf, "\n\n%s_ParamType = typing.Union[%s, int, str]\n",
            en->name, en->name);

    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_enums(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(en, &pkg->enums) {
        iopc_pystub_dump_enum(buf, pkg, en);
    }
}

/* }}} */
/* {{{ Struct/Union */

static void iopc_pystub_dump_field_basetype(sb_t *buf, const iopc_pkg_t *pkg,
                                            const iopc_field_t *field,
                                            bool is_param_type)
{
    switch (field->kind) {
    case IOP_T_I8:
    case IOP_T_U8:
    case IOP_T_I16:
    case IOP_T_U16:
    case IOP_T_I32:
    case IOP_T_U32:
    case IOP_T_I64:
    case IOP_T_U64:
        sb_adds(buf, "int");
        break;

    case IOP_T_BOOL:
        sb_adds(buf, "bool");
        break;

    case IOP_T_DOUBLE:
        sb_adds(buf, "float");
        break;

    case IOP_T_VOID:
        sb_adds(buf, "typing.Any");
        break;

    case IOP_T_STRING:
    case IOP_T_XML:
        if (is_param_type) {
            sb_adds(buf, "typing.Union[str, bytes]");
        } else {
            sb_adds(buf, "str");
        }
        break;

    case IOP_T_DATA:
        if (is_param_type) {
            sb_adds(buf, "typing.Union[bytes, str]");
        } else {
            sb_adds(buf, "bytes");
        }
        break;

    case IOP_T_STRUCT:
    case IOP_T_UNION:
    case IOP_T_ENUM:
        iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                        field->type_path, field->type_name);
        if (is_param_type) {
            sb_adds(buf, "_ParamType");
        }
        break;
    }
}

static void iopc_pystub_dump_field_type(sb_t *buf, const iopc_pkg_t *pkg,
                                        const iopc_field_t *field,
                                        bool is_param_type)
{
    bool ending_bracket = false;

    switch (field->repeat) {
    case IOP_R_OPTIONAL:
        sb_adds(buf, "iopy.IopFieldOptional[");
        ending_bracket = true;
        break;

    case IOP_R_REPEATED:
        sb_adds(buf, "typing.List[");
        ending_bracket = true;
        break;

    case IOP_R_DEFVAL:
    case IOP_R_REQUIRED:
        break;

    default:
        break;
    }
    iopc_pystub_dump_field_basetype(buf, pkg, field, is_param_type);

    if (ending_bracket) {
        sb_addc(buf, ']');
    }
}

static void iopc_pystub_dump_field(sb_t *buf, const iopc_pkg_t *pkg,
                                   const iopc_field_t *field)
{
    sb_adds(buf, field->name);
    sb_adds(buf, ": ");
    iopc_pystub_dump_field_type(buf, pkg, field, false);
}

static void
iopc_pystub_dump_fields(sb_t *buf, const iopc_pkg_t *pkg,
                        const iopc_struct_t *st)
{
    if (st->fields.len) {
        tab_for_each_entry(field, &st->fields) {
            sb_adds(buf, "    ");
            iopc_pystub_dump_field(buf, pkg, field);
            sb_adds(buf, "\n");
        }
        sb_adds(buf, "\n");
    }
}

static void iopc_pystub_dump_unpack_inits(sb_t *buf)
{
    sb_adds(buf,
            "    @typing.overload\n"
            "    def __init__(cls, *, _json: typing.Union[str, bytes]): ...\n"
            "\n"
            "    @typing.overload\n"
            "    def __init__(cls, *, _yaml: typing.Union[str, bytes]): ...\n"
            "\n"
            "    @typing.overload\n"
            "    def __init__(cls, *, _xml: typing.Union[str, bytes]): ...\n"
            "\n"
            "    @typing.overload\n"
            "    def __init__(cls, *, _hex: typing.Union[str, bytes]): ...\n"
            "\n"
            "    @typing.overload\n"
            "    def __init__(cls, *, _bin: typing.Union[str, bytes]): ...\n"
    );
}

/* }}} */
/* {{{ Struct */

static void
iopc_pystub_dump_struct_dict_type(sb_t *buf, const iopc_pkg_t *pkg,
                                  const iopc_struct_t *st,
                                  const char *st_name)
{
    sb_addf(buf, "%s_DictType = typing_extensions.TypedDict("
            "'%s_DictType', {\n", st_name, st_name);

    tab_for_each_entry(field, &st->fields) {
        sb_addf(buf, "    '%s': ", field->name);
        iopc_pystub_dump_field_type(buf, pkg, field, true);
        sb_adds(buf, ",\n");
    }

    sb_adds(buf, "})\n\n\n");
}

static void
iopc_pystub_dump_struct_intern(sb_t *buf, const iopc_pkg_t *pkg,
                               const iopc_struct_t *st, const char *st_name)
{
    assert(st_name);

    iopc_pystub_dump_struct_dict_type(buf, pkg, st, st_name);

    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s(", st_name);
    if (iopc_is_class(st->type) && st->extends.len) {
        const iopc_pkg_t *parent_pkg = st->extends.tab[0]->pkg;
        const iopc_struct_t *parent = st->extends.tab[0]->st;

        iopc_pystub_dump_package_member(buf, pkg, parent_pkg,
                                        parent_pkg->name, parent->name);
    } else {
        sb_adds(buf, "iopy.Struct");
    }
    sb_adds(buf, "):\n");

    iopc_pystub_dump_fields(buf, pkg, st);

    iopc_pystub_dump_unpack_inits(buf);

    sb_addf(buf, "\n\n%s_ParamType = typing.Union[%s, %s_DictType]\n",
            st_name, st_name, st_name);
}

static void iopc_pystub_dump_struct(sb_t *buf, const iopc_pkg_t *pkg,
                                    const iopc_struct_t *st)
{
    const char *st_name = st->name;

    iopc_pystup_dump_fold_begin_extra(buf, st_name);
    iopc_pystub_dump_struct_intern(buf, pkg, st, st_name);
    iopc_pystup_dump_fold_end_extra(buf);
}

/* }}} */
/* {{{ Union */

typedef struct iopc_pystub_union_ambiguous_type_t {
    bool is_ambiguous;
} iopc_pystub_union_ambiguous_type_t;

qm_kvec_t(iopc_pystub_union_ambiguous_type, lstr_t,
          iopc_pystub_union_ambiguous_type_t, qhash_lstr_hash,
          qhash_lstr_equal);

static void t_iopc_pystub_add_ambiguous_type(
    lstr_t py_type, bool is_parent_cls,
    qm_t(iopc_pystub_union_ambiguous_type) *types_map)
{
    uint32_t pos;
    iopc_pystub_union_ambiguous_type_t ambiguous_type = {
        .is_ambiguous = is_parent_cls,
    };

    pos = qm_put(iopc_pystub_union_ambiguous_type, types_map, &py_type,
                 ambiguous_type, 0);
    if (pos & QHASH_COLLISION) {
        pos ^= QHASH_COLLISION;
        types_map->values[pos].is_ambiguous = true;
    }
}

static void
t_iopc_pystub_add_ambiguous_type_parents(
    const iopc_pkg_t *pkg, const iopc_struct_t *st,
    qm_t(iopc_pystub_union_ambiguous_type) *types_map)
{
    SB_1k(sb);
    const iopc_pkg_t *parent_pkg;
    const iopc_struct_t *parent;

    if (!iopc_is_class(st->type) || !st->extends.len) {
        return;
    }

    parent_pkg = st->extends.tab[0]->pkg;
    parent = st->extends.tab[0]->st;

    iopc_pystub_dump_package_member(&sb, pkg, parent_pkg, parent_pkg->name,
                                    parent->name);
    sb_adds(&sb, "_ParamType");
    t_iopc_pystub_add_ambiguous_type(
        t_lstr_dup(LSTR_SB_V(&sb)), true, types_map);

    t_iopc_pystub_add_ambiguous_type_parents(pkg, parent, types_map);
}

static void
t_iopc_pystub_add_ambiguous_types_field(
    const iopc_pkg_t *pkg, const iopc_field_t *field,
    qm_t(iopc_pystub_union_ambiguous_type) *types_map)
{
    switch (field->kind) {
    case IOP_T_I8:
    case IOP_T_U8:
    case IOP_T_I16:
    case IOP_T_U16:
    case IOP_T_I32:
    case IOP_T_U32:
    case IOP_T_I64:
    case IOP_T_U64:
        t_iopc_pystub_add_ambiguous_type(LSTR("int"), false, types_map);
        break;

    case IOP_T_BOOL:
        t_iopc_pystub_add_ambiguous_type(LSTR("bool"), false, types_map);
        break;

    case IOP_T_DOUBLE:
        t_iopc_pystub_add_ambiguous_type(LSTR("float"), false, types_map);
        break;

    case IOP_T_VOID:
        t_iopc_pystub_add_ambiguous_type(LSTR("None"), false, types_map);
        break;

    case IOP_T_STRING:
    case IOP_T_XML:
    case IOP_T_DATA:
        t_iopc_pystub_add_ambiguous_type(LSTR("str"), false, types_map);
        t_iopc_pystub_add_ambiguous_type(LSTR("bytes"), false, types_map);
        break;

    case IOP_T_STRUCT:
        /* Recursively add the parent classes as ambiguous type so we don't
         * have the base and child type as unambiguous types in the end. */
        t_iopc_pystub_add_ambiguous_type_parents(
            pkg, field->struct_def, types_map);

        /* FALLTHROUGH */

    case IOP_T_UNION:
    case IOP_T_ENUM: {
        SB_1k(sb);

        iopc_pystub_dump_package_member(&sb, pkg, field->type_pkg,
                                        field->type_path, field->type_name);
        sb_adds(&sb, "_ParamType");
        t_iopc_pystub_add_ambiguous_type(
            t_lstr_dup(LSTR_SB_V(&sb)), false, types_map);
    } break;
    }
}

static qv_t(lstr) t_iopc_pystub_build_unambiguous_types(
    const iopc_pkg_t *pkg, const iopc_struct_t *st)
{
    qm_t(iopc_pystub_union_ambiguous_type) types_map;
    qv_t(lstr) res;

    /* List get all possible ambiguous types of the fields to the map. */
    t_qm_init(iopc_pystub_union_ambiguous_type, &types_map,
              st->fields.len * 2);
    tab_for_each_entry(field, &st->fields) {
        t_iopc_pystub_add_ambiguous_types_field(pkg, field, &types_map);
    }

    /* Get the python types of the unambiguous types. */
    t_qv_init(&res, qm_len(iopc_pystub_union_ambiguous_type, &types_map));
    qm_for_each_key_value_p(iopc_pystub_union_ambiguous_type, py_type,
                            ambiguous_type, &types_map)
    {
        if (!ambiguous_type->is_ambiguous) {
            qv_append(&res, py_type);
        }
    }

    return res;
}

static void
iopc_pystub_dump_union_dict_types(sb_t *buf, const iopc_pkg_t *pkg,
                                  const iopc_struct_t *st)
{
    const char *st_name = st->name;

    tab_for_each_entry(field, &st->fields) {
        sb_addf(buf, "%s_%s_DictType = typing_extensions.TypedDict("
                "'%s_%s_DictType', {\n    '%s': ",
                st_name, field->name, st_name,
                field->name, field->name);
        iopc_pystub_dump_field_type(buf, pkg, field, true);
        sb_adds(buf, "\n})\n\n\n");
    }

    sb_addf(buf, "%s_DictType = typing.Union[", st_name);

    tab_for_each_pos(pos, &st->fields) {
        const iopc_field_t *field = st->fields.tab[pos];

        if (pos > 0) {
            sb_adds(buf, ", ");
        }

        sb_addf(buf, "%s_%s_DictType", st_name, field->name);
    }

    sb_adds(buf, "]\n\n\n");
}

static void
iopc_pystub_dump_union_unambiguous_type(sb_t *buf, const iopc_pkg_t *pkg,
                                        const iopc_struct_t *st,
                                        const qv_t(lstr) *unambiguous_types)
{
    const char *st_name = st->name;

    assert(unambiguous_types->len);

    sb_addf(buf, "%s_UnambiguousType = typing.Union[", st_name);

    tab_for_each_pos(pos, unambiguous_types) {
        lstr_t py_type = unambiguous_types->tab[pos];

        if (pos > 0) {
            sb_adds(buf, ", ");
        }
        sb_add_lstr(buf, py_type);
    }

    sb_adds(buf, "]\n\n\n");
}

static void iopc_pystub_dump_union(sb_t *buf, const iopc_pkg_t *pkg,
                                   const iopc_struct_t *st)
{
    t_scope;
    const char *st_name = st->name;
    qv_t(lstr) unambiguous_types;

    /* Get the unambiguous types */
    unambiguous_types = t_iopc_pystub_build_unambiguous_types(pkg, st);

    /* Begin fold */
    iopc_pystup_dump_fold_begin_extra(buf, st_name);

    /* Dump dict types */
    iopc_pystub_dump_union_dict_types(buf, pkg, st);

    /* Dump unambigous types if any */
    if (unambiguous_types.len) {
        iopc_pystub_dump_union_unambiguous_type(buf, pkg, st,
                                                &unambiguous_types);
    }

    /* Begin class type */
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s(iopy.Union):\n", st_name);

    /* Dump fields */
    iopc_pystub_dump_fields(buf, pkg, st);

    /* Dump unpack inits */
    iopc_pystub_dump_unpack_inits(buf);

    /* Dump param class type */
    sb_addf(buf, "\n\n%s_ParamType = typing.Union[%s, %s_DictType",
            st_name, st_name, st_name);
    if (unambiguous_types.len) {
        sb_addf(buf, ", %s_UnambiguousType", st_name);
    }
    sb_adds(buf, "]\n");

    /* End fold */
    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_structs(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(st, &pkg->structs) {
        switch (st->type) {
        case STRUCT_TYPE_STRUCT:
        case STRUCT_TYPE_CLASS:
            iopc_pystub_dump_struct(buf, pkg, st);
            break;

        case STRUCT_TYPE_UNION:
            iopc_pystub_dump_union(buf, pkg, st);
            break;

        default:
            break;
        }
    }
}

/* }}} */
/* {{{ Rpc */

static void
iopc_pystub_dump_rpc_fun_struct(sb_t *buf, const iopc_pkg_t *pkg,
                                const iopc_iface_t *iface,
                                const iopc_fun_t *rpc, const char *type,
                                const iopc_fun_struct_t *fun_st)
{
    t_scope;
    const char *st_name = t_fmt("%s_%s_%s", iface->name, rpc->name, type);

    if (iopc_fun_struct_is_void(fun_st)) {
        sb_addf(buf, "%s = None\n", st_name);
    } else if (fun_st->is_anonymous) {
        iopc_pystub_dump_struct_intern(buf, pkg, fun_st->anonymous_struct,
                                       st_name);
        sb_adds(buf, "\n\n");
    } else {
        sb_addf(buf, "%s = ", st_name);
        iopc_pystub_dump_field_basetype(buf, pkg, fun_st->existing_struct,
                                        false);
        sb_adds(buf, "\n");
    }
}

static void iopc_pystub_dump_rpc(sb_t *buf, const iopc_pkg_t *pkg,
                                 const iopc_iface_t *iface,
                                 const iopc_fun_t *rpc)
{
    t_scope;
    const char *rpc_name = t_fmt("%s_%s", iface->name, rpc->name);

    iopc_pystup_dump_fold_begin_extra(buf, rpc_name);

    iopc_pystub_dump_rpc_fun_struct(buf, pkg, iface, rpc, "Arg", &rpc->arg);
    iopc_pystub_dump_rpc_fun_struct(buf, pkg, iface, rpc, "Res", &rpc->res);
    iopc_pystub_dump_rpc_fun_struct(buf, pkg, iface, rpc, "Exn", &rpc->exn);


    sb_adds(buf, "\n\n");
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_RPC(iopy.RPC):\n", rpc_name);
    sb_addf(buf, "    Arg = %s_Arg\n", rpc_name);
    sb_addf(buf, "    Res = %s_Res\n", rpc_name);
    sb_addf(buf, "    Exn = %s_Exn\n", rpc_name);

    iopc_pystup_dump_fold_end_extra(buf);
}

/* }}} */
/* {{{ Interface */

static void iopc_pystub_dump_iface(sb_t *buf, const iopc_pkg_t *pkg,
                                   const iopc_iface_t *iface)
{
    iopc_pystup_dump_fold_begin(buf, iface->name);

    tab_for_each_entry(rpc, &iface->funs) {
        iopc_pystub_dump_rpc(buf, pkg, iface, rpc);
    }

    sb_adds(buf, "\n\n");
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_Iface(iopy.Iface):\n", iface->name);
    if (iface->funs.len) {
        tab_for_each_entry(rpc, &iface->funs) {
            sb_addf(buf, "    %s = %s_%s_RPC\n", rpc->name, iface->name,
                    rpc->name);
        }
    } else {
        sb_adds(buf, "    pass\n");
    }
    sb_adds(buf, "\n\n");

    iopc_pystup_dump_fold_end(buf);
}

static void iopc_pystub_dump_ifaces(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(iface, &pkg->ifaces) {
        switch (iface->type) {
        case IFACE_TYPE_IFACE:
            iopc_pystub_dump_iface(buf, pkg, iface);
            break;

        default:
            break;
        }
    }
}

/* }}} */
/* {{{ Module */

static void iopc_pystub_dump_module(sb_t *buf, const iopc_pkg_t *pkg,
                                    const iopc_struct_t *mod)
{
    const char *mod_name = mod->name;

    iopc_pystup_dump_fold_begin_extra(buf, mod_name);

    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_Module(iopy.Module):\n", mod_name);

    if (mod->fields.len) {
        tab_for_each_entry(field, &mod->fields) {
            sb_addf(buf, "    %s = ", field->name);
            iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                            field->type_path,
                                            field->type_name);
            sb_adds(buf, "_Iface\n");
        }
    } else {
        sb_adds(buf, "    pass\n");
    }


    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_modules(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(mod, &pkg->modules) {
        iopc_pystub_dump_module(buf, pkg, mod);
    }
}

/* }}} */
/* {{{ Package */

static void iopc_pystub_dump_package(sb_t *buf, const iopc_pkg_t *pkg)
{
    iopc_pystup_dump_fold_begin_extra(buf, "Package");

    sb_adds(buf, "@typing.type_check_only\n");
    sb_adds(buf, "class Interfaces(iopy.Interfaces):\n");

    if (pkg->ifaces.len) {
        tab_for_each_entry(iface, &pkg->ifaces) {
            switch (iface->type) {
            case IFACE_TYPE_IFACE:
                sb_addf(buf, "    %s = %s_Iface\n", iface->name, iface->name);
                break;

            default:
                break;
            }
        }
    } else {
        sb_adds(buf, "    pass\n");
    }

    sb_adds(buf, "\n\n");

    sb_adds(buf, "@typing.type_check_only\n");
    sb_adds(buf, "class Package(iopy.Package):\n");

    sb_adds(buf, "    interfaces: Interfaces\n\n");

    tab_for_each_entry(en, &pkg->enums) {
        sb_addf(buf, "    %s = %s\n", en->name, en->name);
    }

    tab_for_each_entry(st, &pkg->structs) {
        sb_addf(buf, "    %s = %s\n", st->name, st->name);
    }

    iopc_pystup_dump_fold_end_extra(buf);
}

/* }}} */
/* {{{ Import */

static void t_iopc_pystub_dump_import(sb_t *buf, const iopc_pkg_t *dep,
                                      qh_t(lstr) *imported)
{
    SB_1k(py_mod);
    lstr_t pkg_name;
    uint32_t pos;

    iopc_pystub_dump_py_mod_name(&py_mod, dep->name);
    pkg_name = LSTR_SB_V(&py_mod);

    pos = qh_put(lstr, imported, &pkg_name, 0);
    if (pos & QHASH_COLLISION) {
        return;
    }
    imported->keys[pos] = t_lstr_dup(pkg_name);

    sb_addf(buf, "import %*pM\n", LSTR_FMT_ARG(pkg_name));
}

static void iopc_pystub_dump_imports(sb_t *buf, iopc_pkg_t *pkg)
{
    t_scope;
    qh_t(lstr) imported;
    qv_t(iopc_pkg) t_deps;
    qv_t(iopc_pkg) t_weak_deps;
    qv_t(iopc_pkg) i_deps;

    t_qh_init(lstr, &imported, 0);
    t_qv_init(&t_deps, 0);
    t_qv_init(&t_weak_deps, 0);
    t_qv_init(&i_deps, 0);

    iopc_pkg_get_deps(pkg, 0, &t_deps, &t_weak_deps, &i_deps);

    tab_for_each_entry(dep, &t_deps) {
        t_iopc_pystub_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &t_weak_deps) {
        t_iopc_pystub_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &i_deps) {
        t_iopc_pystub_dump_import(buf, dep, &imported);
    }
    sb_adds(buf, "\n\n");
}

/* }}} */
/* {{{ Public API */

int iopc_do_pystub(iopc_pkg_t *pkg, const char *outdir)
{
    SB_1k(py_mod);
    SB_8k(buf);
    char path[PATH_MAX];

    /* Unlike other languages output, put all the stubs in the same output
     * directory without hierarchy. */
    if (mkdir_p(outdir, 0777) < 0) {
        throw_error("cannot create directory `%s`: %m", outdir);
    }
    iopc_pystub_dump_py_mod_name(&py_mod, pkg->name);
    snprintf(path, sizeof(path), "%s/%*pM.pyi", outdir, SB_FMT_ARG(&py_mod));

    sb_adds(&buf, STUB_HEADER);
    iopc_pystub_dump_imports(&buf, pkg);

    iopc_pystub_dump_enums(&buf, pkg);
    iopc_pystub_dump_structs(&buf, pkg);
    iopc_pystub_dump_ifaces(&buf, pkg);
    iopc_pystub_dump_modules(&buf, pkg);
    iopc_pystub_dump_package(&buf, pkg);

    return iopc_write_file(&buf, path);
}

/* }}} */
