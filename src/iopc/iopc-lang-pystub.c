/***************************************************************************/
/*                                                                         */
/* Copyright 2025 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include <lib-common/unix.h>
#include "iopc.h"
#include "iopc-internal.h"

/* {{{ Helpers */

#define STUB_HEADER \
    "#***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****\n"     \
    "# pylint: disable=all\n"                                                \
    "\n"                                                                     \
    "import typing\n"                                                        \
    "import typing_extensions\n"                                             \
    "import iopy\n"                                                          \
    "\n"

static void iopc_pystub_dump_py_mod_name(sb_t *buf, const iopc_path_t *path)
{
    tab_for_each_entry(bit, &path->bits) {
        sb_addf(buf, "%s_", bit);
    }
    sb_adds(buf, "_iop");
}

static void iopc_pystup_dump_fold_begin(sb_t *buf, const char *fold_name)
{
    sb_addf(buf, "# {""{{ %s\n", fold_name);
}

static void iopc_pystup_dump_fold_begin_extra(sb_t *buf,
                                              const char *fold_name)
{
    iopc_pystup_dump_fold_begin(buf, fold_name);
    sb_adds(buf, "\n\n");
}

static void iopc_pystup_dump_fold_end(sb_t *buf)
{
    sb_adds(buf, "# }""}}\n");
}

static void iopc_pystup_dump_fold_end_extra(sb_t *buf)
{
    sb_adds(buf, "\n\n");
    iopc_pystup_dump_fold_end(buf);
}

static void iopc_pystub_dump_package_member(sb_t *buf, const iopc_pkg_t *pkg,
                                            const iopc_pkg_t *member_pkg,
                                            const iopc_path_t *member_path,
                                            const char *member_name)
{
    if (pkg != member_pkg) {
        assert(member_path->bits.len);
        iopc_pystub_dump_py_mod_name(buf, member_path);
        sb_addc(buf, '.');
    }
    sb_adds(buf, member_name);
}

/* }}} */
/* {{{ Enum */

static void iopc_pystub_dump_enum(sb_t *buf, const iopc_pkg_t *pkg,
                                  const iopc_enum_t *en)
{
    iopc_pystup_dump_fold_begin_extra(buf, en->name);

    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s(iopy.Enum):\n", en->name);
    sb_adds(buf, "    pass\n");

    sb_addf(buf, "\n\n%s_ParamType = typing.Union[%s, int, str]\n",
            en->name, en->name);

    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_enums(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(en, &pkg->enums) {
        iopc_pystub_dump_enum(buf, pkg, en);
    }
}

/* }}} */
/* {{{ Struct/Union */

static void iopc_pystub_dump_field_basetype(sb_t *buf, const iopc_pkg_t *pkg,
                                            const iopc_field_t *field,
                                            bool is_param_type)
{
    switch (field->kind) {
    case IOP_T_I8:
    case IOP_T_U8:
    case IOP_T_I16:
    case IOP_T_U16:
    case IOP_T_I32:
    case IOP_T_U32:
    case IOP_T_I64:
    case IOP_T_U64:
        sb_adds(buf, "int");
        break;

    case IOP_T_BOOL:
        sb_adds(buf, "bool");
        break;

    case IOP_T_DOUBLE:
        sb_adds(buf, "float");
        break;

    case IOP_T_VOID:
        if (field->repeat == IOP_R_REQUIRED) {
            sb_adds(buf, "typing.Any");
        } else {
            sb_adds(buf, "None");
        }
        break;

    case IOP_T_STRING:
    case IOP_T_XML:
        if (is_param_type) {
            sb_adds(buf, "typing.Union[str, bytes]");
        } else {
            sb_adds(buf, "str");
        }
        break;

    case IOP_T_DATA:
        if (is_param_type) {
            sb_adds(buf, "typing.Union[bytes, str]");
        } else {
            sb_adds(buf, "bytes");
        }
        break;

    case IOP_T_STRUCT:
    case IOP_T_UNION:
    case IOP_T_ENUM:
        iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                        field->type_path, field->type_name);
        if (is_param_type) {
            sb_adds(buf, "_ParamType");
        }
        break;
    }
}

static void iopc_pystub_dump_field_type(sb_t *buf, const iopc_pkg_t *pkg,
                                        const iopc_field_t *field,
                                        bool is_param_type)
{
    switch (field->repeat) {
    case IOP_R_OPTIONAL:
        if (is_param_type) {
            sb_adds(buf, "typing.Optional[");
        } else {
            sb_adds(buf, "iopy.IopOptField[");
        }
        break;

    case IOP_R_REPEATED:
        if (is_param_type) {
            sb_adds(buf, "typing.Union[typing.Sequence[");
        } else {
            sb_adds(buf, "list[");
        }
        break;

    case IOP_R_DEFVAL:
    case IOP_R_REQUIRED:
        break;
    }

    iopc_pystub_dump_field_basetype(buf, pkg, field, is_param_type);

    switch (field->repeat) {
    case IOP_R_OPTIONAL:
        sb_adds(buf, "]");
        break;

    case IOP_R_REPEATED:
        if (is_param_type) {
            sb_adds(buf, "], ");
            iopc_pystub_dump_field_basetype(buf, pkg, field, is_param_type);
        }
        sb_adds(buf, "]");
        break;

    case IOP_R_DEFVAL:
    case IOP_R_REQUIRED:
        break;
    }
}

static void
iopc_pystub_dump_fields(sb_t *buf, const iopc_pkg_t *pkg,
                        const iopc_struct_t *st)
{
    if (st->fields.len) {
        tab_for_each_entry(field, &st->fields) {
            sb_addf(buf, "    %s: ", field->name);
            iopc_pystub_dump_field_type(buf, pkg, field, false);
            sb_adds(buf, "\n");
        }
        sb_adds(buf, "\n");
    }
}

static void iopc_pystub_dump_common_inits(sb_t *buf, const char *st_name)
{
    sb_addf(
        buf,
        "    @typing.overload\n"
        "    def __init__(\n"
        "            self, *,\n"
        "            _json: typing.Union[str, bytes],\n"
        "            _ignore_unknown: bool = False,\n"
        "            _forbid_private: bool = False,\n"
        "            _use_c_case: bool = False,\n"
        "    ) -> None: ...\n"
        "\n"
        "    @typing.overload\n"
        "    def __init__(\n"
        "            self, *,\n"
        "            _yaml: typing.Union[str, bytes],\n"
        "            _ignore_unknown: bool = False,\n"
        "            _forbid_private: bool = False,\n"
        "    ) -> None: ...\n"
        "\n"
        "    @typing.overload\n"
        "    def __init__(\n"
        "            self, *,\n"
        "            _xml: typing.Union[str, bytes],\n"
        "            _ignore_unknown: bool = False,\n"
        "            _forbid_private: bool = False,\n"
        "    ) -> None: ...\n"
        "\n"
        "    @typing.overload\n"
        "    def __init__(\n"
        "            self, *,\n"
        "            _hex: typing.Union[str, bytes],\n"
        "            _forbid_private: bool = False,\n"
        "    ) -> None: ...\n"
        "\n"
        "    @typing.overload\n"
        "    def __init__(\n"
        "            self, *,\n"
        "            _bin: typing.Union[str, bytes],\n"
        "            _forbid_private: bool = False,\n"
        "    ) -> None: ...\n"
        "\n"
        "    @typing.overload\n"
        "    def __init__(self, obj: %s_ParamType, /) -> None: ...\n"
        "\n",
        st_name
    );
}

static void iopc_pystub_dump_to_dict(sb_t *buf, const char *st_name)
{
    sb_addf(
        buf,
        "    def to_dict( # type: ignore[override]\n"
        "            self, skip_private: typing.Optional[bool] = None,\n"
        "            skip_default: typing.Optional[bool] = None,\n"
        "            skip_empty_arrays: typing.Optional[bool] = None,\n"
        "            skip_empty_structs: typing.Optional[bool] = None,\n"
        "            skip_class_names: typing.Optional[bool] = None,\n"
        "            skip_optional_class_names: typing.Optional[bool]"
        " = None,\n"
        "            minimal: typing.Optional[bool] = None\n"
        "    ) -> %s_DictType: ...\n\n",
        st_name);
}

/* }}} */
/* {{{ Struct */

static bool
iopc_pystub_field_dict_is_optional(const iopc_field_t *field)
{
    if (field->repeat != IOP_R_REQUIRED) {
        /* IOP field definition is not required. */
        return true;
    }

    if (field->kind == IOP_T_VOID) {
        /* IOP Void type should always be optional. */
        return true;
    }

    if (field->kind == IOP_T_STRUCT) {
        /* Check that all the fields of a struct/class are optional.
         *
         * XXX: Unlike iop_struct_is_optional(), we cannot consider the class
         * as required for abstract classes since '_class' is always an
         * optional dict type field.
         */
        const iopc_struct_t *st = field->struct_def;

        do {
            tab_for_each_entry(st_field, &st->fields) {
                if (!iopc_pystub_field_dict_is_optional(st_field)) {
                    return false;
                }
            }
            st = (iopc_is_class(st->type) && st->extends.len) ?
                st->extends.tab[0]->st : NULL;
        } while (st);

        /* All fields are optionals. */
        return true;
    }

    return false;
}

static void
iopc_pystub_dump_struct_dict_type(sb_t *buf, const iopc_pkg_t *pkg,
                                  const iopc_struct_t *st,
                                  const char *st_name)
{
    t_scope;
    qh_t(cptr) req_fields;
    bool has_fields;

    t_qh_init(cptr, &req_fields, st->fields.len);

    /* Required fields */
    sb_addf(buf, "class %s_required_DictType(typing.TypedDict):\n", st_name);

    has_fields = false;
    tab_for_each_entry(field, &st->fields) {
        if (iopc_pystub_field_dict_is_optional(field)) {
            continue;
        }
        qh_add(cptr, &req_fields, field);
        has_fields = true;
        sb_addf(buf, "    %s: ", field->name);
        iopc_pystub_dump_field_type(buf, pkg, field, true);
        sb_adds(buf, "\n");
    }

    if (!has_fields) {
        sb_adds(buf, "    pass\n");
    }

    sb_adds(buf, "\n\n");

    /* Optional fields */
    sb_addf(buf, "class %s_optional_DictType(typing.TypedDict, "
            "total=False):\n", st_name);

    if (iopc_is_class(st->type) && !st->extends.len) {
        /* Root class, add '_class' field.
         *
         * Ideally, we should have "root" '_class: str' field and have literal
         * '_class: Literal[""]' field with the IOP full path for each class.
         *
         * Unfortunately, it is not possible in Python to have inheritance on
         * TypedDict, and restrict the literal value on each level, and
         * discriminate on this value, and have it optional or not
         * depending on if we want to use Unpack or not.
         *
         * Currently, the best thing is to trust the user that the '_class'
         * value is valid at runtime (like we did before).
         * What we could do is use 'Annotated' and use a Mypy plugin, but
         * this is complicated.
         *
         * See
         * https://github.com/python/typing/issues/1467
         * https://discuss.python.org/t/pep-589-inheritance-rules-and-typing-literal-pep-586/7721/2
         */
        sb_adds(buf, "    _class: typing.Optional[str]\n");
    }

    has_fields = false;
    tab_for_each_entry(field, &st->fields) {
        if (qh_find(cptr, &req_fields, field) >= 0) {
            /* Not an optional field */
            continue;
        }
        has_fields = true;
        sb_addf(buf, "    %s: ", field->name);
        iopc_pystub_dump_field_type(buf, pkg, field, true);
        sb_adds(buf, "\n");
    }

    if (!has_fields) {
        sb_adds(buf, "    pass\n");
    }

    sb_adds(buf, "\n\n");

    /* Struct dict field */
    sb_addf(buf, "class %s_DictType(", st_name);

    if (iopc_is_class(st->type) && st->extends.len) {
        /* Inherit parent dict type */
        const iopc_pkg_t *parent_pkg = st->extends.tab[0]->pkg;
        const iopc_struct_t *parent = st->extends.tab[0]->st;

        iopc_pystub_dump_package_member(buf, pkg, parent_pkg,
                                        parent_pkg->name, parent->name);
        sb_adds(buf, "_DictType, ");
    }

    sb_addf(buf, "%s_required_DictType, %s_optional_DictType):\n"
            "    pass\n\n\n", st_name, st_name);
}

static void iopc_pystub_dump_struct_inits(sb_t *buf, const char *st_name)
{
    sb_addf(
        buf,
        "    @typing.overload\n"
        "    def __init__(self, "
        "**kwargs: typing_extensions.Unpack[%s_DictType]) -> None: ...\n"
        "\n",
        st_name
    );
}

static void
iopc_pystub_dump_struct_intern(sb_t *buf, const iopc_pkg_t *pkg,
                               const iopc_struct_t *st, const char *st_name)
{
    assert(st_name);

    iopc_pystub_dump_struct_dict_type(buf, pkg, st, st_name);

    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s(", st_name);
    if (iopc_is_class(st->type) && st->extends.len) {
        const iopc_pkg_t *parent_pkg = st->extends.tab[0]->pkg;
        const iopc_struct_t *parent = st->extends.tab[0]->st;

        iopc_pystub_dump_package_member(buf, pkg, parent_pkg,
                                        parent_pkg->name, parent->name);
    } else {
        sb_adds(buf, "iopy.Struct");
    }
    sb_adds(buf, "):\n");

    iopc_pystub_dump_fields(buf, pkg, st);

    iopc_pystub_dump_common_inits(buf, st_name);
    iopc_pystub_dump_struct_inits(buf, st_name);
    iopc_pystub_dump_to_dict(buf, st_name);

    sb_addf(buf, "\n%s_ParamType = typing.Union[%s, %s_DictType]\n",
            st_name, st_name, st_name);
}

static void iopc_pystub_dump_struct(sb_t *buf, const iopc_pkg_t *pkg,
                                    const iopc_struct_t *st)
{
    const char *st_name = st->name;

    iopc_pystup_dump_fold_begin_extra(buf, st_name);
    iopc_pystub_dump_struct_intern(buf, pkg, st, st_name);
    iopc_pystup_dump_fold_end_extra(buf);
}

/* }}} */
/* {{{ Union */

typedef struct iopc_pystub_union_ambiguous_type_t {
    bool is_ambiguous;
} iopc_pystub_union_ambiguous_type_t;

qm_kvec_t(iopc_pystub_union_ambiguous_type, lstr_t,
          iopc_pystub_union_ambiguous_type_t, qhash_lstr_hash,
          qhash_lstr_equal);

static void t_iopc_pystub_add_ambiguous_type(
    lstr_t py_type, bool is_parent_cls,
    qm_t(iopc_pystub_union_ambiguous_type) *types_map)
{
    uint32_t pos;
    iopc_pystub_union_ambiguous_type_t ambiguous_type = {
        .is_ambiguous = is_parent_cls,
    };

    pos = qm_put(iopc_pystub_union_ambiguous_type, types_map, &py_type,
                 ambiguous_type, 0);
    if (pos & QHASH_COLLISION) {
        pos ^= QHASH_COLLISION;
        types_map->values[pos].is_ambiguous = true;
    }
}

static void
t_iopc_pystub_add_ambiguous_type_parents(
    const iopc_pkg_t *pkg, const iopc_struct_t *st,
    qm_t(iopc_pystub_union_ambiguous_type) *types_map)
{
    SB_1k(sb);
    const iopc_pkg_t *parent_pkg;
    const iopc_struct_t *parent;

    if (!iopc_is_class(st->type) || !st->extends.len) {
        return;
    }

    parent_pkg = st->extends.tab[0]->pkg;
    parent = st->extends.tab[0]->st;

    iopc_pystub_dump_package_member(&sb, pkg, parent_pkg, parent_pkg->name,
                                    parent->name);
    sb_adds(&sb, "_ParamType");
    t_iopc_pystub_add_ambiguous_type(
        t_lstr_dup(LSTR_SB_V(&sb)), true, types_map);

    t_iopc_pystub_add_ambiguous_type_parents(pkg, parent, types_map);
}

static void
t_iopc_pystub_add_ambiguous_types_field(
    const iopc_pkg_t *pkg, const iopc_field_t *field,
    qm_t(iopc_pystub_union_ambiguous_type) *types_map)
{
    switch (field->kind) {
    case IOP_T_I8:
    case IOP_T_U8:
    case IOP_T_I16:
    case IOP_T_U16:
    case IOP_T_I32:
    case IOP_T_U32:
    case IOP_T_I64:
    case IOP_T_U64:
        t_iopc_pystub_add_ambiguous_type(LSTR("int"), false, types_map);
        break;

    case IOP_T_BOOL:
        t_iopc_pystub_add_ambiguous_type(LSTR("bool"), false, types_map);
        break;

    case IOP_T_DOUBLE:
        t_iopc_pystub_add_ambiguous_type(LSTR("float"), false, types_map);
        break;

    case IOP_T_VOID:
        t_iopc_pystub_add_ambiguous_type(LSTR("None"), false, types_map);
        break;

    case IOP_T_STRING:
    case IOP_T_XML:
    case IOP_T_DATA:
        t_iopc_pystub_add_ambiguous_type(LSTR("str"), false, types_map);
        t_iopc_pystub_add_ambiguous_type(LSTR("bytes"), false, types_map);
        break;

    case IOP_T_STRUCT:
        /* Recursively add the parent classes as ambiguous type so we don't
         * have the base and child type as unambiguous types in the end. */
        t_iopc_pystub_add_ambiguous_type_parents(
            pkg, field->struct_def, types_map);

        /* FALLTHROUGH */

    case IOP_T_UNION:
    case IOP_T_ENUM: {
        SB_1k(sb);

        iopc_pystub_dump_package_member(&sb, pkg, field->type_pkg,
                                        field->type_path, field->type_name);
        sb_adds(&sb, "_ParamType");
        t_iopc_pystub_add_ambiguous_type(
            t_lstr_dup(LSTR_SB_V(&sb)), false, types_map);
    } break;
    }
}

static qv_t(lstr) t_iopc_pystub_build_unambiguous_types(
    const iopc_pkg_t *pkg, const iopc_struct_t *st)
{
    qm_t(iopc_pystub_union_ambiguous_type) types_map;
    qv_t(lstr) res;

    /* List get all possible ambiguous types of the fields to the map. */
    t_qm_init(iopc_pystub_union_ambiguous_type, &types_map,
              st->fields.len * 2);
    tab_for_each_entry(field, &st->fields) {
        t_iopc_pystub_add_ambiguous_types_field(pkg, field, &types_map);
    }

    /* Get the python types of the unambiguous types. */
    t_qv_init(&res, qm_len(iopc_pystub_union_ambiguous_type, &types_map));
    qm_for_each_key_value_p(iopc_pystub_union_ambiguous_type, py_type,
                            ambiguous_type, &types_map)
    {
        if (!ambiguous_type->is_ambiguous) {
            qv_append(&res, py_type);
        }
    }

    return res;
}

static void
iopc_pystub_dump_union_dict_types(sb_t *buf, const iopc_pkg_t *pkg,
                                  const iopc_struct_t *st)
{
    const char *st_name = st->name;

    tab_for_each_entry(field, &st->fields) {
        sb_addf(buf, "class %s_%s_DictType(typing.TypedDict):\n",
                st_name, field->name);
        sb_addf(buf, "    %s: ",field->name);
        iopc_pystub_dump_field_type(buf, pkg, field, true);
        sb_adds(buf, "\n\n\n");
    }

    sb_addf(buf, "%s_DictType = typing.Union[", st_name);

    tab_for_each_pos(pos, &st->fields) {
        const iopc_field_t *field = st->fields.tab[pos];

        if (pos > 0) {
            sb_adds(buf, ", ");
        }

        sb_addf(buf, "%s_%s_DictType", st_name, field->name);
    }

    sb_adds(buf, "]\n\n\n");
}

static void
iopc_pystub_dump_union_unambiguous_type(sb_t *buf, const iopc_pkg_t *pkg,
                                        const iopc_struct_t *st,
                                        const qv_t(lstr) *unambiguous_types)
{
    const char *st_name = st->name;

    assert(unambiguous_types->len);

    sb_addf(buf, "%s_UnambiguousType = typing.Union[", st_name);

    tab_for_each_pos(pos, unambiguous_types) {
        lstr_t py_type = unambiguous_types->tab[pos];

        if (pos > 0) {
            sb_adds(buf, ", ");
        }
        sb_add_lstr(buf, py_type);
    }

    sb_adds(buf, "]\n\n\n");
}

static void iopc_pystub_dump_union_inits(sb_t *buf, const iopc_pkg_t *pkg,
                                         const iopc_struct_t *st)
{
    tab_for_each_entry(field, &st->fields) {
        sb_addf(
            buf,
            "    @typing.overload\n"
            "    def __init__(self, *, %s: " ,
            field->name
        );
        iopc_pystub_dump_field_type(buf, pkg, field, true);
        sb_adds(buf, ") -> None: ...\n\n");
    }
}

static void iopc_pystub_dump_union(sb_t *buf, const iopc_pkg_t *pkg,
                                   const iopc_struct_t *st)
{
    t_scope;
    const char *st_name = st->name;
    qv_t(lstr) unambiguous_types;

    /* Get the unambiguous types */
    unambiguous_types = t_iopc_pystub_build_unambiguous_types(pkg, st);

    /* Begin fold */
    iopc_pystup_dump_fold_begin_extra(buf, st_name);

    /* Dump dict types */
    iopc_pystub_dump_union_dict_types(buf, pkg, st);

    /* Dump unambigous types if any */
    if (unambiguous_types.len) {
        iopc_pystub_dump_union_unambiguous_type(buf, pkg, st,
                                                &unambiguous_types);
    }

    /* Begin class type */
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s(iopy.Union):\n", st_name);

    /* Dump fields */
    iopc_pystub_dump_fields(buf, pkg, st);

    /* Dump unpack inits */
    iopc_pystub_dump_common_inits(buf, st_name);
    iopc_pystub_dump_union_inits(buf, pkg, st);

    /* Dump methods */
    iopc_pystub_dump_to_dict(buf, st_name);

    /* Dump param class type */
    sb_addf(buf, "\n%s_ParamType = typing.Union[%s, %s_DictType",
            st_name, st_name, st_name);
    if (unambiguous_types.len) {
        sb_addf(buf, ", %s_UnambiguousType", st_name);
    }
    sb_adds(buf, "]\n");

    /* End fold */
    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_structs(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(st, &pkg->structs) {
        switch (st->type) {
        case STRUCT_TYPE_STRUCT:
        case STRUCT_TYPE_CLASS:
            iopc_pystub_dump_struct(buf, pkg, st);
            break;

        case STRUCT_TYPE_UNION:
            iopc_pystub_dump_union(buf, pkg, st);
            break;

        default:
            break;
        }
    }
}

/* }}} */
/* {{{ Rpc */

static void
iopc_pystub_dump_rpc_fun_struct(sb_t *buf, const iopc_pkg_t *pkg,
                                const iopc_iface_t *iface,
                                const iopc_fun_t *rpc, const char *type,
                                const iopc_fun_struct_t *fun_st)
{
    t_scope;
    const char *st_name = t_fmt("%s_%s_%s", iface->name, rpc->name, type);

    if (iopc_fun_struct_is_void(fun_st)) {
        sb_addf(buf, "%s: typing_extensions.TypeAlias = None\n", st_name);
    } else if (fun_st->is_anonymous) {
        iopc_pystub_dump_struct_intern(buf, pkg, fun_st->anonymous_struct,
                                       st_name);
        sb_adds(buf, "\n\n");
    } else {
        SB_1k(type_buf);

        iopc_pystub_dump_field_basetype(&type_buf, pkg,
                                        fun_st->existing_struct, false);
        sb_addf(buf, "%s = %*pM\n", st_name, SB_FMT_ARG(&type_buf));
        sb_addf(buf, "%s_DictType = %*pM_DictType\n", st_name,
                SB_FMT_ARG(&type_buf));
        sb_addf(buf, "%s_ParamType = %*pM_ParamType\n", st_name,
                SB_FMT_ARG(&type_buf));
    }
}

#define RPC_UNDERSCORE_KWARGS                                                \
    "        _timeout: typing.Optional[float] = None,\n"                     \
    "        _login: typing.Optional[str] = None,\n"                         \
    "        _group: typing.Optional[str] = None,\n"                         \
    "        _password: typing.Optional[str] = None,\n"                      \
    "        _kind: typing.Optional[str] = None,\n"                          \
    "        _workspace_id: typing.Optional[int] = None,\n"                  \
    "        _dealias: typing.Optional[bool] = None,\n"                      \
    "        _hdr: typing.Optional['ic__iop.Hdr'] = None"


static void iopc_pystub_dump_rpc_call_meth(sb_t *buf,
                                           const char *method_name,
                                           const iopc_pkg_t *pkg,
                                           const iopc_fun_t *rpc,
                                           const char *rpc_name,
                                           const char *res_type)
{
    t_scope;
    bool arg_is_void = iopc_fun_struct_is_void(&rpc->arg);
    bool arg_is_union;
    const char *arg_obj_type;

    arg_is_union = !arg_is_void && !rpc->arg.is_anonymous &&
                   rpc->arg.existing_struct->type == STRUCT_TYPE_UNION;

    arg_obj_type = arg_is_void ? "None" : t_fmt("%s_Arg_ParamType", rpc_name);

    sb_addf(
        buf,
        "\n"
        "    @typing.overload # type: ignore[override]\n"
        "    def %s(\n"
        "        self, obj: %s, /, *,\n"
        RPC_UNDERSCORE_KWARGS "\n"
        "    ) -> %s: ...\n",
        method_name, arg_obj_type, res_type);

    if (arg_is_void) {
        sb_addf(
            buf,
            "\n"
            "    @typing.overload\n"
            "    def %s(\n"
            "        self, *,\n"
            RPC_UNDERSCORE_KWARGS "\n"
            "    ) -> %s: ...\n",
            method_name, res_type);
    } else if (arg_is_union) {
        const iopc_struct_t *arg_union_st =
            rpc->arg.existing_struct->struct_def;

        tab_for_each_entry(field, &arg_union_st->fields) {
            sb_addf(
                buf,
                "\n"
                "    @typing.overload\n"
                "    def %s(\n"
                "        self, *,\n"
                RPC_UNDERSCORE_KWARGS "\n"
                "        %s: ",
                method_name, field->name);
            iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                            field->type_path,
                                            field->type_name);
            sb_addf(
                buf,
                "    ) -> %s: ...\n",
                res_type);
        }
    } else {
        sb_addf(
            buf,
            "\n"
            "    @typing.overload\n"
            "    def %s(\n"
            "        self, *,\n"
            RPC_UNDERSCORE_KWARGS ",\n"
            "        **kwargs: typing_extensions.Unpack[%s_Arg_DictType]\n"
            "    ) -> %s: ...\n",
            method_name, rpc_name, res_type);
    }
}

static void iopc_pystub_dump_rpc_call(sb_t *buf, const iopc_pkg_t *pkg,
                                      const iopc_fun_t *rpc,
                                      const char *rpc_name,
                                      const char *res_type)
{
    iopc_pystub_dump_rpc_call_meth(buf, "call", pkg, rpc, rpc_name, res_type);
    iopc_pystub_dump_rpc_call_meth(buf, "__call__", pkg, rpc, rpc_name,
                                   res_type);
}

static void iopc_pystub_dump_rpc_types(sb_t *buf, const iopc_pkg_t *pkg,
                                       const iopc_iface_t *iface,
                                       const iopc_fun_t *rpc)
{
    iopc_pystub_dump_rpc_fun_struct(buf, pkg, iface, rpc, "Arg", &rpc->arg);
    iopc_pystub_dump_rpc_fun_struct(buf, pkg, iface, rpc, "Res", &rpc->res);
    iopc_pystub_dump_rpc_fun_struct(buf, pkg, iface, rpc, "Exn", &rpc->exn);
}

static void iopc_pystub_dump_rpc_base(sb_t *buf, const iopc_fun_t *rpc,
                                      const char *rpc_name)
{
    bool arg_is_void = iopc_fun_struct_is_void(&rpc->arg);
    const char *arg_ignore = arg_is_void ? " # type: ignore[override]" : "";
    bool res_is_void = iopc_fun_struct_is_void(&rpc->res);
    const char *res_ignore = res_is_void ? " # type: ignore[override]" : "" ;
    bool exn_is_void = iopc_fun_struct_is_void(&rpc->exn);
    const char *exn_ignore = exn_is_void ? " # type: ignore[override]" : "";

    sb_addf(buf,
            "\n\n"
            "@typing.type_check_only\n"
            "class %s_RPCBase(iopy.RPCBase):\n"
            "    Arg: typing_extensions.TypeAlias = %s_Arg\n"
            "    Res: typing_extensions.TypeAlias = %s_Res\n"
            "    Exn: typing_extensions.TypeAlias = %s_Exn\n"
            "\n"
            "    def arg(self) -> type[%s_Arg]: ...%s\n"
            "    def res(self) -> type[%s_Res]: ...%s\n"
            "    def exn(self) -> type[%s_Exn]: ...%s\n",
            rpc_name,
            rpc_name, rpc_name, rpc_name,
            rpc_name, arg_ignore,
            rpc_name, res_ignore,
            rpc_name, exn_ignore);
}

static void iopc_pystub_dump_client_sync_rpc(sb_t *buf, const iopc_pkg_t *pkg,
                                             const iopc_fun_t *rpc,
                                             const char *rpc_name)
{
    t_scope;
    const char *res_type = t_fmt("%s_Res", rpc_name);

    sb_addf(buf,
            "\n\n"
            "@typing.type_check_only\n"
            "class %s_RPC(iopy.RPC, %s_RPCBase):\n",
            rpc_name, rpc_name);
    iopc_pystub_dump_rpc_call(buf, pkg, rpc, rpc_name, res_type);
}

static void iopc_pystub_dump_client_async_rpc(sb_t *buf,
                                              const iopc_pkg_t *pkg,
                                              const iopc_fun_t *rpc,
                                              const char *rpc_name)
{
    t_scope;
    const char *res_type = t_fmt("typing.Awaitable[%s_Res]", rpc_name);

    sb_addf(buf,
            "\n\n"
            "@typing.type_check_only\n"
            "class %s_AsyncRPC(iopy.AsyncRPC, %s_RPCBase):\n",
            rpc_name, rpc_name);
    iopc_pystub_dump_rpc_call(buf, pkg, rpc, rpc_name, res_type);
}

static void iopc_pystub_dump_server_rpc(sb_t *buf, const iopc_pkg_t *pkg,
                                        const iopc_fun_t *rpc,
                                        const char *rpc_name)
{
    sb_addf(buf,
            "\n\n"
            "@typing.type_check_only\n"
            "class %s_RPCServer(iopy.RPCServer, %s_RPCBase):\n"
            "    RpcArgs: typing_extensions.TypeAlias"
            " = iopy.RPCArgs[%s_Arg, %s_Res, %s_Exn]\n"
            "    RpcRes: typing_extensions.TypeAlias"
            " = typing.Union[%s_Res, %s_Exn]\n"
            "\n"
            "    @property # type: ignore[override]\n"
            "    def impl(self) -> typing.Optional[\n"
            "        iopy.RPCServerImplCb[%s_Arg, %s_Res, %s_Exn]\n"
            "    ]: ...\n"
            "\n"
            "    @impl.setter\n"
            "    def impl(self, value: typing.Optional[\n"
            "        iopy.RPCServerImplCb[%s_Arg, %s_Res, %s_Exn]\n"
            "    ]) -> None: ...\n",
            rpc_name, rpc_name,
            rpc_name, rpc_name, rpc_name,
            rpc_name, rpc_name,
            rpc_name, rpc_name, rpc_name,
            rpc_name, rpc_name, rpc_name);
}

static void iopc_pystub_dump_rpc(sb_t *buf, const iopc_pkg_t *pkg,
                                 const iopc_iface_t *iface,
                                 const iopc_fun_t *rpc)
{
    t_scope;
    const char *rpc_name = t_fmt("%s_%s", iface->name, rpc->name);

    iopc_pystup_dump_fold_begin_extra(buf, rpc_name);

    iopc_pystub_dump_rpc_types(buf, pkg, iface, rpc);

    iopc_pystub_dump_rpc_base(buf, rpc, rpc_name);
    iopc_pystub_dump_client_sync_rpc(buf, pkg, rpc, rpc_name);
    iopc_pystub_dump_client_async_rpc(buf, pkg, rpc, rpc_name);
    iopc_pystub_dump_server_rpc(buf, pkg, rpc, rpc_name);

    iopc_pystup_dump_fold_end_extra(buf);
}

/* }}} */
/* {{{ Interface */

static void iopc_pystub_dump_iface(sb_t *buf, const iopc_pkg_t *pkg,
                                   const iopc_iface_t *iface)
{
    iopc_pystup_dump_fold_begin(buf, iface->name);

    tab_for_each_entry(rpc, &iface->funs) {
        iopc_pystub_dump_rpc(buf, pkg, iface, rpc);
    }

    sb_adds(buf, "\n\n");

    /* Sync RPCs */
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_Iface(iopy.Iface):\n", iface->name);
    if (iface->funs.len) {
        tab_for_each_entry(rpc, &iface->funs) {
            sb_addf(buf, "    %s: %s_%s_RPC\n", rpc->name, iface->name,
                    rpc->name);
        }
    } else {
        sb_adds(buf, "    pass\n");
    }
    sb_adds(buf, "\n\n");

    /* Async RPCs */
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_AsyncIface(iopy.Iface):\n", iface->name);
    if (iface->funs.len) {
        tab_for_each_entry(rpc, &iface->funs) {
            sb_addf(buf, "    %s: %s_%s_AsyncRPC\n", rpc->name, iface->name,
                    rpc->name);
        }
    } else {
        sb_adds(buf, "    pass\n");
    }
    sb_adds(buf, "\n\n");

    /* Server RPCs */
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_IfaceServer(iopy.Iface):\n", iface->name);
    if (iface->funs.len) {
        tab_for_each_entry(rpc, &iface->funs) {
            sb_addf(buf, "    %s: %s_%s_RPCServer\n", rpc->name, iface->name,
                    rpc->name);
        }
    } else {
        sb_adds(buf, "    pass\n");
    }
    sb_adds(buf, "\n\n");

    iopc_pystup_dump_fold_end(buf);
}

static void iopc_pystub_dump_ifaces(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(iface, &pkg->ifaces) {
        switch (iface->type) {
        case IFACE_TYPE_IFACE:
            iopc_pystub_dump_iface(buf, pkg, iface);
            break;

        default:
            break;
        }
    }
}

/* }}} */
/* {{{ Module */

static void iopc_pystub_dump_module(sb_t *buf, const iopc_pkg_t *pkg,
                                    const iopc_struct_t *mod)
{
    const char *mod_name = mod->name;

    iopc_pystup_dump_fold_begin_extra(buf, mod_name);

    /* Sync module */
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_Module(iopy.Module):\n", mod_name);
    if (mod->fields.len) {
        tab_for_each_entry(field, &mod->fields) {
            sb_addf(buf, "    %s: ", field->name);
            iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                            field->type_path,
                                            field->type_name);
            sb_adds(buf, "_Iface\n");
        }
    } else {
        sb_adds(buf, "    pass\n");
    }

    /* Async module */
    sb_adds(buf, "\n\n");
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_AsyncModule(iopy.Module):\n", mod_name);
    if (mod->fields.len) {
        tab_for_each_entry(field, &mod->fields) {
            sb_addf(buf, "    %s: ", field->name);
            iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                            field->type_path,
                                            field->type_name);
            sb_adds(buf, "_AsyncIface\n");
        }
    } else {
        sb_adds(buf, "    pass\n");
    }

    /* Server module */
    sb_adds(buf, "\n\n");
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_ModuleServer(iopy.Module):\n", mod_name);
    if (mod->fields.len) {
        tab_for_each_entry(field, &mod->fields) {
            sb_addf(buf, "    %s: ", field->name);
            iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                            field->type_path,
                                            field->type_name);
            sb_adds(buf, "_IfaceServer\n");
        }
    } else {
        sb_adds(buf, "    pass\n");
    }

    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_modules(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(mod, &pkg->modules) {
        iopc_pystub_dump_module(buf, pkg, mod);
    }
}

/* }}} */
/* {{{ Package */

static void iopc_pystub_dump_package(sb_t *buf, const iopc_pkg_t *pkg)
{
    iopc_pystup_dump_fold_begin_extra(buf, "Package");

    sb_adds(buf, "@typing.type_check_only\n");
    sb_adds(buf, "class Interfaces(iopy.Interfaces):\n");

    if (pkg->ifaces.len) {
        tab_for_each_entry(iface, &pkg->ifaces) {
            switch (iface->type) {
            case IFACE_TYPE_IFACE:
                sb_addf(buf, "    %s = %s_Iface\n", iface->name, iface->name);
                break;

            default:
                break;
            }
        }
    } else {
        sb_adds(buf, "    pass\n");
    }

    sb_adds(buf, "\n\n");

    sb_adds(buf, "@typing.type_check_only\n");
    sb_adds(buf, "class Package(iopy.Package):\n");

    sb_adds(buf, "    interfaces: Interfaces\n\n");

    tab_for_each_entry(en, &pkg->enums) {
        sb_addf(buf, "    %s = %s\n", en->name, en->name);
    }

    tab_for_each_entry(st, &pkg->structs) {
        sb_addf(buf, "    %s = %s\n", st->name, st->name);
    }

    iopc_pystup_dump_fold_end_extra(buf);
}

/* }}} */
/* {{{ Import */

static void t_iopc_pystub_dump_import(sb_t *buf, const iopc_pkg_t *dep,
                                      qh_t(lstr) *imported)
{
    SB_1k(py_mod);
    lstr_t pkg_name;
    uint32_t pos;

    iopc_pystub_dump_py_mod_name(&py_mod, dep->name);
    pkg_name = LSTR_SB_V(&py_mod);

    pos = qh_put(lstr, imported, &pkg_name, 0);
    if (pos & QHASH_COLLISION) {
        return;
    }
    imported->keys[pos] = t_lstr_dup(pkg_name);

    sb_addf(buf, "import %*pM\n", LSTR_FMT_ARG(pkg_name));
}

static void iopc_pystub_dump_imports(sb_t *buf, iopc_pkg_t *pkg)
{
    t_scope;
    qh_t(lstr) imported;
    qv_t(iopc_pkg) t_deps;
    qv_t(iopc_pkg) t_weak_deps;
    qv_t(iopc_pkg) i_deps;

    t_qh_init(lstr, &imported, 0);
    t_qv_init(&t_deps, 0);
    t_qv_init(&t_weak_deps, 0);
    t_qv_init(&i_deps, 0);

    if (pkg->ifaces.len) {
        sb_adds(buf, "import ic__iop\n");
    }

    iopc_pkg_get_deps(pkg, 0, &t_deps, &t_weak_deps, &i_deps);

    tab_for_each_entry(dep, &t_deps) {
        t_iopc_pystub_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &t_weak_deps) {
        t_iopc_pystub_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &i_deps) {
        t_iopc_pystub_dump_import(buf, dep, &imported);
    }
    sb_adds(buf, "\n\n");
}

/* }}} */
/* {{{ Public API */

int iopc_do_pystub(iopc_pkg_t *pkg, const char *outdir)
{
    SB_1k(py_mod);
    SB_8k(buf);
    char path[PATH_MAX];

    /* Unlike other languages output, put all the stubs in the same output
     * directory without hierarchy. */
    if (mkdir_p(outdir, 0777) < 0) {
        throw_error("cannot create directory `%s`: %m", outdir);
    }
    iopc_pystub_dump_py_mod_name(&py_mod, pkg->name);
    snprintf(path, sizeof(path), "%s/%*pM.pyi", outdir, SB_FMT_ARG(&py_mod));

    sb_adds(&buf, STUB_HEADER);
    iopc_pystub_dump_imports(&buf, pkg);

    iopc_pystub_dump_enums(&buf, pkg);
    iopc_pystub_dump_structs(&buf, pkg);
    iopc_pystub_dump_ifaces(&buf, pkg);
    iopc_pystub_dump_modules(&buf, pkg);
    iopc_pystub_dump_package(&buf, pkg);

    return iopc_write_file(&buf, path);
}

/* }}} */
