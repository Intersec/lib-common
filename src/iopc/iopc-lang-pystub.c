/***************************************************************************/
/*                                                                         */
/* Copyright 2025 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include "iopc.h"
#include "iopc-internal.h"

static qv_t(str) pp_g;

#define RO_WARN \
    "/***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****/\n"

static const char *pp_under(iopc_path_t *path)
{
    SB_1k(buf);
    char *res;

    tab_for_each_entry(bit, &path->bits) {
        sb_addf(&buf, "%s__", bit);
    }
    sb_shrink(&buf, 2);
    qv_append(&pp_g, res = sb_detach(&buf, NULL));
    return res;
}

static const char *pp_path(iopc_path_t *path)
{
    SB_1k(buf);
    char *res;

    tab_for_each_entry(bit, &path->bits) {
        sb_addf(&buf, "%s/", bit);
    }
    sb_shrink(&buf, 1);
    qv_append(&pp_g, res = sb_detach(&buf, NULL));
    return res;
}

static const char *pp_dot(iopc_path_t *path)
{
    SB_1k(buf);
    char *res;

    tab_for_each_entry(bit, &path->bits) {
        sb_addf(&buf, "%s.", bit);
    }
    sb_shrink(&buf, 1);
    qv_append(&pp_g, res = sb_detach(&buf, NULL));
    return res;
}

static void iopc_pystub_dump_import(sb_t *buf, const iopc_pkg_t *dep,
                                    qh_t(cstr) *imported)
{
    const char *import_name = pp_under(dep->name);

    if (qh_put(cstr, imported, import_name, 0) & QHASH_COLLISION) {
        return;
    }

    sb_addf(buf, "import * as %s from \"iop/%s.iop\";\n",
            pp_under(dep->name), pp_path(dep->name));
}

static void iopc_pystub_dump_imports(sb_t *buf, iopc_pkg_t *pkg)
{
    qh_t(cstr) imported;
    qv_t(iopc_pkg) t_deps;
    qv_t(iopc_pkg) t_weak_deps;
    qv_t(iopc_pkg) i_deps;

    qh_init(cstr, &imported);
    qv_inita(&t_deps, 1024);
    qv_inita(&t_weak_deps, 1024);
    qv_inita(&i_deps, 1024);

    iopc_pkg_get_deps(pkg, 0, &t_deps, &t_weak_deps, &i_deps);

    tab_for_each_entry(dep, &t_deps) {
        iopc_pystub_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &t_weak_deps) {
        iopc_pystub_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &i_deps) {
        iopc_pystub_dump_import(buf, dep, &imported);
    }

    qv_wipe(&t_deps);
    qv_wipe(&t_weak_deps);
    qv_wipe(&i_deps);
    qh_wipe(cstr, &imported);
}

static void iopc_pystub_dump_package_member(sb_t *buf, const iopc_pkg_t *pkg,
                                            const iopc_pkg_t *member_pkg,
                                            iopc_path_t *member_path,
                                            const char *member_name)
{
    if (pkg != member_pkg) {
        assert (member_path->bits.len);
        sb_adds(buf, pp_under(member_path));
        sb_addc(buf, '.');
    }
    sb_adds(buf, member_name);
}

static void iopc_pystub_dump_enum(sb_t *buf, const char *indent,
                                  const iopc_pkg_t *pkg,
                                  const iopc_enum_t *en)
{
    bool is_strict = false;
    bool first = false;

    tab_for_each_entry(attr, &en->attrs) {
        if (attr->desc->id == IOPC_ATTR_STRICT) {
            is_strict = true;
            break;
        }
    }

    sb_addf(buf, "\n%sexport type %s_Int = ", indent, en->name);
    first = true;
    tab_for_each_entry(field, &en->values) {
        if (!first) {
            sb_addf(buf, "\n%s    | ", indent);
        }
        sb_addf(buf, "%d", field->value);
        first = false;
    }
    sb_adds(buf, ";\n");

    sb_addf(buf, "%sexport type %s_Str = ", indent, en->name);
    first = true;
    tab_for_each_entry(field, &en->values) {
        if (!first) {
            sb_addf(buf, "\n%s    | ", indent);
        }
        sb_addf(buf, "'%s'", field->name);
        first = false;
    }
    sb_adds(buf, ";\n");

    if (is_strict) {
        sb_addf(buf, "%sexport type %s = %s_Str;\n",
                indent, en->name, en->name);
    } else {
        sb_addf(buf, "%sexport type %s = %s_Str;\n",
                indent, en->name, en->name);
    }
}

static void iopc_pystub_dump_enums(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(en, &pkg->enums) {
        iopc_pystub_dump_enum(buf, "", pkg, en);
    }
}

static void iopc_pystub_dump_field_basetype(sb_t *buf, const iopc_pkg_t *pkg,
                                             const iopc_field_t *field,
                                             const char * nullable suffix)
{
    switch (field->kind) {
      case IOP_T_I8: sb_adds(buf, "number"); break;
      case IOP_T_U8: sb_adds(buf, "number"); break;
      case IOP_T_I16: sb_adds(buf, "number"); break;
      case IOP_T_U16: sb_adds(buf, "number"); break;
      case IOP_T_I32: sb_adds(buf, "number"); break;
      case IOP_T_U32: sb_adds(buf, "number"); break;
      case IOP_T_I64: sb_adds(buf, "number | string"); break;
      case IOP_T_U64: sb_adds(buf, "number | string"); break;
      case IOP_T_BOOL: sb_adds(buf, "boolean"); break;
      case IOP_T_DOUBLE: sb_adds(buf, "number"); break;
      case IOP_T_VOID: sb_adds(buf, "null"); break;

      case IOP_T_STRING: case IOP_T_XML:
      case IOP_T_DATA:
        sb_adds(buf, "string");
        break;

      case IOP_T_STRUCT:
        iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                        field->type_path, field->type_name);
        if (suffix) {
            sb_adds(buf, suffix);
        }
        break;

      case IOP_T_UNION: case IOP_T_ENUM:
        iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                        field->type_path, field->type_name);
        if (field->kind == IOP_T_UNION && suffix) {
            sb_adds(buf, suffix);
        } else
        if (suffix) {
            sb_adds(buf, "_Str");
        }
        break;
    }
}

enum {
    OBJECT_FIELD = 1 << 0,
    DEFVAL_AS_OPT = 1 << 1,
    USE_MODEL = 1 << 2,
    USE_PARAM = 1 << 3,
    IN_UNION = 1 << 4,
};

static void iopc_pystub_dump_field_type(sb_t *buf, const iopc_pkg_t *pkg,
                                        const iopc_field_t *field,
                                        unsigned flags)
{
    const char *suffix = (flags & USE_PARAM) ? "_ModelParam" :
                         (flags & USE_MODEL) ? "_Model" : NULL;

    if (field->kind != IOP_T_STRUCT && field->kind != IOP_T_UNION) {
        flags &= ~USE_MODEL;
    }
    switch (field->repeat) {
      case IOP_R_REPEATED:
        if (!(flags & USE_MODEL)) {
            sb_adds(buf, "Array<");
        } else {
            suffix = "_Collection";
        }
        break;

      default:
        break;
    }

    iopc_pystub_dump_field_basetype(buf, pkg, field, suffix);

    switch (field->repeat) {
      case IOP_R_REPEATED:
        if (!(flags & USE_MODEL)) {
            if ((flags & USE_PARAM)) {
                sb_adds(buf, " | ");
                iopc_pystub_dump_field_basetype(buf, pkg, field, "_Model");
            }
            sb_addc(buf, '>');
        }
        break;

      case IOP_R_DEFVAL:
        if (!(flags & DEFVAL_AS_OPT)) {
            break;
        }
        /* FALLTHROUGH */

      case IOP_R_OPTIONAL:
        if (!(flags & OBJECT_FIELD)) {
            sb_adds(buf, " | undefined");
        }
        break;

      default:
        break;
    }
}

static void iopc_pystub_dump_field(sb_t *buf, const iopc_pkg_t *pkg,
                                   const iopc_field_t *field,
                                   unsigned flags)
{
    sb_adds(buf, field->name);
    if (flags & OBJECT_FIELD) {
        switch (field->repeat) {
          case IOP_R_DEFVAL:
            if (!(flags & DEFVAL_AS_OPT)) {
                break;
            }
            /* FALLTHROUGH */

          case IOP_R_OPTIONAL:
            sb_addc(buf, '?');
            break;

          case IOP_R_REPEATED:
            if (flags & USE_PARAM) {
                sb_addc(buf, '?');
            }
            break;

          case IOP_R_REQUIRED:
            /* Make a void field in struct optional, so that it does not have
             * to be specified when building the type.
             * However, do not make it optional if it is an element of a
             * union, as the field is a discriminant. */
            if (unlikely(field->kind == IOP_T_VOID && !(flags & IN_UNION))) {
                sb_addc(buf, '?');
            }
            break;

          default:
            break;
        }
    }
    sb_adds(buf, ": ");
    iopc_pystub_dump_field_type(buf, pkg, field, flags);
}

static void iopc_pystub_dump_struct(sb_t *buf, const char *indent,
                                    const iopc_pkg_t *pkg, iopc_struct_t *st,
                                    const char *st_name)
{
    if (!st_name) {
        st_name = st->name;
    }

    sb_addf(buf, "%sconst %s_fullname = '%s%s%s.%s';\n",
            indent, st_name, pp_dot(pkg->name), st->iface ? "." : "",
            st->iface ? st->iface->name : "", st_name);

    sb_addf(buf, "%sexport interface %s", indent, st_name);
    if (iopc_is_class(st->type) && st->extends.len) {
        const iopc_pkg_t *parent_pkg = st->extends.tab[0]->pkg;
        const iopc_struct_t *parent = st->extends.tab[0]->st;

        sb_adds(buf, " extends ");
        iopc_pystub_dump_package_member(buf, pkg, parent_pkg,
                                        parent_pkg->name, parent->name);
    }

    sb_adds(buf, " {\n");

    if (iopc_is_class(st->type) && !st->extends.len) {
        sb_addf(buf, "%s    _class: string;\n", indent);
    }

    tab_for_each_entry(field, &st->fields) {
        sb_addf(buf, "%s    ", indent);
        iopc_pystub_dump_field(buf, pkg, field, OBJECT_FIELD);
        sb_adds(buf, ";\n");
    }

    sb_addf(buf, "%s}\n", indent);
}

static void iopc_pystub_dump_union(sb_t *buf, const char *indent,
                                   const iopc_pkg_t *pkg, iopc_struct_t *st,
                                   const char *st_name)
{
    bool first;

    if (!st_name) {
        st_name = st->name;
    }

    sb_addc(buf, '\n');

    first = true;
    sb_addf(buf, "%sexport type %s = ", indent, st_name);
    tab_for_each_entry(field, &st->fields) {
        if (!first) {
            sb_addf(buf, "\n%s    | ", indent);
        }
        sb_adds(buf, "{ ");
        iopc_pystub_dump_field(buf, pkg, field, OBJECT_FIELD | IN_UNION);
        sb_adds(buf, " }");
        first = false;
    }
    sb_adds(buf, ";\n");

    first = true;
    sb_addf(buf, "%sexport type %s_Pairs = ", indent, st_name);
    tab_for_each_entry(field, &st->fields) {
        if (!first) {
            sb_addf(buf, "\n%s    | ", indent);
        }
        sb_addf(buf, "{ kind: '%s', value: ", field->name);
        iopc_pystub_dump_field_type(buf, pkg, field, OBJECT_FIELD);
        sb_adds(buf, " }");
        first = false;
    }
    sb_adds(buf, ";\n");

    sb_addf(buf, "%sexport type %s_Keys = ", indent, st_name);
    tab_for_each_entry(field, &st->fields) {
        sb_addf(buf, "'%s' | ", field->name);
    }
    sb_shrink(buf, 3);
    sb_adds(buf, ";\n");
}

static void iopc_pystub_dump_structs(sb_t *buf, iopc_pkg_t *pkg)
{
    tab_for_each_entry(st, &pkg->structs) {
        switch (st->type) {
          case STRUCT_TYPE_STRUCT:
          case STRUCT_TYPE_CLASS:
            iopc_pystub_dump_struct(buf, "", pkg, st, NULL);
            sb_addc(buf, '\n');
            break;

          case STRUCT_TYPE_UNION:
            iopc_pystub_dump_union(buf, "", pkg, st, NULL);
            sb_addc(buf, '\n');
            break;

          default:
            break;
        }
    }
}

static void
iopc_pystub_dump_rpc_fun_struct(sb_t *buf, const iopc_pkg_t *pkg,
                                const iopc_fun_t *rpc, const char *type,
                                const iopc_fun_struct_t *fun_st)
{
    if (iopc_fun_struct_is_void(fun_st)) {
        sb_addf(buf, "        export type %s%s = void;\n", rpc->name, type);
    } else {
        if (fun_st->is_anonymous) {
            iopc_pystub_dump_struct(buf, "        ", pkg,
                                     fun_st->anonymous_struct,
                                     t_fmt("%s%s", rpc->name, type));
        } else {
            sb_addf(buf, "        export type %s%s = ", rpc->name, type);
            iopc_pystub_dump_field_basetype(buf, pkg,
                                             fun_st->existing_struct, NULL);
            sb_adds(buf, ";\n");
        }
    }
}

static void iopc_pystub_dump_rpc(sb_t *buf, const iopc_pkg_t *pkg,
                                 const iopc_fun_t *rpc)
{
    t_scope;

    iopc_pystub_dump_rpc_fun_struct(buf, pkg, rpc, "Args", &rpc->arg);
    iopc_pystub_dump_rpc_fun_struct(buf, pkg, rpc, "Res", &rpc->res);
    iopc_pystub_dump_rpc_fun_struct(buf, pkg, rpc, "Exn", &rpc->exn);

    sb_addf(buf, "        export type %s = (", rpc->name);
    if (!iopc_fun_struct_is_void(&rpc->arg)) {
        if (rpc->arg.is_anonymous) {
            bool first = true;

            tab_for_each_entry(field, &rpc->arg.anonymous_struct->fields) {
                if (!first) {
                    sb_adds(buf, ", ");
                }
                iopc_pystub_dump_field(buf, pkg, field, DEFVAL_AS_OPT);
                first = false;
            }
        } else {
            sb_adds(buf, "arg: ");
            iopc_pystub_dump_field_basetype(buf, pkg,
                                             rpc->arg.existing_struct,
                                             NULL);
        }
    }
    sb_adds(buf, ") => ");

    if (rpc->fun_is_async) {
        sb_adds(buf, "void");
    } else
    if (!iopc_fun_struct_is_void(&rpc->res)) {
        sb_addf(buf, "Promise<%sRes>", rpc->name);
    } else {
        sb_adds(buf, "Promise<void>");
    }

    sb_adds(buf, ";\n\n");
}

static void iopc_pystub_dump_iface(sb_t *buf, const iopc_pkg_t *pkg,
                                   iopc_iface_t *iface)
{
    sb_addf(buf, "    export namespace %s {\n", iface->name);

    tab_for_each_entry(rpc, &iface->funs) {
        iopc_pystub_dump_rpc(buf, pkg, rpc);
    }

    sb_addf(buf, "    }\n");
}

static void iopc_pystub_dump_ifaces(sb_t *buf, iopc_pkg_t *pkg)
{
    sb_adds(buf, "\nexport namespace interfaces {\n");

    tab_for_each_entry(iface, &pkg->ifaces) {
        switch (iface->type) {
          case IFACE_TYPE_IFACE:
            iopc_pystub_dump_iface(buf, pkg, iface);
            break;

          default:
            break;
        }
    }

    sb_adds(buf, "}\n");
}

int iopc_do_pystub(iopc_pkg_t *pkg, const char *outdir)
{
    SB_8k(buf);
    char path[PATH_MAX];

    iopc_set_path(outdir, pkg, "_iop.pyi", sizeof(path), path, true);

    sb_adds(&buf, RO_WARN);
    sb_adds(&buf, "/* tslint:disable */\n");
    sb_adds(&buf, "/* eslint-disable */\n");
    iopc_pystub_dump_imports(&buf, pkg);

    iopc_pystub_dump_enums(&buf, pkg);
    iopc_pystub_dump_structs(&buf, pkg);
    iopc_pystub_dump_ifaces(&buf, pkg);

    qv_deep_wipe(&pp_g, p_delete);
    return iopc_write_file(&buf, path);
}
