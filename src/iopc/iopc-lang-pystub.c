/***************************************************************************/
/*                                                                         */
/* Copyright 2025 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include <lib-common/unix.h>
#include "iopc.h"
#include "iopc-internal.h"

#define STUB_HEADER \
    "#***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****\n"     \
    "# pylint: disable=all\n"                                                \
    "\n"                                                                     \
    "import typing\n"                                                        \
    "import typing_extensions\n"                                             \
    "import iopy\n"                                                          \
    "\n"

static void iopc_pystub_dump_pkg_name(sb_t *buf, const iopc_path_t *path)
{
    tab_for_each_entry(bit, &path->bits) {
        sb_addf(buf, "%s_", bit);
    }
    sb_shrink(buf, 1);
}

static void iopc_pystub_dump_py_mod_name(sb_t *buf, const iopc_path_t *path)
{
    iopc_pystub_dump_pkg_name(buf, path);
    sb_adds(buf, "__iop");
}

static void iopc_pystup_dump_fold_begin(sb_t *buf, const char *fold_name)
{
    sb_addf(buf, "# {""{{ %s\n", fold_name);
}

static void iopc_pystup_dump_fold_begin_extra(sb_t *buf,
                                              const char *fold_name)
{
    iopc_pystup_dump_fold_begin(buf, fold_name);
    sb_adds(buf, "\n\n");
}

static void iopc_pystup_dump_fold_end(sb_t *buf)
{
    sb_adds(buf, "# }""}}\n");
}

static void iopc_pystup_dump_fold_end_extra(sb_t *buf)
{
    sb_adds(buf, "\n\n");
    iopc_pystup_dump_fold_end(buf);
}

static void t_iopc_pystub_dump_import(sb_t *buf, const iopc_pkg_t *dep,
                                      qh_t(lstr) *imported)
{
    SB_1k(py_mod);
    lstr_t pkg_name;
    uint32_t pos;

    iopc_pystub_dump_py_mod_name(&py_mod, dep->name);
    pkg_name = LSTR_SB_V(&py_mod);

    pos = qh_put(lstr, imported, &pkg_name, 0);
    if (pos & QHASH_COLLISION) {
        return;
    }
    imported->keys[pos] = t_lstr_dup(pkg_name);

    sb_addf(buf, "import %*pM\n", LSTR_FMT_ARG(pkg_name));
}

static void iopc_pystub_dump_imports(sb_t *buf, iopc_pkg_t *pkg)
{
    t_scope;
    qh_t(lstr) imported;
    qv_t(iopc_pkg) t_deps;
    qv_t(iopc_pkg) t_weak_deps;
    qv_t(iopc_pkg) i_deps;

    t_qh_init(lstr, &imported, 0);
    t_qv_init(&t_deps, 0);
    t_qv_init(&t_weak_deps, 0);
    t_qv_init(&i_deps, 0);

    iopc_pkg_get_deps(pkg, 0, &t_deps, &t_weak_deps, &i_deps);

    tab_for_each_entry(dep, &t_deps) {
        t_iopc_pystub_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &t_weak_deps) {
        t_iopc_pystub_dump_import(buf, dep, &imported);
    }
    tab_for_each_entry(dep, &i_deps) {
        t_iopc_pystub_dump_import(buf, dep, &imported);
    }
    sb_adds(buf, "\n\n");
}

static void iopc_pystub_dump_package_member(sb_t *buf, const iopc_pkg_t *pkg,
                                            const iopc_pkg_t *member_pkg,
                                            const iopc_path_t *member_path,
                                            const char *member_name)
{
    if (pkg != member_pkg) {
        assert(member_path->bits.len);
        iopc_pystub_dump_py_mod_name(buf, member_path);
        sb_addc(buf, '.');
    }
    sb_adds(buf, member_name);
}

static void iopc_pystub_dump_enum(sb_t *buf, const iopc_pkg_t *pkg,
                                  const iopc_enum_t *en)
{
    iopc_pystup_dump_fold_begin_extra(buf, en->name);

    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s(iopy.Enum):\n", en->name);
    sb_adds(buf, "    pass\n");

    sb_addf(buf, "\n\n%s_ParamType = typing.Union[%s, int, str]\n",
            en->name, en->name);

    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_enums(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(en, &pkg->enums) {
        iopc_pystub_dump_enum(buf, pkg, en);
    }
}

static void iopc_pystub_dump_field_basetype(sb_t *buf, const iopc_pkg_t *pkg,
                                            const iopc_field_t *field,
                                            const char * nullable suffix)
{
    switch (field->kind) {
    case IOP_T_I8:
    case IOP_T_U8:
    case IOP_T_I16:
    case IOP_T_U16:
    case IOP_T_I32:
    case IOP_T_U32:
    case IOP_T_I64:
    case IOP_T_U64:
        sb_adds(buf, "int");
        break;

    case IOP_T_BOOL:
        sb_adds(buf, "bool");
        break;

    case IOP_T_DOUBLE:
        sb_adds(buf, "float");
        break;

    case IOP_T_VOID:
        sb_adds(buf, "typing.Any");
        break;

    case IOP_T_STRING:
    case IOP_T_XML:
        sb_adds(buf, "str");
        break;

    case IOP_T_DATA:
        sb_adds(buf, "bytes");
        break;

    case IOP_T_STRUCT:
    case IOP_T_UNION:
    case IOP_T_ENUM:
        iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                        field->type_path, field->type_name);
        if (suffix) {
            sb_adds(buf, suffix);
        }
        break;
    }
}

static void iopc_pystub_dump_field(sb_t *buf, const iopc_pkg_t *pkg,
                                   const iopc_field_t *field)
{
    bool ending_bracket = false;

    sb_adds(buf, field->name);
    sb_adds(buf, ": ");

    switch (field->repeat) {
    case IOP_R_OPTIONAL:
        sb_adds(buf, "iopy.IopFieldOptional[");
        ending_bracket = true;
        break;

    case IOP_R_REPEATED:
        sb_adds(buf, "typing.List[");
        ending_bracket = true;
        break;

    case IOP_R_DEFVAL:
    case IOP_R_REQUIRED:
        break;

    default:
        break;
    }
    iopc_pystub_dump_field_basetype(buf, pkg, field, NULL);

    if (ending_bracket) {
        sb_addc(buf, ']');
    }
}

static void iopc_pystub_dump_unpack_inits(sb_t *buf)
{
    sb_adds(buf,
            "    @typing.overload\n"
            "    def __init__(cls, *, _json: typing.Union[str, bytes]): ...\n"
            "\n"
            "    @typing.overload\n"
            "    def __init__(cls, *, _yaml: typing.Union[str, bytes]): ...\n"
            "\n"
            "    @typing.overload\n"
            "    def __init__(cls, *, _xml: typing.Union[str, bytes]): ...\n"
            "\n"
            "    @typing.overload\n"
            "    def __init__(cls, *, _hex: typing.Union[str, bytes]): ...\n"
            "\n"
            "    @typing.overload\n"
            "    def __init__(cls, *, _bin: typing.Union[str, bytes]): ...\n"
    );
}

static void
iopc_pystub_dump_struct_intern(sb_t *buf, const iopc_pkg_t *pkg,
                               const iopc_struct_t *st, const char *st_name)
{
    assert(st_name);

    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s(", st_name);
    if (iopc_is_class(st->type) && st->extends.len) {
        const iopc_pkg_t *parent_pkg = st->extends.tab[0]->pkg;
        const iopc_struct_t *parent = st->extends.tab[0]->st;

        iopc_pystub_dump_package_member(buf, pkg, parent_pkg,
                                        parent_pkg->name, parent->name);
    } else {
        sb_adds(buf, "iopy.Struct");
    }
    sb_adds(buf, "):\n");

    if (st->fields.len) {
        tab_for_each_entry(field, &st->fields) {
            sb_adds(buf, "    ");
            iopc_pystub_dump_field(buf, pkg, field);
            sb_adds(buf, "\n");
        }
        sb_adds(buf, "\n");
    }

    iopc_pystub_dump_unpack_inits(buf);

    sb_addf(buf, "\n\n%s_ParamType = typing.Union[%s]\n",
            st_name, st_name);
}

static void iopc_pystub_dump_struct(sb_t *buf, const iopc_pkg_t *pkg,
                                    const iopc_struct_t *st)
{
    const char *st_name = st->name;

    iopc_pystup_dump_fold_begin_extra(buf, st_name);
    iopc_pystub_dump_struct_intern(buf, pkg, st, st_name);
    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_union(sb_t *buf, const iopc_pkg_t *pkg,
                                   const iopc_struct_t *st)
{
    const char *st_name = st->name;

    iopc_pystup_dump_fold_begin_extra(buf, st_name);

    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s(iopy.Union):\n", st_name);

    if (st->fields.len) {
        tab_for_each_entry(field, &st->fields) {
            sb_adds(buf, "    ");
            iopc_pystub_dump_field(buf, pkg, field);
            sb_adds(buf, "\n");
        }
        sb_adds(buf, "\n");
    }

    iopc_pystub_dump_unpack_inits(buf);

    sb_addf(buf, "\n\n%s_ParamType = typing.Union[%s]\n",
            st_name, st_name);

    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_structs(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(st, &pkg->structs) {
        switch (st->type) {
        case STRUCT_TYPE_STRUCT:
        case STRUCT_TYPE_CLASS:
            iopc_pystub_dump_struct(buf, pkg, st);
            break;

        case STRUCT_TYPE_UNION:
            iopc_pystub_dump_union(buf, pkg, st);
            break;

        default:
            break;
        }
    }
}

static void
iopc_pystub_dump_rpc_fun_struct(sb_t *buf, const iopc_pkg_t *pkg,
                                const iopc_iface_t *iface,
                                const iopc_fun_t *rpc, const char *type,
                                const iopc_fun_struct_t *fun_st)
{
    t_scope;
    const char *st_name = t_fmt("%s_%s_%s", iface->name, rpc->name, type);

    if (iopc_fun_struct_is_void(fun_st)) {
        sb_addf(buf, "%s = None\n", st_name);
    } else if (fun_st->is_anonymous) {
        iopc_pystub_dump_struct_intern(buf, pkg, fun_st->anonymous_struct,
                                       st_name);
        sb_adds(buf, "\n\n");
    } else {
        sb_addf(buf, "%s = ", st_name);
        iopc_pystub_dump_field_basetype(buf, pkg, fun_st->existing_struct,
                                        NULL);
        sb_adds(buf, "\n");
    }
}

static void iopc_pystub_dump_rpc(sb_t *buf, const iopc_pkg_t *pkg,
                                 const iopc_iface_t *iface,
                                 const iopc_fun_t *rpc)
{
    t_scope;
    const char *rpc_name = t_fmt("%s_%s", iface->name, rpc->name);

    iopc_pystup_dump_fold_begin_extra(buf, rpc_name);

    iopc_pystub_dump_rpc_fun_struct(buf, pkg, iface, rpc, "Arg", &rpc->arg);
    iopc_pystub_dump_rpc_fun_struct(buf, pkg, iface, rpc, "Res", &rpc->res);
    iopc_pystub_dump_rpc_fun_struct(buf, pkg, iface, rpc, "Exn", &rpc->exn);


    sb_adds(buf, "\n\n");
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_RPC(iopy.RPC):\n", rpc_name);
    sb_addf(buf, "    Arg = %s_Arg\n", rpc_name);
    sb_addf(buf, "    Res = %s_Res\n", rpc_name);
    sb_addf(buf, "    Exn = %s_Exn\n", rpc_name);

    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_iface(sb_t *buf, const iopc_pkg_t *pkg,
                                   const iopc_iface_t *iface)
{
    iopc_pystup_dump_fold_begin(buf, iface->name);

    tab_for_each_entry(rpc, &iface->funs) {
        iopc_pystub_dump_rpc(buf, pkg, iface, rpc);
    }

    sb_adds(buf, "\n\n");
    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_Iface(iopy.Iface):\n", iface->name);
    if (iface->funs.len) {
        tab_for_each_entry(rpc, &iface->funs) {
            sb_addf(buf, "    %s = %s_%s_RPC\n", rpc->name, iface->name,
                    rpc->name);
        }
    } else {
        sb_adds(buf, "    pass\n");
    }
    sb_adds(buf, "\n\n");

    iopc_pystup_dump_fold_end(buf);
}

static void iopc_pystub_dump_ifaces(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(iface, &pkg->ifaces) {
        switch (iface->type) {
        case IFACE_TYPE_IFACE:
            iopc_pystub_dump_iface(buf, pkg, iface);
            break;

        default:
            break;
        }
    }
}

static void iopc_pystub_dump_module(sb_t *buf, const iopc_pkg_t *pkg,
                                    const iopc_struct_t *mod)
{
    const char *mod_name = mod->name;

    iopc_pystup_dump_fold_begin_extra(buf, mod_name);

    sb_adds(buf, "@typing.type_check_only\n");
    sb_addf(buf, "class %s_Module(iopy.Module):\n", mod_name);

    if (mod->fields.len) {
        tab_for_each_entry(field, &mod->fields) {
            sb_addf(buf, "    %s = ", field->name);
            iopc_pystub_dump_package_member(buf, pkg, field->type_pkg,
                                            field->type_path,
                                            field->type_name);
            sb_adds(buf, "_Iface\n");
        }
    } else {
        sb_adds(buf, "    pass\n");
    }


    iopc_pystup_dump_fold_end_extra(buf);
}

static void iopc_pystub_dump_modules(sb_t *buf, const iopc_pkg_t *pkg)
{
    tab_for_each_entry(mod, &pkg->modules) {
        iopc_pystub_dump_module(buf, pkg, mod);
    }
}

int iopc_do_pystub(iopc_pkg_t *pkg, const char *outdir)
{
    SB_1k(py_mod);
    SB_8k(buf);
    char path[PATH_MAX];

    /* Unlike other languages output, put all the stubs in the same output
     * directory without hierarchy. */
    if (mkdir_p(outdir, 0777) < 0) {
        throw_error("cannot create directory `%s`: %m", outdir);
    }
    iopc_pystub_dump_py_mod_name(&py_mod, pkg->name);
    snprintf(path, sizeof(path), "%s/%*pM.pyi", outdir, SB_FMT_ARG(&py_mod));

    sb_adds(&buf, STUB_HEADER);
    iopc_pystub_dump_imports(&buf, pkg);

    iopc_pystub_dump_enums(&buf, pkg);
    iopc_pystub_dump_structs(&buf, pkg);
    iopc_pystub_dump_ifaces(&buf, pkg);
    iopc_pystub_dump_modules(&buf, pkg);

    return iopc_write_file(&buf, path);
}
