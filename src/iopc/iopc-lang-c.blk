/***************************************************************************/
/*                                                                         */
/* Copyright 2022 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include "iopc-priv.h"
#include <float.h>
#include <math.h>

static qv_t(str) pp_g;
struct iopc_do_c_globs iopc_do_c_g;
#define _G  iopc_do_c_g

#define CONST     _G.no_const ? "" : "const "
#define NULLABLE  (_G.export_nullability ? "nullable " : "")

/* {{{ Misc. */

static const char *pp_under(const iopc_path_t *path)
{
    SB_1k(buf);
    char *res;

    tab_for_each_entry(bit, &path->bits) {
        sb_addf(&buf, "%s__", bit);
    }
    sb_shrink(&buf, 2);
    qv_append(&pp_g, res = sb_detach(&buf, NULL));
    return res;
}

static const char *pp_to_c(const char *s)
{
    t_scope;
    lstr_t str = lstr_dup(t_camelcase_to_c(LSTR(s)));

    qv_append(&pp_g, str.v);
    return str.v;
}

static lstr_t t_enum_get_prefix(const iopc_enum_t *en)
{
    lstr_t ns = LSTR_NULL;

    if (t_iopc_attr_check_prefix(&en->attrs, &ns) < 0) {
        ns = t_lstr_dups(pp_to_c(en->name), -1);
    }
    lstr_ascii_toupper(&ns);
    return ns;
}

/** Give the extra length for the encoding of an IOP tag. */
static inline int iopc_tag_len(int32_t tag)
{
    /* Tags 0..29 are encoded inline -> 0 byte,
     * Tags 30..255 are encoded as value 30 plus 1 byte,
     * Tags 256..65535 are encoded as value 31 plus 2 extra bytes */
    return (tag >= 30) + (tag >= 256);
}

/* }}} */
/* {{{ Struct sorting and optimizing. */

static void iopc_field_compute_size(iopc_field_t *f);

static iopc_field_t *iopc_bubble_field(qv_t(iopc_field) *fields, int pos,
                                       size_t size)
{
    int lost = INT_MAX, match = 0;
    iopc_field_t **tab = fields->tab + pos;

    for (int i = 0; i < fields->len - pos; i++) {
        iopc_field_t *f = tab[i];
        int f_lost = ROUND_UP(size, f->align) - size;

        if (f_lost < lost) {
            lost  = f_lost;
            match = i;
        }
    }

    if (match) {
        iopc_field_t *f = tab[match];

        p_move(tab + 1, tab, match);
        tab[0] = f;
    }
    return tab[0];
}

/* TODO Do it systematically somewhere else. */
static void iopc_struct_build_fields_by_tag(iopc_struct_t *st)
{
    if (st->fields_by_tag.len == st->fields.len) {
        return;
    }

    qv_extend_tab(&st->fields_by_tag, &st->fields);
    qv_sort(iopc_field)(&st->fields_by_tag, ^int (iopc_field_t * const *f1,
                                                  iopc_field_t * const *f2) {
        return (*f1)->tag - (*f2)->tag;
    });
}

/** Calculate sizes and alignments then and optimize the fields order to
 * minimize the structure size.
 */
static void iopc_struct_optimize(iopc_struct_t *st)
{
    size_t size = 0;
    size_t opt_size = 0;
    size_t orig_size = 0;
    bool do_reorder;

    if (st->size || st->optimized) {
        return;
    }

    if (st->type == STRUCT_TYPE_UNION) {
        /* iop_tag field */
        st->align = alignof(uint16_t);
    } else
    if (st->type == STRUCT_TYPE_CLASS) {
        /* __vptr field */
        st->align = alignof(void *);
    } else {
        st->align = 1;
    }
    tab_for_each_entry(f, &st->fields) {
        iopc_field_compute_size(f);
        st->align = MAX(st->align, f->align);
        orig_size = ROUND_UP(orig_size, f->align) + f->size;
        opt_size += f->size;
    }
    orig_size = ROUND_UP(orig_size, st->align);

    iopc_struct_build_fields_by_tag(st);
    qv_extend_tab(&st->fields_in_c_struct_order, &st->fields_by_tag);

    if (st->type == STRUCT_TYPE_UNION) {
        /*
         * union is struct { uint16_t tag; union { ... }; }
         *
         * so its align is at least 2, and its size is an alignment + max size
         * of any member of the union.
         */
        tab_for_each_entry(f, &st->fields) {
            size = MAX(size, f->size);
        }
        size     = ROUND_UP(size, st->align);
        st->size = st->align + size;
        return;
    }

    if (iopc_is_class(st->type) || iopc_is_snmp_st(st->type)) {
        /* XXX: we don't want to reorder class/snmpObj fields to ease
         * debugging and backward compatibility. */
        do_reorder = false;
    } else {
        do_reorder = iopc_attr_check(&st->attrs, IOPC_ATTR_NO_REORDER,
                                     NULL) < 0;
    }

    for (int i = 0; i < st->fields_in_c_struct_order.len; i++) {
        iopc_field_t *f;

        if (do_reorder) {
            f = iopc_bubble_field(&st->fields_in_c_struct_order, i, size);
        } else {
            f = st->fields_in_c_struct_order.tab[i];
        }

        size = ROUND_UP(size, f->align) + f->size;
    }
    st->size = size = ROUND_UP(size, st->align);

    if (do_reorder && st->size - opt_size >= st->align)
        warn_loc("suboptimal type size (%s packed is %zd, size is %d@%d)",
                 st->loc, st->name, opt_size, st->size, st->align);
#if 0
    if (orig_size > size) {
        warn_loc("%s:\torig:%3zd now:%3zd gain:%2zd packed:%3zd",
                 st->loc, st->name, orig_size, size,
                 orig_size - size, opt_size);
    }
#else
    IGNORE(orig_size);
#endif

    st->optimized = true;
}

/* }}} */
/* {{{ Sizes and alignment helpers. */

/** Same as \ref iop_scalar_type_get_size_and_alignment but for optional
 * types. */
static void iop_opt_type_get_size_and_alignment(iop_type_t type,
                                                uint16_t *nullable size,
                                                uint8_t *nullable align)
{
    static struct {
        uint16_t size;
        uint8_t align;
    } sizes_and_alignments[] = {
#define SIZE_ALIGN(type_t)  { sizeof(type_t), alignof(type_t) }

        [IOP_T_VOID]   = SIZE_ALIGN(bool),
        [IOP_T_BOOL]   = SIZE_ALIGN(opt_bool_t),
        [IOP_T_U8]     = SIZE_ALIGN(opt_u8_t),
        [IOP_T_I8]     = SIZE_ALIGN(opt_i8_t),
        [IOP_T_U16]    = SIZE_ALIGN(opt_u16_t),
        [IOP_T_I16]    = SIZE_ALIGN(opt_i16_t),
        [IOP_T_U32]    = SIZE_ALIGN(opt_u32_t),
        [IOP_T_I32]    = SIZE_ALIGN(opt_i32_t),
        [IOP_T_ENUM]   = SIZE_ALIGN(opt_i32_t),
        [IOP_T_U64]    = SIZE_ALIGN(opt_u64_t),
        [IOP_T_I64]    = SIZE_ALIGN(opt_i64_t),
        [IOP_T_DOUBLE] = SIZE_ALIGN(opt_double_t),
        [IOP_T_STRING] = SIZE_ALIGN(lstr_t),
        [IOP_T_DATA]   = SIZE_ALIGN(lstr_t),
        [IOP_T_XML]    = SIZE_ALIGN(lstr_t),
        [IOP_T_UNION]  = SIZE_ALIGN(void *),
        [IOP_T_STRUCT] = SIZE_ALIGN(void *),

#undef SIZE_ALIGN
    };

    typeof(sizes_and_alignments[0]) res;

    res = sizes_and_alignments[type];
    if (size) {
        *size = res.size;
    }
    if (align) {
        *align = res.align;
    }
}

/** Get the field size and alignment for the C type associated to an IOP
 * scalar type.
 */
static void iop_scalar_type_get_size_and_alignment(iop_type_t type,
                                                   uint16_t *nullable size,
                                                   uint8_t *nullable align)
{
    static struct {
        uint16_t size;
        uint8_t align;
    } sizes_and_alignments[] = {
#define SIZE_ALIGN(type_t)  { sizeof(type_t), alignof(type_t) }

        [IOP_T_VOID]   = { 0, alignof(bool) },
        [IOP_T_BOOL]   = SIZE_ALIGN(bool),
        [IOP_T_U8]     = SIZE_ALIGN(uint8_t),
        [IOP_T_I8]     = SIZE_ALIGN(int8_t),
        [IOP_T_U16]    = SIZE_ALIGN(uint16_t),
        [IOP_T_I16]    = SIZE_ALIGN(int16_t),
        [IOP_T_U32]    = SIZE_ALIGN(uint32_t),
        [IOP_T_I32]    = SIZE_ALIGN(int32_t),
        [IOP_T_ENUM]   = SIZE_ALIGN(int32_t),
        [IOP_T_U64]    = SIZE_ALIGN(uint64_t),
        [IOP_T_I64]    = SIZE_ALIGN(int64_t),
        [IOP_T_DOUBLE] = SIZE_ALIGN(double),
        [IOP_T_STRING] = SIZE_ALIGN(lstr_t),
        [IOP_T_DATA]   = SIZE_ALIGN(lstr_t),
        [IOP_T_XML]    = SIZE_ALIGN(lstr_t),

#undef SIZE_ALIGN
    };
    typeof(sizes_and_alignments[0]) res;

    if (!iop_type_is_scalar(type)) {
        e_panic("should not happen");
    }

    res = sizes_and_alignments[type];
    if (size) {
        *size = res.size;
    }
    if (align) {
        *align = res.align;
    }
}

static uint8_t iop_struct_get_align(const iop_struct_t *st);

/* XXX The logic is the same (and *should* stay the same) as for
 * "iopc_field_compute_size" except that the description type is different. */
static uint16_t iop_field_get_align(const iop_field_t *f)
{
    uint8_t align;
    uint16_t flags = f->flags;

    if (TST_BIT(&flags, IOP_FIELD_IS_REFERENCE)) {
        align = alignof(void *);
    } else
    if (f->repeat == IOP_R_OPTIONAL) {
        iop_opt_type_get_size_and_alignment(f->type, NULL, &align);
    } else
    if (f->repeat == IOP_R_REPEATED) {
        align = alignof(IOP_ARRAY_OF(void));
    } else
    if (iop_type_is_scalar(f->type)) {
        iop_scalar_type_get_size_and_alignment(f->type, NULL, &align);
    } else
    if (iop_field_is_class(f)) {
        align = alignof(void *);
    } else {
        align = iop_struct_get_align(f->u1.st_desc);
    }

    return align;
}

/* TODO We may want to expose it someday and also to extend iop_struct_t to
 * have the alignment in it. */
/* XXX The there is no caching of structs alignments (and we might want to add
 * some at some point. The calculation is in O(N) where N is the number of
 * inlined fields and subfields in the struct/union, which is not so bad. */
static uint8_t iop_struct_get_align(const iop_struct_t *st)
{
    uint8_t align = 1;

    for (int i = 0; i < st->fields_len; i++) {
        const iop_field_t *f = &st->fields[i];

        align = MAX(align, iop_field_get_align(f));
    }

    return align;
}

static void iopc_field_compute_size(iopc_field_t *f)
{
    if (f->size) {
        return;
    }

    if (f->is_ref) {
        f->align = alignof(void *);
        f->size  = sizeof(void *);
    } else
    if (f->repeat == IOP_R_OPTIONAL) {
        iop_opt_type_get_size_and_alignment(f->kind, &f->size, &f->align);
    } else
    if (f->repeat == IOP_R_REPEATED) {
        f->align = alignof(IOP_ARRAY_OF(void));
        f->size  = sizeof(IOP_ARRAY_OF(void));
    } else
    if (iop_type_is_scalar(f->kind)) {
        iop_scalar_type_get_size_and_alignment(f->kind, &f->size, &f->align);
    } else
    if (iopc_field_type_is_class(f)) {
        f->align = alignof(void *);
        f->size  = sizeof(void *);
    } else
    if (f->has_external_type) {
        f->align = iop_struct_get_align(f->external_st);
        f->size = f->external_st->size;
    } else {
        iopc_struct_optimize(f->struct_def);
        f->align = f->struct_def->align;
        f->size  = f->struct_def->size;
    }
}

/* }}} */
/* {{{ Field source writing */

static void pp_field_with_type(sb_t *sb, const iopc_field_t *f, int indent)
{
    const char *type = NULL;
    const char *old_type = NULL;
    bool type_is_class = false;

    if (f->kind == IOP_T_STRUCT && f->struct_def->type == STRUCT_TYPE_CLASS) {
        type_is_class = true;
    }

    switch (f->repeat) {
      case IOP_R_REPEATED:
        switch (f->kind) {
          case IOP_T_U8:
            type     = "iop_array_u8_t     ";
            old_type = "IOP_ARRAY_OF(uint8_t)  ";
            break;
          case IOP_T_I8:
            type     = "iop_array_i8_t     ";
            old_type = "IOP_ARRAY_OF(int8_t)   ";
            break;
          case IOP_T_U16:
            type     = "iop_array_u16_t    ";
            old_type = "IOP_ARRAY_OF(uint16_t) ";
            break;
          case IOP_T_I16:
            type     = "iop_array_i16_t    ";
            old_type = "IOP_ARRAY_OF(int16_t)  ";
            break;
          case IOP_T_U32:
            type     = "iop_array_u32_t    ";
            old_type = "IOP_ARRAY_OF(uint32_t) ";
            break;
          case IOP_T_I32:
            type     = "iop_array_i32_t    ";
            old_type = "IOP_ARRAY_OF(int32_t)  ";
            break;
          case IOP_T_U64:
            type     = "iop_array_u64_t    ";
            old_type = "IOP_ARRAY_OF(uint64_t) ";
            break;
          case IOP_T_I64:
            type     = "iop_array_i64_t    ";
            old_type = "IOP_ARRAY_OF(int64_t)  ";
            break;
          case IOP_T_BOOL:
            type     = "iop_array_bool_t   ";
            old_type = "IOP_ARRAY_OF(bool)     ";
            break;
          case IOP_T_DOUBLE:
            type     = "iop_array_double_t ";
            old_type = "IOP_ARRAY_OF(double)   ";
            break;
          case IOP_T_STRING:
          case IOP_T_XML:
            type     = "iop_array_lstr_t   ";
            old_type = "IOP_ARRAY_OF(lstr_t)   ";
            break;
          case IOP_T_DATA:
            type     = "iop_array_lstr_t   ";
            old_type = "IOP_ARRAY_OF(iop_data_t) ";
            break;
          case IOP_T_VOID:
            /* Repeated void are forbidden in the parser. */
            assert (false);
            break;
          default:
            sb_addnc(sb, indent, ' ');
            sb_addf(sb, "%s__%s__array_t %s;\n",
                    pp_under(f->type_path), pp_to_c(f->type_name),
                    pp_to_c(f->name));
            return;
        }
        break;

      case IOP_R_OPTIONAL:
        switch (f->kind) {
          case IOP_T_U8:     type = "opt_u8_t         ";    break;
          case IOP_T_I8:     type = "opt_i8_t         ";    break;
          case IOP_T_U16:    type = "opt_u16_t        ";    break;
          case IOP_T_I16:    type = "opt_i16_t        ";    break;
          case IOP_T_U32:    type = "opt_u32_t        ";    break;
          case IOP_T_I32:    type = "opt_i32_t        ";    break;
          case IOP_T_U64:    type = "opt_u64_t        ";    break;
          case IOP_T_I64:    type = "opt_i64_t        ";    break;
          case IOP_T_BOOL:   type = "opt_bool_t       ";    break;
          case IOP_T_VOID:   type = "bool             ";    break;
          case IOP_T_DOUBLE: type = "opt_double_t     ";    break;
          case IOP_T_STRING: type = "lstr_t           ";    break;
          case IOP_T_XML:    type = "lstr_t           ";    break;
          case IOP_T_DATA:   type = "lstr_t           ";    break;
          case IOP_T_ENUM:
            sb_addnc(sb, indent, ' ');
            sb_addf(sb, "%s__%s__opt_t  %s;\n",
                    pp_under(f->type_path), pp_to_c(f->type_name),
                    pp_to_c(f->name));
            return;
          default:
            sb_addnc(sb, indent, ' ');
            sb_addf(sb, "struct %s__%s__t *nullable %s;\n",
                    pp_under(f->type_path), pp_to_c(f->type_name),
                    pp_to_c(f->name));
            return;
        }
        break;

      default:
        switch (f->kind) {
          case IOP_T_U8:     type = "uint8_t  ";   break;
          case IOP_T_I8:     type = "int8_t   ";   break;
          case IOP_T_U16:    type = "uint16_t ";   break;
          case IOP_T_I16:    type = "int16_t  ";   break;
          case IOP_T_U32:    type = "uint32_t ";   break;
          case IOP_T_I32:    type = "int32_t  ";   break;
          case IOP_T_U64:    type = "uint64_t ";   break;
          case IOP_T_I64:    type = "int64_t  ";   break;
          case IOP_T_BOOL:   type = "bool     ";   break;
          case IOP_T_VOID:
             /* void type is not present in struct or union */
            return;
          case IOP_T_DOUBLE: type = "double   ";   break;
          case IOP_T_STRING: type = "lstr_t   ";   break;
          case IOP_T_DATA:   type = "lstr_t   ";   break;
          case IOP_T_XML:    type = "lstr_t   ";   break;
          case IOP_T_ENUM:
            sb_addnc(sb, indent, ' ');
            sb_addf(sb, "%s__%s__t %s;\n", pp_under(f->type_path),
                    pp_to_c(f->type_name), pp_to_c(f->name));
            return;
          default:
            sb_addnc(sb, indent, ' ');
            sb_addf(sb, "struct %s__%s__t%s%s%s;\n", pp_under(f->type_path),
                    pp_to_c(f->type_name),
                    type_is_class || f->is_ref ? " *" : " ",
                    type_is_class || f->is_ref ? "nonnull " : "",
                    pp_to_c(f->name));
            return;
        }
        break;
    }

    if (old_type) {
        sb_addf(sb, "#ifndef IOP_ARRAY_T\n");
        sb_addnc(sb, indent, ' ');
        sb_addf(sb, "%s%s;\n", old_type, pp_to_c(f->name));
        sb_adds(sb, "#else\n");
    }

    assert (type);
    sb_addnc(sb, indent, ' ');
    sb_addf(sb, "%s%s;\n", type, pp_to_c(f->name));

    if (old_type) {
        sb_adds(sb, "#endif\n");
    }
}

qm_kvec_t(rg, lstr_t, int, qhash_lstr_hash, qhash_lstr_equal);
static qm_t(rg) range_h_g = QM_INIT_CACHED(rg, range_h_g);

static int iopc_put_range(sb_t *sb, const iop_array_i32_t *tab)
{
    qm_t(rg) *h = &range_h_g;
    lstr_t    s   = LSTR_INIT((char *)tab->tab, 4 * tab->len);
    int       pos = qm_reserve(rg, h, &s, 0);
    int       res;

    if (pos & QHASH_COLLISION)
        return h->values[pos ^ QHASH_COLLISION];

    h->keys[pos]   = lstr_dup(s);
    h->values[pos] = res = qm_len(rg, h);
    sb_addf(sb, "static int const iop__ranges__%d[] = {\n", res);
    for (int i = 0; i < tab->len / 2; i++)
        sb_addf(sb, "    %d, %d,\n", tab->tab[2 * i], tab->tab[2 * i + 1]);
    sb_addf(sb, "    %d,\n"
            "};\n", tab->tab[tab->len - 1]);
    return res;
}

static void iopc_put_range_cleanup(void)
{
    qm_deep_clear(rg, &range_h_g, lstr_wipe, IGNORE);
}

static lstr_t ctype_get_prefix(lstr_t ctype)
{
    lstr_t pfx = lstr_dupc(ctype);

    if (expect(lstr_endswith(ctype, LSTR("__t")))) {
        pfx.len -= 3;
    }
    return pfx;
}

static void iopc_gen_ctype(sb_t *buf, const qv_t(iopc_attr) *attrs,
                           const char *tbase, iop_type_t type, int class_id)
{
    assert (type == IOP_T_STRUCT || type == IOP_T_UNION
    ||      type == IOP_T_ENUM);

    tab_for_each_entry(attr, attrs) {
        if (attr->desc->id == IOPC_ATTR_CTYPE) {
            tab_for_each_ptr(arg, &attr->args) {
                lstr_t ctype = arg->v.s;
                lstr_t pfx;

                pfx = ctype_get_prefix(ctype);
                sb_addf(buf, "typedef %s__t %*pM;\n", tbase,
                        LSTR_FMT_ARG(ctype));
                sb_addf(buf, "typedef %s__array_t %*pM__array_t;\n", tbase,
                        LSTR_FMT_ARG(pfx));

                if (type == IOP_T_STRUCT || type == IOP_T_UNION) {
                    sb_addf(buf, "#define %*pM__s  %s__s\n",
                            LSTR_FMT_ARG(pfx), tbase);
                } else
                if (type == IOP_T_ENUM) {
                    sb_addf(buf, "typedef %s__opt_t %*pM__opt_t;\n",
                            tbase, LSTR_FMT_ARG(pfx));
                    sb_addf(buf, "#define %*pM__e  %s__e\n",
                            LSTR_FMT_ARG(pfx), tbase);
                }
                if (class_id != -1) {
                    sb_addf(buf, "#define %*pM__class_id  %d\n",
                            LSTR_FMT_ARG(pfx), class_id);
                }

                sb_addc(buf, '\n');
            }
        }
    }
}

/* {{{ attribute kinds */

typedef struct iopc_attr_kind_t {
    const char *attr_typename;
    const char *attr_arg_typename;
    const char *attrs_typename;
    const char *attrs_var_sfx;
    const char *ext;
    int str_gen_type;
    int int_gen_type;
    int bool_gen_type;
    int double_gen_type;
    int ident_gen_type;
    int help_type;

    /* Set to true if the generic attribute types should be written to the
     * 'flags' attribute of the 'attrs' structure. */
    bool write_gen_attr_flags;
} iopc_attr_kind_t;

static const iopc_attr_kind_t iopc_attr_kind_field_g = {
    .attr_typename = "iop_field_attr_t",
    .attr_arg_typename = "iop_field_attr_arg_t",
    /* TODO Use it in 'iopc_struct_dump_src()'. */
    .attrs_typename = "iop_field_attrs_t",
    .attrs_var_sfx = "desc_fields_attrs",
    .ext = "f",
    .str_gen_type = IOP_FIELD_GEN_ATTR_S,
    .int_gen_type = IOP_FIELD_GEN_ATTR_I,
    .bool_gen_type = IOP_FIELD_GEN_ATTR_I,
    .double_gen_type = IOP_FIELD_GEN_ATTR_D,
    .ident_gen_type = IOP_FIELD_GEN_ATTR_O,
    .help_type = IOP_FIELD_ATTR_HELP_V2,
};

static const iopc_attr_kind_t iopc_attr_kind_static_field_g = {
    .attr_typename = "iop_field_attr_t",
    .attr_arg_typename = "iop_field_attr_arg_t",
    .attrs_typename = "iop_field_attrs_t",
    .attrs_var_sfx = "sf_desc_attrs",
    .ext = "sf",
    .str_gen_type = IOP_FIELD_GEN_ATTR_S,
    .int_gen_type = IOP_FIELD_GEN_ATTR_I,
    .bool_gen_type = IOP_FIELD_GEN_ATTR_I,
    .double_gen_type = IOP_FIELD_GEN_ATTR_D,
    .ident_gen_type = IOP_FIELD_GEN_ATTR_O,
    .help_type = IOP_FIELD_ATTR_HELP_V2,
};

static const iopc_attr_kind_t iopc_attr_kind_enum_value_g = {
    .attr_typename = "iop_enum_value_attr_t",
    .attr_arg_typename = "iop_enum_value_attr_arg_t",
    .attrs_typename = "iop_enum_value_attrs_t",
    .attrs_var_sfx = "e_desc_values_attrs",
    .ext = "v",
    .str_gen_type = IOP_ENUM_VALUE_GEN_ATTR_S,
    .int_gen_type = IOP_ENUM_VALUE_GEN_ATTR_I,
    .bool_gen_type = IOP_ENUM_VALUE_GEN_ATTR_I,
    .double_gen_type = IOP_ENUM_VALUE_GEN_ATTR_D,
    .ident_gen_type = IOP_ENUM_VALUE_GEN_ATTR_O,
    .help_type = IOP_ENUM_VALUE_ATTR_HELP_V2,

    /* FIXME Not sure about the reason why we do that... */
    .write_gen_attr_flags = true,
};

static const iopc_attr_kind_t iopc_attr_kind_enum_g = {
    .attr_typename = "iop_enum_attr_t",
    .attr_arg_typename = "iop_enum_attr_arg_t",
    .attrs_typename = "iop_enum_attrs_t",
    .attrs_var_sfx = "e_desc_attrs",
    .ext = "e",
    .str_gen_type = IOP_ENUM_GEN_ATTR_S,
    .int_gen_type = IOP_ENUM_GEN_ATTR_I,
    .bool_gen_type = IOP_ENUM_GEN_ATTR_I,
    .double_gen_type = IOP_ENUM_GEN_ATTR_D,
    .ident_gen_type = IOP_ENUM_GEN_ATTR_O,
    .help_type = IOP_ENUM_ATTR_HELP_V2,
};

static const iopc_attr_kind_t iopc_attr_kind_struct_g = {
    .attr_typename = "iop_struct_attr_t",
    .attr_arg_typename = "iop_struct_attr_arg_t",
    .attrs_typename = "iop_struct_attrs_t",
    .attrs_var_sfx = "s_desc_attrs",
    .ext = "s",
    .str_gen_type = IOP_STRUCT_GEN_ATTR_S,
    .int_gen_type = IOP_STRUCT_GEN_ATTR_I,
    .bool_gen_type = IOP_STRUCT_GEN_ATTR_I,
    .double_gen_type = IOP_STRUCT_GEN_ATTR_D,
    .ident_gen_type = IOP_STRUCT_GEN_ATTR_O,
    .help_type = IOP_STRUCT_ATTR_HELP_V2,
};

static const iopc_attr_kind_t iopc_attr_kind_iface_g = {
    .attr_typename = "iop_iface_attr_t",
    .attr_arg_typename = "iop_iface_attr_arg_t",
    .attrs_typename = "iop_iface_attrs_t",
    .attrs_var_sfx = "desc_if_attrs",
    .ext = "if",
    .str_gen_type = IOP_IFACE_GEN_ATTR_S,
    .int_gen_type = IOP_IFACE_GEN_ATTR_I,
    .bool_gen_type = IOP_IFACE_GEN_ATTR_I,
    .double_gen_type = IOP_IFACE_GEN_ATTR_D,
    .ident_gen_type = IOP_IFACE_GEN_ATTR_O,
    .help_type = IOP_IFACE_ATTR_HELP_V2,
};

static const iopc_attr_kind_t iopc_attr_kind_mod_g = {
    .attr_typename = "iop_mod_attr_t",
    .attr_arg_typename = "iop_mod_attr_arg_t",
    .attrs_typename = "iop_mod_attrs_t",
    .attrs_var_sfx = "m_desc_attrs",
    .ext = "m",
    .help_type = IOP_MOD_ATTR_HELP_V2,
};

static const iopc_attr_kind_t iopc_attr_kind_mod_iface_g = {
    .attr_typename = "iop_mod_iface_attr_t",
    .attr_arg_typename = "iop_mod_iface_attr_arg_t",
    .attrs_typename = "iop_mod_iface_attrs_t",
    .attrs_var_sfx = "m_desc_if_attrs",
    .ext = "m_if",
    .help_type = IOP_MOD_IFACE_ATTR_HELP_V2,
};

/* TODO Use it in 'iopc_iface_dump_rpc_attrs()'. */
static const iopc_attr_kind_t iopc_attr_kind_rpc_g = {
    .attr_typename = "iop_rpc_attr_t",
    .attr_arg_typename = "iop_rpc_attr_arg_t",
    .attrs_typename = "iop_rpc_attrs_t",
    .attrs_var_sfx = "rpc_desc_attrs",
    .ext = "rpc",
    .str_gen_type = IOP_RPC_GEN_ATTR_S,
    .int_gen_type = IOP_RPC_GEN_ATTR_I,
    .bool_gen_type = IOP_RPC_GEN_ATTR_I,
    .double_gen_type = IOP_RPC_GEN_ATTR_D,
    .ident_gen_type = IOP_RPC_GEN_ATTR_O,
    .help_type = IOP_RPC_ATTR_HELP_V2,
};

static const iopc_attr_kind_t iopc_attr_kind_rpc_arg_g = {
    .attr_typename = "iop_rpc_attr_t",
    .attr_arg_typename = "iop_rpc_attr_arg_t",
    .attrs_typename = "iop_rpc_attrs_t",
    .attrs_var_sfx = "rpc_desc_attrs",
    .ext = "rpc_arg",
    .str_gen_type = IOP_RPC_GEN_ATTR_S,
    .int_gen_type = IOP_RPC_GEN_ATTR_I,
    .bool_gen_type = IOP_RPC_GEN_ATTR_I,
    .double_gen_type = IOP_RPC_GEN_ATTR_D,
    .ident_gen_type = IOP_RPC_GEN_ATTR_O,
    .help_type = IOP_RPC_ATTR_ARG_HELP_V2,
};

static const iopc_attr_kind_t iopc_attr_kind_rpc_res_g = {
    .attr_typename = "iop_rpc_attr_t",
    .attr_arg_typename = "iop_rpc_attr_arg_t",
    .attrs_typename = "iop_rpc_attrs_t",
    .attrs_var_sfx = "rpc_desc_attrs",
    .ext = "rpc_res",
    .str_gen_type = IOP_RPC_GEN_ATTR_S,
    .int_gen_type = IOP_RPC_GEN_ATTR_I,
    .bool_gen_type = IOP_RPC_GEN_ATTR_I,
    .double_gen_type = IOP_RPC_GEN_ATTR_D,
    .ident_gen_type = IOP_RPC_GEN_ATTR_O,
    .help_type = IOP_RPC_ATTR_RES_HELP_V2,
};

static const iopc_attr_kind_t iopc_attr_kind_rpc_exn_g = {
    .attr_typename = "iop_rpc_attr_t",
    .attr_arg_typename = "iop_rpc_attr_arg_t",
    .attrs_typename = "iop_rpc_attrs_t",
    .attrs_var_sfx = "rpc_desc_attrs",
    .ext = "rpc_exn",
    .str_gen_type = IOP_RPC_GEN_ATTR_S,
    .int_gen_type = IOP_RPC_GEN_ATTR_I,
    .bool_gen_type = IOP_RPC_GEN_ATTR_I,
    .double_gen_type = IOP_RPC_GEN_ATTR_D,
    .ident_gen_type = IOP_RPC_GEN_ATTR_O,
    .help_type = IOP_RPC_ATTR_EXN_HELP_V2,
};

/* TODO SNMP attrs. */

static unsigned iopc_attr_kind_get_gen_type(const iopc_attr_kind_t *attr_kind,
                                            iopc_tok_type_t tok_type)
{
    switch (tok_type) {
    case ITOK_STRING:
        return attr_kind->str_gen_type;

    case ITOK_INTEGER:
        return attr_kind->int_gen_type;

    case ITOK_BOOL:
        return attr_kind->bool_gen_type;

    case ITOK_DOUBLE:
        return attr_kind->double_gen_type;

    case ITOK_IDENT:
        return attr_kind->ident_gen_type;

    default:
        assert(false);
        return 0;
    }
}

/*}}} */
/*{{{ doxygen */

static void write_string(sb_t *buf, const char *s, const char *escaped_chars)
{
    for (;; s++) {
        const char *c;

        for (c = s; isprint(*c) && *c != '"'; c++) {
            for (const char *ec = escaped_chars; *ec ; ec++) {
                if (*c == *ec)
                    goto write_chars;
            }
        }
      write_chars:
        sb_add(buf, s, c - s);
        s = c;

        if (!*s)
            break;
        sb_addf(buf, "\\%03o", (uint8_t)*s);
    }
}

static void write_help_string(sb_t *buf, const char *s)
{
    write_string(buf, s, "\\");
}

#define NAME_FIELD_FMT  "%s__%s"
#define NAME_FIELD_FMT_ARG(_pfx, _ext) _pfx, _ext

#define NAME_HELP_FMT NAME_FIELD_FMT"_help"
#define NAME_HELP_FMT_ARG(_pfx, _ext) NAME_FIELD_FMT_ARG(_pfx, _ext)

static bool has_help(const qv_t(iopc_dox) *comments)
{
    for (int i = 0; i <= IOPC_DOX_TYPE_SIMPLE; i++) {
        if (iopc_dox_find_type(comments, i)) {
            return true;
        }
    }
    return false;
}

static void
iopc_dump_help(sb_t *buf, const iopc_attr_kind_t *attr_kind,
               const char *help_var_pfx,
               const qv_t(iopc_dox) *comments)
{
    sb_addf(buf, "static const iop_help_t "NAME_HELP_FMT
                 " = {\n",
                 NAME_HELP_FMT_ARG(help_var_pfx, attr_kind->ext));

    for (int i = 0; i <= IOPC_DOX_TYPE_SIMPLE; i++) {
        const iopc_dox_t *dox = iopc_dox_find_type(comments, i);
        lstr_t type;

        if (!dox) {
            continue;
        }

        type = iopc_dox_type_to_lstr(i);
        sb_addf(buf, "    .%*pM = ", LSTR_FMT_ARG(type));
        if (!dox->desc.len) {
            sb_adds(buf, "LSTR_NULL,\n");
        } else {
            sb_adds(buf, "LSTR_IMMED(\"");
            write_help_string(buf, dox->desc.s);
            sb_adds(buf, "\"),\n");
        }
    }
    sb_addf(buf, "};\n");
}

static void
iopc_dump_help_ref(sb_t *buf, const iopc_attr_kind_t *attr_kind,
                   const char *help_var_pfx)
{
    sb_addf(buf, "    {\n"
                 "        .type = %d,\n"
                 "        .args = (%s[]){ { .v.p = &"NAME_HELP_FMT" } },\n"
                 "    },\n",
            attr_kind->help_type, attr_kind->attr_arg_typename,
            NAME_HELP_FMT_ARG(help_var_pfx, attr_kind->ext));
}

static void
iopc_dump_help_and_ref(sb_t *buf_help, sb_t *buf_ref,
                       const iopc_attr_kind_t *attr_kind,
                       const char *help_var_pfx,
                       const qv_t(iopc_dox) *comments)
{
    if (has_help(comments)) {
        iopc_dump_help(buf_help, attr_kind, help_var_pfx, comments);
        iopc_dump_help_ref(buf_ref, attr_kind, help_var_pfx);
    }
}

static void
iopc_dump_attr_table_head(sb_t *buf, const iopc_attr_kind_t *attr_kind,
                          const char *attr_table_var_pfx)
{
    sb_addf(buf, "static const %s "NAME_FIELD_FMT"_attrs[] = {\n",
            attr_kind->attr_typename,
            NAME_FIELD_FMT_ARG(attr_table_var_pfx, attr_kind->ext));
}

static void
iopc_dump_attrs_ref(sb_t *buf, unsigned int flags, uint16_t attrs_len,
                    const char *attr_table_var_pfx, bool is_in_array,
                    const char *ext)
{
    const char *tabs = is_in_array ? "    " : "";

    sb_addf(buf,
            "%s{\n"
            "%s    .flags     = %u,\n",
            tabs, tabs, flags);

    if (attrs_len) {
        sb_addf(buf,
            "%s    .attrs_len = %u,\n"
            "%s    .attrs     = "NAME_FIELD_FMT"_attrs,\n",
            tabs, attrs_len,
            tabs, NAME_FIELD_FMT_ARG(attr_table_var_pfx, ext));
    }
    sb_addf(buf,
            "%s}%s\n",
            tabs, is_in_array ? "," : ";");
}

/*}}} */
/*{{{ attributes */

/* TODO Move the function definition here. */
static void iopc_dump_attrs(const iopc_attr_kind_t *attr_kind,
                            const qv_t(iopc_dox) *comments,
                            const qv_t(iopc_attr) *attrs,
                            const char *var_name_pfx,
                            sb_t *buf, bool *has_attrs);
/*}}} */

static void
iopc_enum_dump_tdef_hdr(sb_t *buf, const char *pkg_name,
                        const iopc_enum_t *en)
{
    t_scope;
    const char *tname = pp_to_c(en->name);
    char *tbase = t_fmt("%s__%s", pkg_name, tname);
    int next_value = 0;
    lstr_t ns = t_enum_get_prefix(en);
    int min = INT_MAX;
    int max = INT_MIN;

    sb_addf(buf, "typedef enum %s__t {\n", tbase);

    tab_for_each_entry(f, &en->values) {
        sb_addf(buf, "    %*pM_%s", LSTR_FMT_ARG(ns), f->name);
        if (f->value == next_value++) {
            sb_adds(buf, ",\n");
        } else {
            sb_addf(buf, " = %d,\n", f->value);
            next_value = f->value + 1;
        }
        if (f->value > max)
            max = f->value;
        if (f->value < min)
            min = f->value;
        tab_for_each_entry(attr, &f->attrs) {
            if (attr->desc->id == IOPC_ATTR_ALIAS) {
                tab_for_each_entry(alias, &attr->args) {
                    sb_addf(buf, "    %*pM_%*pM", LSTR_FMT_ARG(ns),
                            LSTR_FMT_ARG(alias.v.s));
                    sb_addf(buf, " = %*pM_%s,\n", LSTR_FMT_ARG(ns), f->name);
                }
            }
        }
    }
    sb_addf(buf, "} %s__t;\n", tbase);
    sb_addf(buf,
            "typedef IOP_ARRAY_OF(enum %s__t) %s__array_t;\n",
            tbase, tbase);
    sb_addf(buf,
            "#ifdef OPT_OF\n"
            "typedef OPT_OF(enum %s__t) %s__opt_t;\n"
            "#else\n"
            "typedef IOP_OPT_OF(enum %s__t) %s__opt_t;\n"
            "#endif\n",
            tbase, tbase, tbase, tbase);
    sb_addf(buf,
            "#define %*pM_count %d\n"
            "#define %*pM_min   %d\n"
            "#define %*pM_max   %d\n",
            LSTR_FMT_ARG(ns), en->values.len, LSTR_FMT_ARG(ns), min,
            LSTR_FMT_ARG(ns), max);
    sb_addc(buf, '\n');
}

static void
iopc_enum_dump_hdr(sb_t *buf, const char *pkg_name, const iopc_enum_t *en)
{
    t_scope;
    const char *tname = pp_to_c(en->name);
    char *tbase = t_fmt("%s__%s", pkg_name, tname);

    sb_addf(buf,
            "EXPORT iop_enum_t const %s__e;\n"
            "EXPORT iop_enum_t const * const nonnull %s__ep;\n",
            tbase, tbase);

    sb_addc(buf, '\n');

    iopc_gen_ctype(buf, &en->attrs, tbase, IOP_T_ENUM, -1);
}


static void
iopc_struct_dump_tdef_hdr(sb_t *buf, const char *pkg_name,
                          const iopc_struct_t *st, const char *ns)
{
    t_scope;
    const char *tname = pp_to_c(st->name);
    char *tbase = t_fmt("%s__%s", ns ?: pkg_name, tname);

    sb_addf(buf,
            "typedef struct %s__t %s__t;\n"
            "typedef IOP_ARRAY_OF(%s__t%s%s) %s__array_t;\n\n",
            tbase, tbase, tbase, iopc_is_class(st->type) ? " *" : "",
            iopc_is_class(st->type) ? "nonnull " : "",
            tbase);
}

static const char *iopc_field_type(const iopc_field_t *f)
{
    switch (f->kind) {
      case IOP_T_U8:     return "uint8_t  ";
      case IOP_T_I8:     return "int8_t   ";
      case IOP_T_U16:    return "uint16_t ";
      case IOP_T_I16:    return "int16_t  ";
      case IOP_T_U32:    return "uint32_t ";
      case IOP_T_I32:    return "int32_t  ";
      case IOP_T_U64:    return "uint64_t ";
      case IOP_T_I64:    return "int64_t  ";
      case IOP_T_BOOL:   return "bool     ";
      case IOP_T_DOUBLE: return "double   ";
      case IOP_T_STRING: return "lstr_t   ";
      case IOP_T_DATA:   return "lstr_t   ";
      case IOP_T_XML:    return "lstr_t   ";
      case IOP_T_ENUM:   return "enum ";

      default:
        warn_loc("attribute type not handled for this kind", f->loc);
        assert (false);
        return NULL;
    }
}

static void
iopc_snmp_field_dump_tdef_hdr(sb_t *buf, const char *pkg_name,
                              const iopc_struct_t *st,
                              const iopc_field_t *field)
{
    t_scope;
    const char *tname = pp_to_c(st->name);
    const char *fname = pp_to_c(field->name);
    char *tbase = t_fmt("%s__%s__%s", pkg_name, tname, fname);

    if (field->kind == IOP_T_ENUM) {
        sb_addf(buf, "typedef %s %s__%s__t %s_typedef__t;\n",
                iopc_field_type(field), pp_under(field->type_path),
                pp_to_c(field->type_name), tbase);
        return;
    }

    sb_addf(buf, "typedef %s %s_typedef__t;\n",
            iopc_field_type(field), tbase);
}


static void
iopc_struct_dump_fields(sb_t *buf, int ident, const qv_t(iopc_field) *fields)
{
    tab_for_each_entry(f, fields) {
        pp_field_with_type(buf, f, ident);
    }
}

static void
iopc_struct_dump_snmp_fields(sb_t *buf, int ident,
                             const qv_t(iopc_field) *fields)
{
    tab_for_each_entry(f, fields) {
        pp_field_with_type(buf, f->field_origin, ident);
    }
}

static void iopc_struct_dump_hdr_class(sb_t *buf, iopc_struct_t *st)
{
    qv_t(iopc_struct) parents;
    qv_t(iopc_pkg)    parents_pkgs;
    int ident;

    if (!st->extends.len || st->extends.tab[0]->is_snmp_root) {
        sb_adds(buf, "    const iop_struct_t *nonnull __vptr;\n");
        return;
    }

    /* Get parents list; last element of vector will be the master class, and
     * the first one the nearest parent. */
    qv_init(&parents);
    qv_init(&parents_pkgs);
    do {
        qv_append(&parents_pkgs, st->extends.tab[0]->pkg);
        st = st->extends.tab[0]->st;
        qv_append(&parents, st);
    } while (st->extends.len && !st->extends.tab[0]->is_snmp_root);

    sb_addnc(buf, 4, ' ');
    sb_adds(buf, "union {\n");
    sb_addnc(buf, 8, ' ');
    sb_addf(buf, "struct %s__%s__t super;\n",
            pp_under(parents_pkgs.tab[0]->name),
            pp_to_c(parents.tab[0]->name));

    /* Print parent structure */
    for (ident = 8; ident <= 4 * parents.len + 4; ident += 4) {
        sb_addnc(buf, ident, ' ');
        sb_adds(buf, "struct {\n");
    }
    sb_addnc(buf, ident, ' ');
    sb_adds(buf, "const iop_struct_t *nonnull __vptr;\n");

    tab_for_each_pos_safe(pos, &parents) {
        st = parents.tab[pos];
        sb_addnc(buf, ident, ' ');
        sb_addf(buf, "/* fields of %s__%s__t */\n",
                pp_under(parents_pkgs.tab[pos]->name), pp_to_c(st->name));
        iopc_struct_optimize(st);
        iopc_struct_dump_fields(buf, ident, &st->fields_in_c_struct_order);
        ident -= 4;
        sb_addnc(buf, ident, ' ');
        sb_adds(buf, "};\n");
    }

    sb_addnc(buf, 4, ' ');
    sb_adds(buf, "};\n");

    qv_wipe(&parents);
    qv_wipe(&parents_pkgs);
}

static void iopc_struct_dump_hdr(sb_t *buf, const iopc_pkg_t *pkg,
                                 const char *pkg_name, iopc_struct_t *st,
                                 const char *ns)
{
    t_scope;
    const char *tname = pp_to_c(st->name);
    char *tbase = t_fmt("%s__%s", ns ?: pkg_name, tname);

    assert (st->type != STRUCT_TYPE_UNION);

    if (st->c_hdr_written) {
        return;
    }

    st->c_hdr_written = true;
    iopc_struct_optimize(st);

    if (!iopc_is_snmp_obj(st->type)) {
        if (iopc_is_class(st->type) && st->extends.len
        &&  pkg == st->extends.tab[0]->pkg)
        {
            iopc_struct_dump_hdr(buf, st->extends.tab[0]->pkg, pkg_name,
                                 st->extends.tab[0]->st, ns);
        }

        sb_addf(buf, "struct %s__t {\n", tbase);

        if (iopc_is_class(st->type)) {
            iopc_struct_dump_hdr_class(buf, st);
        }

        if (st->contains_snmp_info) {
            iopc_struct_dump_snmp_fields(buf, 4,
                                         &st->fields_in_c_struct_order);
        } else {
            iopc_struct_dump_fields(buf, 4, &st->fields_in_c_struct_order);
        }

        sb_adds(buf, "};\n");
    }
    sb_addf(buf, "EXPORT iop_struct_t const %s__s;\n", tbase);
    sb_addf(buf, "EXPORT iop_struct_t const * const nonnull %s__sp;\n",
            tbase);
    if (iopc_is_class(st->type)) {
        sb_addf(buf, "#define %s__class_id  %d\n\n", tbase, st->class_id);
        iopc_gen_ctype(buf, &st->attrs, tbase, IOP_T_STRUCT, st->class_id);
    } else
    if (!iopc_is_snmp_st(st->type)) {
        iopc_gen_ctype(buf, &st->attrs, tbase, IOP_T_STRUCT, -1);
    }
}

static void iopc_snmp_field_dump_hdr(sb_t *buf, const char *pkg_name,
                                     const iopc_struct_t *st,
                                     const iopc_field_t *field)
{
    t_scope;
    const char *tname = pp_to_c(st->name);
    const char *fname = pp_to_c(field->name);
    char *tbase = t_fmt("%s__%s__%s", pkg_name, tname, fname);

    sb_addf(buf, "EXPORT iop_snmp_attrs_t const %s__snmp_attrs__s;\n", tbase);
    if (iopc_is_snmp_tbl(st->type)) {
        sb_addf(buf, "#define %s__oid  %d\n\n", tbase, field->tag);
    }
}

static void iopc_union_dump_tag_cst(sb_t *buf, const char *tbase,
                                    const iopc_struct_t *st)
{
#define VOID_TAG_ALIAS(buf, f, tbase, name)  \
    if (f->kind == IOP_T_VOID && f->repeat == IOP_R_REQUIRED) {              \
        sb_addf(buf, "#define %*pM__%s__empty_ft  %*pM__%s__ft\n",           \
                LSTR_FMT_ARG(tbase), name, LSTR_FMT_ARG(tbase), name);       \
    }

    sb_addf(buf, "typedef enum %s__tag_t {\n", tbase);
    tab_for_each_entry(f, &st->fields_by_tag) {
        /* Tag of the field (enum) */
        sb_addf(buf, "    %s__%s__ft = %d,\n", tbase, pp_to_c(f->name),
                f->tag);
        VOID_TAG_ALIAS(buf, f, LSTR(tbase), pp_to_c(f->name));
    }
    sb_addf(buf, "} %s__tag_t;\n", tbase);

    tab_for_each_entry(attr, &st->attrs) {
        if (attr->desc->id == IOPC_ATTR_CTYPE) {
            tab_for_each_ptr(arg, &attr->args) {
                lstr_t ctype;

                assert (lstr_endswith(arg->v.s, LSTR("__t")));
                ctype = LSTR_INIT_V(arg->v.s.s, arg->v.s.len - 3);
                sb_addf(buf, "typedef %s__tag_t %*pM__tag_t;\n", tbase,
                        LSTR_FMT_ARG(ctype));
                tab_for_each_entry(f, &st->fields) {
                    sb_addf(buf, "#define %*pM__%s__ft %s__%s__ft\n",
                            LSTR_FMT_ARG(ctype), pp_to_c(f->name),
                            tbase, pp_to_c(f->name));
                    VOID_TAG_ALIAS(buf, f, ctype, pp_to_c(f->name));
                }
            }
        }
    }
#undef VOID_ALIAS
}

static void iopc_union_dump_fdesc_cst(sb_t *buf, const char *tbase,
                                    const iopc_struct_t *st)
{
    tab_enumerate(pos, f, &st->fields_by_tag) {
        sb_addf(buf, "#define %s__%s__fdesc  %s__s.fields[%d]\n",
                tbase, pp_to_c(f->name), tbase, pos);
    }

    tab_for_each_entry(attr, &st->attrs) {
        if (attr->desc->id == IOPC_ATTR_CTYPE) {
            tab_for_each_ptr(arg, &attr->args) {
                lstr_t ctype;

                assert (lstr_endswith(arg->v.s, LSTR("__t")));
                ctype = LSTR_INIT_V(arg->v.s.s, arg->v.s.len - 3);

                tab_for_each_entry(f, &st->fields_by_tag) {
                    sb_addf(buf, "#define %*pM__%s__fdesc  %s__%s__fdesc\n",
                            LSTR_FMT_ARG(ctype), pp_to_c(f->name),
                            tbase, pp_to_c(f->name));
                }
            }
        }
    }
}

static void iopc_union_dump_hdr(sb_t *buf, const char *pkg_name,
                                iopc_struct_t *st)
{
    t_scope;
    const char *tname = pp_to_c(st->name);
    char *tbase = t_fmt("%s__%s", pkg_name, tname);

    assert (st->type == STRUCT_TYPE_UNION);

    iopc_struct_optimize(st);

    sb_adds(buf, "/*----- XXX private data, do not use directly -{{{-*/\n");

    iopc_union_dump_tag_cst(buf, tbase, st);
    sb_addc(buf, '\n');
    iopc_union_dump_fdesc_cst(buf, tbase, st);
    sb_adds(buf, "/*-}}}-*/\n");

    sb_addf(buf, "struct %s__t {\n", tbase);
    sb_addf(buf, "    %s__tag_t iop_tag;\n", tbase);
    sb_addf(buf, "    union {\n");
    tab_for_each_entry(f, &st->fields_in_c_struct_order) {
        pp_field_with_type(buf, f, 8);
    }
    sb_addf(buf, "    };\n"
            "};\n"
            "EXPORT iop_struct_t const %s__s;\n"
            "EXPORT iop_struct_t const * const nonnull %s__sp;\n",
            tbase, tbase);

    /* Get & copy functions */
    sb_addf(buf, "#define %s__get(u, field)       "
            "IOP_UNION_GET(%s, u, field)\n",
            tbase, tbase);

    iopc_gen_ctype(buf, &st->attrs, tbase, IOP_T_UNION, -1);
}

static int iopc_fun_n_aliases(const iopc_fun_t *fun)
{
    tab_for_each_entry(attr, &fun->attrs) {
        if (attr->desc->id == IOPC_ATTR_ALIAS) {
            return attr->args.len;
        }
    }
    return 0;
}

static void
iopc_fun_struct_dump_tdef_hdr(sb_t *buf, const char *pkg_name,
                              const char *ibase, const char *fbase,
                              const char *fun_type, iopc_fun_struct_t *fun_st)
{
    if (iopc_fun_struct_is_void(fun_st)) {
        sb_addf(buf, "typedef iop__void__t %s_%s__t;\n", fbase, fun_type);
    } else {
        if (fun_st->is_anonymous) {
            iopc_struct_dump_tdef_hdr(buf, pkg_name, fun_st->anonymous_struct,
                                      ibase);
        } else {
            /* When the function argument is just a reference to another
             * structure, we just yield several alias using macros */
            sb_addf(buf, "typedef %s__%s__t %s_%s__t;\n",
                    pp_under(fun_st->existing_struct->type_path),
                    pp_to_c(fun_st->existing_struct->type_name), fbase,
                    fun_type);
        }
    }
}

static void
iopc_iface_dump_tdef_hdr(sb_t *buf, const char *pkg_name, iopc_iface_t *iface)
{
    t_scope;
    const char *iname = pp_to_c(iface->name);
    const char *ibase = t_fmt("%s__%s", pkg_name, iname);

    tab_for_each_entry(fun, &iface->funs) {
        const char *fbase = t_fmt("%s__%s", ibase, pp_to_c(fun->name));

        iopc_fun_struct_dump_tdef_hdr(buf, pkg_name, ibase, fbase, "args",
                                      &fun->arg);
        iopc_fun_struct_dump_tdef_hdr(buf, pkg_name, ibase, fbase, "res",
                                      &fun->res);
        iopc_fun_struct_dump_tdef_hdr(buf, pkg_name, ibase, fbase, "exn",
                                      &fun->exn);
    }
}

static void
iopc_fun_struct_dump_hdr(sb_t *buf, const iopc_pkg_t *pkg,
                         const char *pkg_name, const char *ibase,
                         iopc_fun_struct_t *fun_st)
{
    if (fun_st->is_anonymous && fun_st->anonymous_struct) {
        iopc_struct_dump_hdr(buf, pkg, pkg_name, fun_st->anonymous_struct,
                             ibase);
    }
}

static void
iopc_iface_dump_hdr(sb_t *buf, const iopc_pkg_t *pkg,
                    const char *pkg_name, iopc_iface_t *iface)
{
    t_scope;
    const char *iname = pp_to_c(iface->name);
    char *ibase = t_fmt("%s__%s", pkg_name, iname);
    int j = 0;

    if (!iface->funs.len)
        return;

    sb_addf(buf,
            "/*----- interface %s.%s -----*/\n",
            pretty_path_dot(pkg->name), iface->name);

    tab_for_each_entry(fun, &iface->funs) {
        char *fbase = t_fmt("%s__%s", ibase, pp_to_c(fun->name));

        iopc_fun_struct_dump_hdr(buf, pkg, pkg_name, ibase, &fun->arg);
        iopc_fun_struct_dump_hdr(buf, pkg, pkg_name, ibase, &fun->res);
        iopc_fun_struct_dump_hdr(buf, pkg, pkg_name, ibase, &fun->exn);

        sb_addf(buf,
                "#define %s__rpc__tag    0x%04x\n"
                "#define %s__rpc__async  %d\n"
                "#define %s__rpc         (%s__if.funs + %d)\n\n",
                fbase, fun->tag, fbase, fun->fun_is_async, fbase, ibase, j);
        j += 1 + iopc_fun_n_aliases(fun);
    }
    sb_addf(buf, "EXPORT iop_iface_t const %s__if;\n", ibase);
    sb_addf(buf, "EXPORT iop_iface_t const * const nonnull %s__ifp;\n\n",
            ibase);
}

static void
iopc_module_dump_hdr(sb_t *buf, const iopc_pkg_t *pkg,
                     const char *pkg_name, iopc_struct_t *mod)
{
    t_scope;
    char *mbase = t_fmt("%s__%s", pkg_name, pp_to_c(mod->name));

    sb_addf(buf,
            "\n"
            "/*----- module %s.%s -----*/\n",
            pretty_path_dot(pkg->name), mod->name);

    iopc_struct_build_fields_by_tag(mod);
    assert(mod->fields_by_tag.len == mod->fields.len);
    for (int i = 0; i < mod->fields_by_tag.len; i++) {
        iopc_field_t *f = mod->fields_by_tag.tab[i];

        sb_addf(buf,
                "#define %s__%s__TAG    0x%04x\n"
                "#define %s__%s(a)      %s__%s__##a\n"
                "#define %s__%s__alias  (%s__mod.ifaces + %d)\n\n",
                mbase, pp_to_c(f->name), f->tag,
                mbase, pp_to_c(f->name),
                pp_under(f->type_path), pp_to_c(f->type_name),
                mbase, pp_to_c(f->name), mbase, i);
    }
    sb_addf(buf,
            "EXPORT iop_mod_t const %s__mod;\n"
            "EXPORT iop_mod_t const * const nonnull %s__modp;\n"
            "\n", mbase, mbase);
}

static void
iopc_pkg_dump_hdr(sb_t *buf, iopc_pkg_t *pkg, const char *pkg_name)
{
    sb_addf(buf,
            "\n"
            "/*----- package %s -----*/\n"
            "EXPORT iop_pkg_t const %s__pkg;\n"
            "EXPORT iop_pkg_t const * const nonnull %s__pkgp;\n"
            "\n",
            pretty_path_dot(pkg->name), pkg_name, pkg_name);
}

static char const * const repeats[] = {
    [IOP_R_OPTIONAL] = "IOP_R_OPTIONAL",
    [IOP_R_DEFVAL]   = "IOP_R_DEFVAL",
    [IOP_R_REQUIRED] = "IOP_R_REQUIRED",
    [IOP_R_REPEATED] = "IOP_R_REPEATED",
};
static char const * const types[] = {
#define ITEM(n)  [IOP_T_##n] = TOSTR(IOP_T_##n)
    ITEM(U8),  ITEM(I8),
    ITEM(U16), ITEM(I16),
    ITEM(U32), ITEM(I32),
    ITEM(U64), ITEM(I64),
    ITEM(BOOL),
    ITEM(ENUM),
    ITEM(DOUBLE),
    ITEM(STRING),
    ITEM(DATA),
    ITEM(XML),
    ITEM(UNION),
    ITEM(STRUCT),
    ITEM(VOID),
#undef ITEM
};

static void defval_escape(sb_t *sb, const void *ptr)
{
    write_string(sb, ptr, "?");
}

/** Process the value of the flags associated to an IOP field. */
static unsigned iopc_field_build_flags(const iopc_field_t *nonnull f,
                                       const iopc_struct_t *nonnull st,
                                       const iopc_attrs_t *nullable attrs)
{
    unsigned flags = 0;

    if (f->is_ref) {
        SET_BIT(&flags, IOP_FIELD_IS_REFERENCE);
    }
    if (attrs && attrs->checkf_name.len) {
        SET_BIT(&flags, IOP_FIELD_CHECK_CONSTRAINTS);
    }
    if (f->snmp_is_from_param || iopc_is_snmp_st(st->type)) {
        SET_BIT(&flags, IOP_FIELD_HAS_SNMP_INFO);
    }
    tab_for_each_entry(attr, &f->attrs) {
        if (attr->desc->id == IOPC_ATTR_SNMP_INDEX) {
            SET_BIT(&flags, IOP_FIELD_IS_SNMP_INDEX);
        } else
        if (attr->desc->id == IOPC_ATTR_MIN_OCCURS) {
            SET_BIT(&flags, 1 /* IOP_FIELD_NO_EMPTY_ARRAY */);
            break;
        }
    }

    return flags;
}

static void
iopc_dump_field_src(sb_t *buf, const iopc_struct_t *st, const char *tbase,
                    const iopc_field_t *f, const iopc_attrs_t *attrs)
{
    unsigned flags = 0;
    const char *cname = pp_to_c(f->name);
    iop_type_t kind = f->kind;

    /* IOPC fields with types taken from IOP environment cannot be dumped to C
     * code. */
    assert (!f->has_external_type);

    /* If the field is a field of a snmp rpc' struct, it is needed to get the
     * real type of the field, which is the one of field_origin */
    if (f->snmp_is_from_param) {
       kind = f->field_origin->kind;
    }

    sb_addf(buf,
            "    {\n"
            "        .name      = LSTR_IMMED(\"%s\"),\n"
            "        .tag       = %d,\n"
            "        .tag_len   = %d,\n"
            "        .repeat    = %s,\n"
            "        .type      = %s,\n",
            f->name, f->tag, iopc_tag_len(f->tag),
            repeats[f->repeat], types[kind]);

    if (!iopc_is_snmp_obj(st->type)) {
        if (iopc_struct_is_field_ignored(f)) {
            if (st->type == STRUCT_TYPE_UNION) {
                assert(st->fields_by_tag.len == st->fields.len);
                tab_for_each_entry(f2, &st->fields_by_tag) {
                    if (!iopc_struct_is_field_ignored(f2)) {
                        sb_addf(buf,
                                "        .data_offs = offsetof(%s__t, %s),\n",
                                tbase, pp_to_c(f2->name));
                        break;
                    }
                }
            }
        } else {
            sb_addf(buf,
                    "        .data_offs = offsetof(%s__t, %s),\n",
                    tbase, cname);
        }
    }

    flags = iopc_field_build_flags(f, st, attrs);
    if (flags) {
        sb_addf(buf, "        .flags     = %u,\n", flags);
    }

    if (f->repeat == IOP_R_DEFVAL) {
        t_scope;
        sb_t sb;

        t_sb_init(&sb, BUFSIZ);
        switch (f->kind) {
          case IOP_T_ENUM:
            sb_addf(buf,
                    "        .u0        = { .defval_enum = %jd },\n",
                    f->defval.u64);
            break;
          case IOP_T_I8 ... IOP_T_U64:
            sb_addf(buf,
                    "        .u1        = { .defval_u64 = 0x%jx },\n",
                    f->defval.u64);
            break;
          case IOP_T_BOOL:
            sb_addf(buf,
                    "        .u1        = { .defval_u64 = %s },\n",
                    f->defval.u64 ? "true" : "false");
            break;
          case IOP_T_DOUBLE:
            sb_addf(buf,
                    "        .u1        = { .defval_d = "DOUBLE_FMT" },\n",
                    f->defval.d);
            break;
          case IOP_T_STRING:
          case IOP_T_DATA:
          case IOP_T_XML:
            /* Perform an octal escaping */
            defval_escape(&sb, f->defval.ptr);
            sb_addf(buf,
                    "        .u0        = { .defval_len  = %zd },\n"
                    "        .u1        = { .defval_data = \"%s\" },\n",
                    strlen(f->defval.ptr), sb.data);
            break;

          default:
            break;
        }
    }

    if (f->kind == IOP_T_STRUCT || f->kind == IOP_T_UNION) {
        /* XXX: Fields of type class are ALWAYS pointed, and the size of
         *      a class type is uninformative (we have to know the real
         *      instanciated class to know the size), so write the size of
         *      the pointer in that case, this will simplify some code during
         *      packing/unpacking. */
        sb_addf(buf,
                "        .size      = sizeof(%s__%s__t%s),\n"
                "        .u1        = { .st_desc = &%s__%s__s },\n",
                pp_under(f->type_path), pp_to_c(f->type_name),
                f->struct_def->type == STRUCT_TYPE_CLASS ? " *" : "",
                pp_under(f->type_path), pp_to_c(f->type_name));
    } else if (f->repeat == IOP_R_REPEATED) {
        /* void arrays only have a length, no data */
        if (f->kind != IOP_T_VOID) {
            sb_addf(buf,
                    "        .size      = fieldsizeof(%s__t, %s.tab[0]),\n",
                    tbase, cname);
        }
    } else
    if (!iopc_is_snmp_st(st->type)) {
        /* required void fields are never physically present */
        if (!iopc_struct_is_field_ignored(f)) {
            sb_addf(buf,
                    "        .size      = fieldsizeof(%s__t, %s),\n",
                    tbase, cname);
        }
    }
    if (f->kind == IOP_T_ENUM) {
        sb_addf(buf,
                "        .u1        = { .en_desc = &%s__%s__e },\n",
                pp_under(f->type_path),
                pp_to_c(f->type_name));
    }
    sb_addf(buf, "    },\n");
}

#define ATTR_HELP(_what) IOP_##_what##_ATTR_HELP_V2

static void
iopc_dump_static_field_src(sb_t *buf, const iopc_field_t *f, const char *name)
{
    lstr_t type;
    const iopc_attr_kind_t *attr_kind = &iopc_attr_kind_static_field_g;

    iopc_dump_attrs(attr_kind, &f->comments, NULL, name, buf, NULL);

    sb_addf(buf,
            "static const iop_static_field_t %s = {\n"
            "    .name  = LSTR_IMMED(\"%s\"),\n"
            "    .value = ",
            name, f->name);

    switch (f->kind) {
      case IOP_T_U8:
      case IOP_T_U16:
      case IOP_T_U32:
      case IOP_T_U64:
        sb_addf(buf, "{ .u = %ju },\n", f->defval.u64);
        type = LSTR("IOP_T_U64");
        break;

      case IOP_T_DOUBLE:
        sb_addf(buf, "{ .d = %.17e },\n", f->defval.d);
        type = LSTR("IOP_T_DOUBLE");
        break;

      case IOP_T_BOOL:
        sb_addf(buf, "{ .b = %s },\n",
                f->defval.u64 ? "true" : "false");
        type = LSTR("IOP_T_BOOL");
        break;

      case IOP_T_STRING:
      case IOP_T_DATA:
      case IOP_T_XML:
        sb_adds(buf, "{ .s = LSTR_IMMED(\"");
        defval_escape(buf, f->defval.ptr);
        sb_adds(buf, "\") },\n");
        type = LSTR("IOP_T_STRING");
        break;

      default:
        sb_addf(buf, "{ .i = %jd },\n", f->defval.u64);
        type = LSTR("IOP_T_I64");
        break;
    }
    sb_addf(buf, "    .type  = %*pM,\n", LSTR_FMT_ARG(type));

    if (has_help(&f->comments)) {
        sb_addf(buf, "    .attrs = &%s__%s,\n", name,
                attr_kind->attrs_var_sfx);
    }

    sb_addf(buf, "};\n");
}

static void
iopc_struct_dump_static_fields_src(sb_t *buf, iopc_struct_t *st,
                                   const char *tbase)
{
    t_scope;
    int index_field;

    if (unlikely(!st->nb_real_static_fields)) {
        return;
    }
    assert (iopc_is_class(st->type));

    sb_addc(buf, '\n');

    /* Generate static fields structures */
    qv_sort(iopc_field)(&st->static_fields,
        ^int (iopc_field_t * const *f1, iopc_field_t * const *f2)
    {
        return strcmp((*f1)->name, (*f2)->name);
    });
    index_field = 0;
    tab_for_each_entry(f, &st->static_fields) {
        if (!f->defval_type) {
            continue;
        }
        iopc_dump_static_field_src(buf, f, t_fmt("%s__static_field_%d",
                                                 tbase, index_field));
        index_field++;
    }

    /* generate <tbase>__static_fields */
    sb_addf(buf,
            "static const iop_static_field_t *%s__static_fields[] = {\n",
            tbase);
    index_field = 0;
    tab_for_each_entry(f, &st->static_fields) {
        if (!f->defval_type) {
            continue;
        }
        sb_addf(buf, "    &%s__static_field_%d,\n", tbase, index_field);
        index_field++;
    }
    sb_adds(buf, "};\n\n");
}

int iopc_field_get_signed(const iopc_field_t *f, bool *is_signed)
{
    switch (f->kind) {
      case IOP_T_I8:
      case IOP_T_I16:
      case IOP_T_I32:
      case IOP_T_I64:
      case IOP_T_ENUM:
      case IOP_T_DOUBLE:
        *is_signed = true;
        break;
      case IOP_T_U8:
      case IOP_T_U16:
      case IOP_T_U32:
      case IOP_T_U64:
      case IOP_T_BOOL:
        *is_signed = false;
        break;
      default:
        throw_error("expected numerical type, got %d", f->kind);
    }

    return 0;
}

#define LVL1 "    "
#define LVL2 LVL1 LVL1
#define LVL3 LVL2 LVL1
#define LVL4 LVL2 LVL2
#define LVL5 LVL3 LVL2

/* {{{ Generic attributes helpers */

/* Dump a generic attribute */
static void iopc_dump_gen_attr(sb_t *buf, const iopc_attr_t *attr,
                               unsigned type)
{
    SB_1k(tmp);
    assert (attr->args.len == 1);

    /* Generic attributes have only one argument, their values. But we
     * want to write two arguments in the generated .c file: the name of
     * the attribute, and its value
     */

    /* First argument: name of the generic attribute */
    sb_addf(buf,
            LVL1 "{\n"
            LVL1 "    .type = %d,\n"
            LVL1 "    .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED(\"%*pM\") }, ",
            type, LSTR_FMT_ARG(attr->real_name));

    /* Second argument: value of the generic attribute */
    switch (attr->args.tab[0].type) {
      case ITOK_IDENT:
        /* JSON object */
        sb_add_slashes(&tmp, attr->args.tab[0].v.s.s,
                       attr->args.tab[0].v.s.len, "\"", "\"");
        sb_addf(buf, "{.v.s = LSTR_IMMED(\"%*pM\") } },\n",
                SB_FMT_ARG(&tmp));
        break;
      case ITOK_STRING:
        sb_add_slashes(&tmp, attr->args.tab[0].v.s.s,
                       attr->args.tab[0].v.s.len,
                       "\a\b\e\t\n\v\f\r'\"", "abetnvfr'\"");
        sb_addf(buf, "{.v.s = LSTR_IMMED(\"%*pM\") } },\n",
                SB_FMT_ARG(&tmp));
        break;
      case ITOK_BOOL:
      case ITOK_INTEGER:
        sb_addf(buf,"{ .v.i64 = %jdUL } },\n",
                IOPC_ATTR_GET_ARG_V(int64_t, &attr->args.tab[0]));
        break;
      case ITOK_DOUBLE:
        sb_addf(buf, "{ .v.d = "DOUBLE_FMT" } },\n",
                IOPC_ATTR_GET_ARG_V(double, &attr->args.tab[0]));
        break;

      default:
        assert(false);
        return;
    }

    sb_addf(buf,
            LVL1 "},\n");

    sb_wipe(&tmp);
}

static void iopc_dump_attrs_ref_body(const iopc_attr_kind_t *attr_kind,
                                     const char *tbase,
                                     lstr_t body, bool is_array, sb_t *buf)
{
    sb_addf(buf, "static const %s %s__%s",
            attr_kind->attrs_typename, tbase, attr_kind->attrs_var_sfx);
    if (is_array) {
        sb_adds(buf, "[] = {\n");
    } else {
        sb_adds(buf, " = ");
    }
    sb_add_lstr(buf, body);
    if (is_array) {
        sb_adds(buf, "};\n");
    }
}

/** Dump the attributes table associated to a given object.
 *
 * \param[in] comments  Comments associated to the object. They may be
 *                      converted into help attributes.
 *
 * \param[in] attrs  Attributes found around the object. If null, then only
 *                   the help attributes extracted from the comments will be
 *                   dumped.
 *
 * \param[out] attrs_flags  Flags to use in the 'attrs' structure associted to
 *                          the object.
 *
 * \param[out] attrs_cnt  Number of attributes dumped.
 */
static void iopc_dump_attr_table(const iopc_attr_kind_t *attr_kind,
                                 const qv_t(iopc_dox) *comments,
                                 const qv_t(iopc_attr) *nullable attrs,
                                 const char *var_name_pfx,
                                 sb_t *buf, unsigned *attrs_flags,
                                 int *attrs_cnt)
{
    SB_1k(attrs_body);
    unsigned nbr_attrs = 0;
    unsigned flags = 0;

    if (has_help(comments)) {
        iopc_dump_help_and_ref(buf, &attrs_body, attr_kind,
                               var_name_pfx, comments);
        SET_BIT(&flags, attr_kind->help_type);
        nbr_attrs++;
    }

    if (attrs) {
        tab_for_each_entry(attr, attrs) {
            unsigned gen_type;

            if (attr->desc->id != IOPC_ATTR_GENERIC) {
                continue;
            }

            gen_type = iopc_attr_kind_get_gen_type(attr_kind,
                                                   attr->args.tab[0].type);
            iopc_dump_gen_attr(&attrs_body, attr, gen_type);
            if (attr_kind->write_gen_attr_flags) {
                SET_BIT(&flags, gen_type);
            }
            nbr_attrs++;
        }
    }

    if (nbr_attrs > 0) {
        iopc_dump_attr_table_head(buf, attr_kind, var_name_pfx);
        sb_addsb(buf, &attrs_body);
        sb_addf(buf, "};\n");
    }

    *attrs_cnt = nbr_attrs;
    *attrs_flags = flags;
}

/** Dump the attributes associated to a given object.
 *
 * Dump the attribute table and the 'attrs' structure associated to the
 * object.
 */
static void iopc_dump_attrs(const iopc_attr_kind_t *attr_kind,
                            const qv_t(iopc_dox) *comments,
                            const qv_t(iopc_attr) *nullable attrs,
                            const char *var_name_pfx,
                            sb_t *buf, bool *has_attrs)
{
    int nbr_attrs;
    unsigned flags;

    iopc_dump_attr_table(attr_kind, comments, attrs, var_name_pfx, buf,
                         &flags, &nbr_attrs);
    if (nbr_attrs > 0) {
        /* Write the 'attrs' structure containing the attributes. */
        SB_1k(attrs_ref_body);

        iopc_dump_attrs_ref(&attrs_ref_body, flags, nbr_attrs, var_name_pfx,
                            false, attr_kind->ext);
        iopc_dump_attrs_ref_body(attr_kind, var_name_pfx,
                                 LSTR_SB_V(&attrs_ref_body), false, buf);
    }
    if (has_attrs) {
        *has_attrs = !!nbr_attrs;
    }
}

/* }}} */

static int
iopc_dump_fieldval_loop(sb_t *buf, const iopc_field_t *f)
{
    const char *type;

    sb_adds(buf, LVL1 "for (int j = 0; j < n; j++) {\n");

    switch (f->kind) {
      case IOP_T_U8:     type = "uint8_t  ";   break;
      case IOP_T_I8:     type = "int8_t   ";   break;
      case IOP_T_U16:    type = "uint16_t ";   break;
      case IOP_T_I16:    type = "int16_t  ";   break;
      case IOP_T_U32:    type = "uint32_t ";   break;
      case IOP_T_I32:    type = "int32_t  ";   break;
      case IOP_T_U64:    type = "uint64_t ";   break;
      case IOP_T_I64:    type = "int64_t  ";   break;
      case IOP_T_BOOL:   type = "bool     ";   break;
      case IOP_T_DOUBLE: type = "double   ";   break;
      case IOP_T_STRING: type = "lstr_t   ";   break;
      case IOP_T_DATA:   type = "lstr_t   "; break;
      case IOP_T_XML:    type = "lstr_t   ";   break;
      case IOP_T_ENUM:
        sb_addf(buf, LVL2 "%s__%s__t val = IOP_FIELD(int32_t, ptr, j);\n\n",
                pp_under(f->type_path),
                pp_to_c(f->type_name));
        return 0;

      case IOP_T_UNION:
        sb_addf(buf, LVL2
                "%s__%s__t *val = &IOP_FIELD(%s__%s__t, ptr, j);\n\n",
                pp_under(f->type_path), pp_to_c(f->type_name),
                pp_under(f->type_path), pp_to_c(f->type_name));
        return 0;

      default:
        throw_error("constraints not supported for fields of kind %d",
                    f->kind);
    }
    sb_addf(buf, LVL2 "%s val = IOP_FIELD(%s, ptr, j);\n\n",
            type, type);
    return 0;
}

static void
iopc_dump_minmax_occurs(sb_t *sb, int cmp, const iopc_attr_t *attr,
                        const iopc_field_t *f)
{
    sb_addf(sb,
            LVL1 "if (n %c %jd) {\n"
            LVL2 "iop_set_err(\"violation of constraint %%s (%%d) "
                 "on field %%s: length=%%d\",\n"
            LVL2 "            \"%*pM\", %jd, \"%s\", n);\n"
            LVL2 "return -1;\n"
            LVL1 "}\n",
            cmp, attr->args.tab[0].v.i64,
            LSTR_FMT_ARG(attr->desc->name), attr->args.tab[0].v.i64, f->name);
}

static void
iopc_dump_minmax_length(sb_t *sb, const char *cmp, const iopc_attr_t *attr,
                        const iopc_field_t *f)
{
    sb_addf(sb,
            LVL2 "if (val.len %s %jd) {\n"
            LVL3 "iop_set_err(\"violation of constraint %%s (%%d) "
                 "on field %%s: length=%%d\",\n"
            LVL3 "            \"%*pM\", %jd, \"%s\", val.len);\n"
            LVL3 "return -1;\n"
            LVL2 "}\n",
            cmp, attr->args.tab[0].v.i64,
            LSTR_FMT_ARG(attr->desc->name), attr->args.tab[0].v.i64, f->name);
}

static inline int get_char(pstream_t *ps, lstr_t *s) {
    int c, d;

    PS_CHECK(c = ps_getc(ps));
    if (c == '\\') {
        /* escaped character */
        PS_CHECK(d = ps_getc(ps));
        switch (d) {
          case '\\':
            *s = LSTR("\\\\");
            return 0;
          case '|': case '.': case '-': case '^': case '?':
          case '*': case '+': case '{': case '}': case '(': case ')':
          case '[': case ']':
            *s = LSTR_INIT_V(ps->s - 1, 1);
            return 0;
          default:
            return -1;
        }
    } else {
        switch (c) {
            /* unsupported regexp special char */
          case '|': case '.': case '-': case '^': case '?':
          case '*': case '+': case '{': case '}': case '(': case ')':
          case '[': case ']':
            return -1;
          default:
            *s = LSTR_INIT_V(ps->s - 1, 1);
            return 0;
        }
    }
}

/* }}} */
/* {{{ Attributes source writing. */

static int
iopc_dump_pattern(sb_t *sb, const iopc_attr_t *attr, const iopc_field_t *f)
{

    SB_1k(sbcase);
    SB_1k(cpattern);
    SB_1k(error);
    bool negative = false;
    lstr_t pattern = attr->args.tab[0].v.s;
    pstream_t ps = ps_initlstr(&pattern);

    PS_WANT(ps_getc(&ps) == '[');

    PS_WANT(ps_has(&ps, 2));
    PS_WANT(ps.b_end[-2] == ']' && ps.b_end[-1] == '*');
    PS_CHECK(ps_shrink(&ps, 2));

    PS_WANT(!ps_done(&ps));
    if (*ps.b == '^') {
        negative = true;
        ps_skip(&ps, 1);
        PS_WANT(!ps_done(&ps));
    }

    while (!ps_done(&ps)) {
        lstr_t start = LSTR_EMPTY_V;

        PS_CHECK(get_char(&ps, &start));

        if (ps_has(&ps, 1) && *ps.b == '-') {
            lstr_t end = LSTR_EMPTY_V;

            __ps_skip(&ps, 1);
            PS_CHECK(get_char(&ps, &end));
            sb_addf(&sbcase, LVL4 "case '%*pM' ... '%*pM':\n",
                    LSTR_FMT_ARG(start), LSTR_FMT_ARG(end));
        } else {
            sb_addf(&sbcase, LVL4 "case '%*pM':\n", LSTR_FMT_ARG(start));
        }
    }

    sb_add_slashes(&cpattern, pattern.s, pattern.len, "\\", "\\");

    sb_addf(&error,
            LVL5 "iop_set_err(\"violation of constraint %%s (%%s) "
                 "on field %%s: %%*pM\",\n"
            LVL5 "            \"%*pM\", \"%*pM\", \"%s\", LSTR_FMT_ARG(val));\n"
            LVL5 "return -1;\n",
            LSTR_FMT_ARG(attr->desc->name),
            cpattern.len, cpattern.data, f->name);

    sb_addf(sb,
            LVL2 "for (int c = 0; c < val.len; c++) {\n"
            LVL3 "switch (val.s[c]) {\n"
                 "%*pM"
                 "%s"
            LVL4 "default:\n"
                 "%s"
            LVL3 "}\n"
            LVL2 "}\n",
            sbcase.len, sbcase.data, negative ? error.data : LVL5 "break;\n",
            negative ? LVL5 "break;\n" : error.data);

    sb_wipe(&error);
    sb_wipe(&sbcase);
    sb_wipe(&cpattern);
    return 0;
}

static void
iopc_dump_case_allow(sb_t *sb, const char *elem_name,
                     const iopc_attr_t *attr, const iopc_field_t *f)
{
    bool is_allow = (attr->desc->id == IOPC_ATTR_ALLOW);
    bool allowed = !is_allow;

    tab_for_each_ptr(arg, &attr->args) {
        if (strequal(elem_name, arg->v.s.s)) {
            allowed = !allowed;
            break;
        }
    }

    if (allowed) {
        sb_addf(sb, LVL2 "    break;\n");
    } else {
        sb_addf(sb, LVL2 "    iop_set_err(\"violation of constraint %s "
                         "(%s) on field %s\");\n"
                    LVL2 "    return -1;\n",
                    is_allow ? "allow" : "disallow", elem_name, f->name);
    }
}

static int iopc_dump_allow_union(sb_t *sb, const iopc_attr_t *attr,
                                 const iopc_field_t *f)
{
    sb_adds(sb, LVL2 "switch (val->iop_tag) {\n");

    tab_for_each_entry(uf, &f->struct_def->fields) {
        sb_addf(sb, LVL2 "  case %s__%s__%s__ft:\n", pp_under(f->type_path),
                pp_to_c(f->type_name), pp_to_c(uf->name));

        iopc_dump_case_allow(sb, uf->name, attr, f);
    }
    sb_adds(sb, LVL2 "}\n");
    return 0;
}

static int
iopc_dump_allow_enum(sb_t *sb, const iopc_attr_t *attr, const iopc_field_t *f)
{
    t_scope;

    sb_adds(sb, LVL2 "switch (val) {\n");

    tab_for_each_entry(ef, &f->enum_def->values) {
        lstr_t prefix = t_enum_get_prefix(f->enum_def);

        sb_addf(sb, LVL2 "  case %*pM_%s:\n", LSTR_FMT_ARG(prefix), ef->name);

        iopc_dump_case_allow(sb, ef->name, attr, f);
    }
    sb_adds(sb, LVL2 "}\n");
    return 0;
}

static int
iopc_dump_allow(sb_t *sb, const iopc_attr_t *attr, const iopc_field_t *f)
{
    switch (f->kind) {
      case IOP_T_UNION:
        return iopc_dump_allow_union(sb, attr, f);
      case IOP_T_ENUM:
        return iopc_dump_allow_enum(sb, attr, f);
      default:
        e_panic("attribute type not handled for this kind");
    }
}

static int64_t merge_int64(const iopc_attr_t *attr)
{
    int64_t ret;

    switch (attr->desc->id) {
      case IOPC_ATTR_MIN_OCCURS:
      case IOPC_ATTR_MIN_LENGTH:
      case IOPC_ATTR_MIN:
        ret = INT64_MIN;
        tab_for_each_ptr(arg, &attr->args) {
            ret = MAX(ret, IOPC_ATTR_GET_ARG_V(int64_t, arg));
        }
        break;

      case IOPC_ATTR_MAX_OCCURS:
      case IOPC_ATTR_MAX_LENGTH:
      case IOPC_ATTR_MAX:
        ret = INT64_MAX;
        tab_for_each_ptr(arg, &attr->args) {
            ret = MIN(ret, IOPC_ATTR_GET_ARG_V(int64_t, arg));
        }
        break;

     case IOPC_ATTR_LENGTH:
        assert (attr->args.len == 1);
        ret = attr->args.tab[0].v.i64;
        break;

      default:
        e_panic("attribute type not handled in `int64`");
    }
    return ret;
}

static uint64_t merge_uint64(const iopc_attr_t *attr)
{
    uint64_t ret;

    switch (attr->desc->id) {
      case IOPC_ATTR_MIN:
        ret = 0;
        tab_for_each_ptr(arg, &attr->args) {
            ret = MAX(ret, IOPC_ATTR_GET_ARG_V(uint64_t, arg));
        }
        break;

      case IOPC_ATTR_MAX:
        ret = UINT64_MAX;
        tab_for_each_ptr(arg, &attr->args) {
            ret = MIN(ret, IOPC_ATTR_GET_ARG_V(uint64_t, arg));
        }
        break;

      default:
        e_panic("attribute type not handled in `uint64`");
    }
    return ret;
}

static double merge_double(const iopc_attr_t *attr)
{
    double ret;

    switch (attr->desc->id) {
      case IOPC_ATTR_MIN:
        ret = -FLT_MAX;
        tab_for_each_ptr(arg, &attr->args) {
            ret = MAX(ret, IOPC_ATTR_GET_ARG_V(double, arg));
        }
        break;

      case IOPC_ATTR_MAX:
        ret = FLT_MAX;
        tab_for_each_ptr(arg, &attr->args) {
            ret = MIN(ret, IOPC_ATTR_GET_ARG_V(double, arg));
        }
        break;

      default:
        e_panic("attribute type not handled in `double`");
    }
    return ret;
}

static int iopc_dump_minmax(sb_t *sb, int cmp, const iopc_attr_t *attr,
                            const iopc_field_t *f)
{
    bool is_signed;

#define GEN_TEST(fmt1, fmt2, type) \
    do {                                                                     \
        sb_addf(sb,                                                          \
                LVL2 "if (val %c " fmt1 ") {\n"                              \
                LVL3 "if (n > 1) {\n"                                        \
                                                                             \
                LVL4 "iop_set_err(\"violation of constraint %%s (" fmt2 ") " \
                     "on field %%s[%%d]: val=" fmt2 "\",\n"                  \
                LVL4 "            \"%*pM\", (" type ")" fmt1 ", \"%s\", j, " \
                     "(" type ")val);\n"                                     \
                                                                             \
                LVL3 "} else {\n"                                            \
                                                                             \
                LVL4 "iop_set_err(\"violation of constraint %%s (" fmt2 ") " \
                     "on field %%s: val=" fmt2 "\",\n"                       \
                LVL4 "            \"%*pM\", (" type ")" fmt1 ", \"%s\", "    \
                     "(" type ")val);\n"                                     \
                                                                             \
                LVL3 "}\n"                                                   \
                                                                             \
                LVL3 "return -1;\n"                                          \
                LVL2 "}\n",                                                  \
                cmp, v, LSTR_FMT_ARG(attr->desc->name), v, f->name,          \
                LSTR_FMT_ARG(attr->desc->name), v, f->name);                 \
    } while (0)

    RETHROW(iopc_field_get_signed(f, &is_signed));
    if (f->kind == IOP_T_DOUBLE) {
        double v = merge_double(attr);

        GEN_TEST("%.17e", "%%.17e", "double");
    } else
    if (is_signed) {
        int64_t v = merge_int64(attr);

        GEN_TEST("%jdLL", "%%jd", "int64_t");
    } else {
        uint64_t v = merge_uint64(attr);

        GEN_TEST("%juULL", "%%ju", "uint64_t");
    }
#undef GEN_TEST
    return 0;
}

static void
iopc_dump_non_zero(sb_t *sb, const iopc_attr_t *attr, const iopc_field_t *f)
{
    sb_addf(sb,
            LVL2 "if (val == 0) {\n"
            LVL3 "if (n > 1) {\n"

            LVL4 "iop_set_err(\"violation of constraint %%s on field %%s[%%d]\",\n"
            LVL4 "            \"%*pM\", \"%s\", j);\n"

            LVL3 "} else {\n"

            LVL4 "iop_set_err(\"violation of constraint %%s on field %%s\",\n"
            LVL4 "            \"%*pM\", \"%s\");\n"

            LVL3 "}\n"

            LVL3 "return -1;\n"
            LVL2 "}\n",
            LSTR_FMT_ARG(attr->desc->name), f->name,
            LSTR_FMT_ARG(attr->desc->name), f->name);
}

static void
iopc_dump_non_empty(sb_t *sb, const iopc_attr_t *attr, const iopc_field_t *f)
{
    sb_addf(sb,
            LVL2 "if (val.len == 0) {\n"
            LVL3 "if (n > 1) {\n"

            LVL4 "iop_set_err(\"violation of constraint %%s on field %%s[%%d]\",\n"
            LVL4 "            \"%*pM\", \"%s\", j);\n"

            LVL3 "} else {\n"

            LVL4 "iop_set_err(\"violation of constraint %%s on field %%s\",\n"
            LVL4 "            \"%*pM\", \"%s\");\n"

            LVL3 "}\n"

            LVL3 "return -1;\n"
            LVL2 "}\n",
            LSTR_FMT_ARG(attr->desc->name), f->name,
            LSTR_FMT_ARG(attr->desc->name), f->name);
}

static void
iopc_dump_snmp_attrs(sb_t *buf, const iopc_struct_t *st,
                     const iopc_pkg_t *pkg, const char *tbase, int oid,
                     bool xt_is_snmp_root, bool is_rpc, bool is_iface,
                     iop_type_t kind)
{
    sb_addf(buf,
            "%siop_snmp_attrs_t %s__snmp_attrs__s "
            "= {\n", CONST, tbase);
    if (!xt_is_snmp_root && !is_rpc) {
        sb_addf(buf,
                LVL1 ".parent = &%s__%s__s,\n",
                pp_under(pkg->name), pp_to_c(st->name));
    }
    sb_addf(buf, LVL1 ".oid    = %d,\n", oid);

    if (!is_iface) {
        sb_addf(buf, LVL1 ".type   = %s,\n", types[kind]);
    }

    sb_addf(buf, "};\n");
}

static int iopc_dump_field_attr(iopc_attr_t *attr, unsigned type,
                                sb_t *sb, iopc_attrs_t *attrs,
                                const iopc_field_t *f)
{
    bool is_signed;
    SB_1k(pattern);

    SET_BIT(&attrs->flags, type);
    attrs->attrs_len++;

    switch (attr->desc->id) {
      case IOPC_ATTR_MIN_OCCURS:
      case IOPC_ATTR_MAX_OCCURS:
      case IOPC_ATTR_MIN_LENGTH:
      case IOPC_ATTR_MAX_LENGTH:
      case IOPC_ATTR_LENGTH:
        sb_addf(sb,
                LVL1 "{\n"
                LVL1 "    .type = %d,\n"
                LVL1 "    .args = (iop_field_attr_arg_t[]){ { .v.i64 = %jdLL } },\n"
                LVL1 "},\n",
                type, merge_int64(attr));
        break;

      case IOPC_ATTR_PATTERN:
        assert (attr->args.tab[0].type == ITOK_STRING);
        assert (attr->args.len == 1);
        sb_add_slashes(&pattern, attr->args.tab[0].v.s.s,
                       attr->args.tab[0].v.s.len, "\\", "\\");
        sb_addf(sb,
                LVL1 "{\n"
                LVL1 "    .type = %d,\n"
                LVL1 "    .args = (iop_field_attr_arg_t[]){ { .v.s = LSTR_IMMED(\"%*pM\") } },\n"
                LVL1 "},\n",
                type, pattern.len, pattern.data);
        break;

      case IOPC_ATTR_MIN:
      case IOPC_ATTR_MAX:
        RETHROW(iopc_field_get_signed(f, &is_signed));
        if (f->kind == IOP_T_DOUBLE) {
            sb_addf(sb,
                    LVL1 "{\n"
                    LVL1 "    .type = %d,\n"
                    LVL1 "    .args = (iop_field_attr_arg_t[]){ { .v.d = %.17e } },\n"
                    LVL1 "},\n",
                    type, merge_double(attr));
        } else
        if (is_signed) {
            sb_addf(sb,
                    LVL1 "{\n"
                    LVL1 "    .type = %d,\n"
                    LVL1 "    .args = (iop_field_attr_arg_t[]){ { .v.i64 = %jdLL } },\n"
                    LVL1 "},\n",
                    type, merge_int64(attr));
        } else {
            sb_addf(sb,
                    LVL1 "{\n"
                    LVL1 "    .type = %d,\n"
                    LVL1 "    .args = (iop_field_attr_arg_t[]){ { .v.i64 = %juULL } },\n"
                    LVL1 "},\n",
                    type, merge_uint64(attr));
        }
        break;

      case IOPC_ATTR_GENERIC:
        iopc_dump_gen_attr(sb, attr, type);
        break;

      default:
        e_panic("should not happen");
    }

    sb_wipe(&pattern);
    return 0;
}

static void
iopc_dump_snmp_field_attr(sb_t *sb, iopc_attrs_t *attrs,
                          const char *ibase, const char *field_name)
{
    sb_addf(sb,
            LVL1 "{\n"
            LVL2 ".type = %d,\n"
            LVL2 ".args = (iop_field_attr_arg_t[]){ { .v.p = (void*)&%s__%s__snmp_attrs__s } },\n"
            LVL1 "},\n",
            IOP_FIELD_SNMP_INFO, ibase, pp_to_c(field_name));
    attrs->attrs_len++;
}

static int
iopc_dump_field_attrs(sb_t *buf, const iopc_struct_t *st, const char *tbase,
                      const iopc_field_t *f, iopc_attrs_t *attrs)
{
    t_scope;
    SB_1k(attrs_body);
    SB_1k(checkf_body);
    SB_1k(checkf_loopbody);
    const char *cname = t_camelcase_to_c_str(f->name);
    const char *var_pfx = t_fmt("%s__%s", tbase, cname);
    int type;

    iopc_dump_help_and_ref(buf, &attrs_body, &iopc_attr_kind_field_g,
                           var_pfx, &f->comments);
    if (has_help(&f->comments)) {
        attrs->attrs_len++;
        SET_BIT(&attrs->flags, ATTR_HELP(FIELD));
    }

    tab_for_each_entry(attr, &f->attrs) {
        switch (attr->desc->id) {

          case IOPC_ATTR_CDATA:
            SET_BIT(&attrs->flags, IOP_FIELD_CDATA);
            break;

          case IOPC_ATTR_MIN_OCCURS:
            iopc_dump_minmax_occurs(&checkf_body, '<', attr, f);
            RETHROW(iopc_dump_field_attr(attr, IOP_FIELD_MIN_OCCURS,
                                         &attrs_body, attrs, f));
            break;
          case IOPC_ATTR_MAX_OCCURS:
            iopc_dump_minmax_occurs(&checkf_body, '>', attr, f);
            RETHROW(iopc_dump_field_attr(attr, IOP_FIELD_MAX_OCCURS,
                                         &attrs_body, attrs, f));
            break;

          case IOPC_ATTR_MIN_LENGTH:
            iopc_dump_minmax_length(&checkf_loopbody, "<", attr, f);
            RETHROW(iopc_dump_field_attr(attr, IOP_FIELD_MIN_LENGTH,
                                         &attrs_body, attrs, f));
            break;

          case IOPC_ATTR_MAX_LENGTH:
            iopc_dump_minmax_length(&checkf_loopbody, ">", attr, f);
            RETHROW(iopc_dump_field_attr(attr, IOP_FIELD_MAX_LENGTH,
                                         &attrs_body, attrs, f));
            break;

          case IOPC_ATTR_LENGTH:
            iopc_dump_minmax_length(&checkf_loopbody, "!=", attr, f);
            RETHROW(iopc_dump_field_attr(attr, IOP_FIELD_MIN_LENGTH,
                                         &attrs_body, attrs, f));
            RETHROW(iopc_dump_field_attr(attr, IOP_FIELD_MAX_LENGTH,
                                         &attrs_body, attrs, f));
            break;

          case IOPC_ATTR_PATTERN:
            if (iopc_dump_pattern(&checkf_loopbody, attr, f) < 0) {
                throw_error("unsupported pattern: %*pM",
                            LSTR_FMT_ARG(attr->args.tab[0].v.s));
            }
            RETHROW(iopc_dump_field_attr(attr, IOP_FIELD_PATTERN, &attrs_body,
                                 attrs, f));
            break;

          case IOPC_ATTR_MIN:
            RETHROW(iopc_dump_minmax(&checkf_loopbody, '<', attr, f));
            RETHROW(iopc_dump_field_attr(attr, IOP_FIELD_MIN, &attrs_body,
                                         attrs, f));
            break;
          case IOPC_ATTR_MAX:
            RETHROW(iopc_dump_minmax(&checkf_loopbody, '>', attr, f));
            RETHROW(iopc_dump_field_attr(attr, IOP_FIELD_MAX, &attrs_body,
                                         attrs, f));
            break;
          case IOPC_ATTR_NON_EMPTY:
            iopc_dump_non_empty(&checkf_loopbody, attr, f);
            SET_BIT(&attrs->flags, IOP_FIELD_NON_EMPTY);
            break;
          case IOPC_ATTR_NON_ZERO:
            iopc_dump_non_zero(&checkf_loopbody, attr, f);
            SET_BIT(&attrs->flags, IOP_FIELD_NON_ZERO);
            break;
          case IOPC_ATTR_ALLOW:
          case IOPC_ATTR_DISALLOW:
            iopc_dump_allow(&checkf_loopbody, attr, f);
            break;

          case IOPC_ATTR_PRIVATE:
            SET_BIT(&attrs->flags, IOP_FIELD_PRIVATE);
            break;

          case IOPC_ATTR_GENERIC:
            type = iopc_attr_kind_get_gen_type(&iopc_attr_kind_field_g,
                                               attr->args.tab[0].type);
            RETHROW(iopc_dump_field_attr(attr, type, &attrs_body, attrs, f));
            break;

          case IOPC_ATTR_DEPRECATED:
            SET_BIT(&attrs->flags, IOP_FIELD_DEPRECATED);
            break;

          default:
            break;
        }
    }

    if (st->contains_snmp_info || iopc_is_snmp_st(st->type)) {
        iopc_dump_snmp_field_attr(&attrs_body, attrs, tbase, cname);
        SET_BIT(&attrs->flags, IOP_FIELD_SNMP_INFO);
    }

    if (checkf_body.len || checkf_loopbody.len) {
        attrs->checkf_name = lstr_fmt("%s__%s__check", tbase, cname);

        sb_addf(buf,
                "static int %*pM(const void *ptr, int n)\n"
                "{\n",
                LSTR_FMT_ARG(attrs->checkf_name));
        sb_addsb(buf, &checkf_body);
        if (checkf_loopbody.len) {
            RETHROW(iopc_dump_fieldval_loop(buf, f));
            sb_addsb(buf, &checkf_loopbody);
            sb_adds(buf, "    }\n");
        }
        sb_adds(buf,
                "    return 0;\n"
                "}\n");
    }
    if (attrs_body.len) {
        attrs->attrs_name = lstr_fmt("%s__%s__attrs", tbase, cname);

        sb_addf(buf,
                "static iop_field_attr_t const %*pM[] = {\n",
                LSTR_FMT_ARG(attrs->attrs_name));
        sb_addsb(buf, &attrs_body);
        sb_adds(buf,
                "};\n");
    }

    return 0;
}

/** XXX: sb_na    buffer where to write attributes other than IOPC_ATTR_ALIAS
 *       sb_alias buffer where to write attribute IOPC_ATTR_ALIAS
 */
static void
iopc_dump_rpc_attr(iopc_attr_t *attr, sb_t *sb_na, sb_t *sb_alias,
                   iopc_attrs_t *attrs, const char *ibase,
                   unsigned *n_func_and_alias)
{
    unsigned type = 0;

    switch (attr->desc->id) {
      case IOPC_ATTR_ALIAS:
        type = IOP_RPC_ALIAS;
        tab_for_each_entry(arg, &attr->args) {
            sb_addf(sb_alias,
                    LVL1 "{\n"
                    LVL1 "    .type = %d,\n"
                    LVL1 "    .args = (iop_rpc_attr_arg_t[]){ { .v.p = (void*)&%s__if_funs[%u] } },\n"
                    LVL1 "},\n",
                    type, ibase, *n_func_and_alias);
            (*n_func_and_alias)++;
            attrs->attrs_len++;
        }
        break;
      case IOPC_ATTR_GENERIC:
        type = iopc_attr_kind_get_gen_type(&iopc_attr_kind_rpc_g,
                                           attr->args.tab[0].type);
        iopc_dump_gen_attr(sb_na, attr, type);
        attrs->attrs_len++;
        break;
      default:
        e_panic("should not happen");
    }
    SET_BIT(&attrs->flags, type);
}

static void
iopc_dump_fun_struct_attrs(sb_t *buf, const iopc_attr_kind_t *attr_kind,
                           const char *tbase, const char *cname,
                           const iopc_fun_struct_t *fun_st,
                           iopc_attrs_t *attrs, sb_t *attrs_body)
{
    t_scope;
    const char *var_pfx;

    if (fun_st->is_anonymous || !fun_st->existing_struct) {
        return;
    }

    var_pfx = t_fmt("%s__%s", tbase, cname);
    iopc_dump_help_and_ref(buf, attrs_body, attr_kind, var_pfx,
                           &fun_st->existing_struct->comments);
    if (has_help(&fun_st->existing_struct->comments)) {
        SET_BIT(&attrs->flags, attr_kind->help_type);
        attrs->attrs_len++;
    }
}

static void
iopc_dump_rpc_attrs(sb_t *buf, const char *tbase, const iopc_fun_t *f,
                    iopc_attrs_t *attrs, unsigned *n_func_and_alias)
{
    t_scope;
    SB_1k(attrs_body);
    SB_1k(attrs_body_alias);
    const char *cname = t_camelcase_to_c_str(f->name);
    const char *var_pfx = t_fmt("%s__%s", tbase, cname);

    iopc_dump_help_and_ref(buf, &attrs_body, &iopc_attr_kind_rpc_g, var_pfx,
                           &f->comments);
    if (has_help(&f->comments)) {
        SET_BIT(&attrs->flags, ATTR_HELP(RPC));
        attrs->attrs_len++;
    }

    iopc_dump_fun_struct_attrs(buf, &iopc_attr_kind_rpc_arg_g, tbase, cname,
                               &f->arg, attrs, &attrs_body);
    iopc_dump_fun_struct_attrs(buf, &iopc_attr_kind_rpc_res_g, tbase, cname,
                               &f->res, attrs, &attrs_body);
    iopc_dump_fun_struct_attrs(buf, &iopc_attr_kind_rpc_exn_g, tbase, cname,
                               &f->exn, attrs, &attrs_body);

    tab_for_each_entry(attr, &f->attrs) {
        iopc_dump_rpc_attr(attr, &attrs_body, &attrs_body_alias, attrs, tbase,
                           n_func_and_alias);
    }
    if (!attrs->attrs_len)
        return;

    attrs->attrs_name = lstr_fmt("%s__%s__attrs", tbase, cname);

    if (attrs_body.len && attrs_body_alias.len) {
        /** dump attributes other than aliases, used by aliased functions */
        sb_addf(buf, "static iop_rpc_attr_t const %*pM_na[] = {\n",
                LSTR_FMT_ARG(attrs->attrs_name));
        sb_addsb(buf, &attrs_body);
        sb_adds(buf, "};\n");
    }

    sb_addsb(&attrs_body, &attrs_body_alias);
    sb_wipe(&attrs_body_alias);

    /** dump all attributes */
    sb_addf(buf,
            "static iop_rpc_attr_t const %*pM[] = {\n",
            LSTR_FMT_ARG(attrs->attrs_name));
    sb_addsb(buf, &attrs_body);
    sb_adds(buf,
            "};\n");
    sb_wipe(&attrs_body);
}

static void
iopc_dump_field_attrs_src(sb_t *buf, const iopc_struct_t *st,
                          const char *tbase, const iopc_field_t *f,
                          const iopc_attrs_t *attrs)
{
    sb_addf(buf,
            "    {\n"
            "        .flags             = %u,\n"
            "        .attrs_len         = %u,\n",
            attrs->flags, attrs->attrs_len);

    if (attrs->checkf_name.len) {
        sb_addf(buf, "        .check_constraints = &%*pM,\n",
                LSTR_FMT_ARG(attrs->checkf_name));
    }
    if (attrs->attrs_name.len) {
        sb_addf(buf, "        .attrs             = %*pM,\n",
                LSTR_FMT_ARG(attrs->attrs_name));
    }

    sb_adds(buf,
            "    },\n");
}

static void
iopc_dump_rpc_attrs_src(sb_t *buf, const iopc_attrs_t *attrs)
{
    sb_addf(buf,
            "    {\n"
            "        .flags             = %u,\n",
            attrs->flags);
    if (attrs->attrs_len) {
        sb_addf(buf,
                "        .attrs_len         = %u,\n"
                "        .attrs             = %*pM,\n",
                attrs->attrs_len, LSTR_FMT_ARG(attrs->attrs_name));
    }
    sb_adds(buf,
            "    },\n");
}

/* }}} */
/* {{{ Enum source writing. */

/* FIXME Almost a duplicate from t_iopc_struct_build_ranges. */
/** Build the range used to associate an enum value to the associated element.
 */
static iop_array_i32_t mp_iopc_enum_build_ranges(mem_pool_t *mp,
                                                 const iopc_enum_t *en)
{
    qv_t(i32) t;

    mp_qv_init(mp, &t, 2 * en->values.len + 1);
    for (int i = 0, last_enum = 0; i < en->values.len; i++) {
        iopc_enum_field_t *f = en->values.tab[i];

        if (!i || ++last_enum != f->value) {
            qv_append(&t, i);
            qv_append(&t, f->value);
            last_enum = f->value;
        }
    }
    qv_append(&t, en->values.len);
    mp_realloc_from(mp, &t.tab, t.size, t.len);

    return IOP_TYPED_ARRAY_TAB(i32, &t);
}

static void
iopc_enum_dump_src(sb_t *buf, const iopc_pkg_t *pkg,
                   const char *pkg_name, iopc_enum_t *en)
{
    t_scope;
    SB_1k(values_attrs_body);
    char *tbase = t_fmt("%s__%s", pkg_name, t_camelcase_to_c_str(en->name));
    int range;
    unsigned flags = 0;
    bool has_attrs;
    iop_array_i32_t t;
    bool values_have_attributes = false;
    uint16_t alias_count = 0;

    qv_sort(iopc_enum_field)(&en->values,
                             ^int (iopc_enum_field_t * const *f1,
                                   iopc_enum_field_t * const *f2) {
        return CMP((*f1)->value, (*f2)->value);
    });
    sb_addf(buf,
            "/* Enum %s.%s {""{{ */\n"
            "\n"
            "static int const %s__values[] = {\n",
            pretty_path_dot(pkg->name), en->name, tbase);
    tab_for_each_entry(f, &en->values) {
        sb_addf(buf, " %d,", f->value);
    }
    sb_adds(buf,
            "\n"
            "};\n");

    t = mp_iopc_enum_build_ranges(t_pool(), en);
    range = iopc_put_range(buf, &t);

    sb_addf(buf,
            "static const lstr_t %s__names[] = {\n",
            tbase);
    tab_for_each_entry(value, &en->values) {
        sb_addf(buf, "    LSTR_IMMED(\"%s\"),\n", value->name);
    }
    sb_adds(buf, "};\n");
    tab_for_each_entry(attr, &en->attrs) {
        if (attr->desc->id == IOPC_ATTR_STRICT) {
            SET_BIT(&flags, IOP_ENUM_STRICT);
            break;
        }
    }

    for (int i = 0; i < en->values.len; i++) {
        t_scope;
        iopc_enum_field_t *f = en->values.tab[i];

        tab_for_each_entry(attr, &f->attrs) {
            if (attr->desc->id == IOPC_ATTR_ALIAS) {
                SET_BIT(&flags, IOP_ENUM_ALIASES);
                tab_for_each_entry(alias, &attr->args) {
                    if (!alias_count) {
                        sb_addf(buf, "static const iop_enum_aliases_t "
                                "%s__aliases = {\n", tbase);
                        sb_adds(buf, "    .aliases = {\n");
                    }
                    sb_addf(buf, "        { "
                            ".pos = %d, .name = LSTR_IMMED(\"%*pM\") },\n",
                            i, LSTR_FMT_ARG(alias.v.s));
                    alias_count++;
                }
            }
        }
    }
    if (alias_count > 0) {
        sb_adds(buf, "    },\n");
        sb_addf(buf, "    .len = %d\n", alias_count);
        sb_adds(buf, "};\n");
    }

    tab_for_each_entry(val, &en->values) {
        t_scope;
        lstr_t fname;
        const char *var_pfx;
        int nb_enum_value_attrs;
        unsigned enum_value_attrs_flags;

        fname = t_lstr_ascii_tolower(LSTR(val->name));
        var_pfx = t_fmt("%s__%*pM", tbase, LSTR_FMT_ARG(fname));

        iopc_dump_attr_table(&iopc_attr_kind_enum_value_g, &val->comments,
                             &val->attrs, var_pfx, buf,
                             &enum_value_attrs_flags, &nb_enum_value_attrs);
        if (nb_enum_value_attrs) {
            values_have_attributes = true;
        }
        iopc_dump_attrs_ref(&values_attrs_body, enum_value_attrs_flags,
                            nb_enum_value_attrs, var_pfx, true,
                            iopc_attr_kind_enum_value_g.ext);
    }

    if (values_have_attributes) {
        iopc_dump_attrs_ref_body(&iopc_attr_kind_enum_value_g, tbase,
                                 LSTR_SB_V(&values_attrs_body), true, buf);
    }

    iopc_dump_attrs(&iopc_attr_kind_enum_g, &en->comments, &en->attrs,
                    tbase, buf, &has_attrs);
    if (has_attrs || values_have_attributes) {
        SET_BIT(&flags, IOP_ENUM_EXTENDED);
    }

    sb_addf(buf,
            "iop_enum_t const %s__e = {\n"
            "    .name         = LSTR_IMMED(\"%s\"),\n"
            "    .fullname     = LSTR_IMMED(\"%s.%s\"),\n"
            "    .names        = %s__names,\n"
            "    .values       = %s__values,\n"
            "    .ranges       = iop__ranges__%d,\n"
            "    .ranges_len   = countof(iop__ranges__%d) / 2,\n"
            "    .enum_len     = %d,\n",
            tbase, en->name, pretty_path_dot(pkg->name), en->name,
            tbase, tbase, range, range, en->values.len);
    if (flags) {
        sb_addf(buf, "    .flags        = %u,\n", flags);
    }
    if (has_attrs) {
        sb_addf(buf, "    .en_attrs     = &%s__e_desc_attrs,\n", tbase);
    }
    if (values_have_attributes) {
        sb_addf(buf, "    .values_attrs = %s__e_desc_values_attrs,\n", tbase);
    }
    if (alias_count > 0) {
        sb_addf(buf, "    .aliases      = &%s__aliases,\n", tbase);
    }
    sb_addf(buf,
            "};\n"
            "iop_enum_t const * const %s__ep = &%s__e;\n"
            "\n"
            "/* }""}} */\n", tbase, tbase);
}

/* }}} */
/* {{{ Constraint checks. */

static bool iopc_has_constraints(const qv_t(iopc_attr) *attrs)
{
    tab_for_each_entry(attr, attrs) {
        if ((attr->desc->flags & IOPC_ATTR_F_CONSTRAINT)) {
            return true;
        }
    }
    return false;
}

static bool iopc_is_private(const qv_t(iopc_attr) *attrs)
{
    tab_for_each_entry(attr, attrs) {
        if (attr->desc->id == IOPC_ATTR_PRIVATE) {
            return true;
        }
    }
    return false;
}

static void iopc_struct_check_constraints(iopc_struct_t *st)
{
    if (st->checked_constraints)
        return;
    st->checked_constraints = true;

    if (iopc_has_constraints(&st->attrs))
        st->has_constraints = true;

    tab_for_each_entry(f, &st->fields) {
        if (iopc_has_constraints(&f->attrs))
            st->has_constraints = true;

        switch (f->kind) {
          case IOP_T_STRUCT:
          case IOP_T_UNION:
            iopc_struct_check_constraints(f->struct_def);
            if (f->struct_def->has_constraints) {
                st->has_constraints = true;
            }
            break;

          case IOP_T_ENUM:
            if (iopc_has_constraints(&f->enum_def->attrs)) {
                st->has_constraints = true;
            }
            break;

          default:
            break;
        }
    }
}

/* }}} */
/* {{{ Struct source writing. */

static const char *get_struct_type_desc(iopc_struct_type_t type)
{
    switch (type) {
      default:
      case STRUCT_TYPE_STRUCT: return "Structure";
      case STRUCT_TYPE_CLASS:  return "Class";
      case STRUCT_TYPE_UNION:  return "Union";
    }
}

static int iopc_put_struct_fields(sb_t *buf, const iopc_struct_t *st,
                                  const char *tbase, bool has_attrs,
                                  const char *as_base)
{
    if (iopc_is_class(st->type) || iopc_is_snmp_st(st->type)
    ||  st->contains_snmp_info)
    {
        t_scope;
        lstr_t st_attrs = t_lstr_fmt("&%s__s_desc_attrs", tbase);
        lstr_t fields_attrs = t_lstr_fmt("%s__desc_fields_attrs", as_base);

        sb_addf(buf,
                "    .flags      = %d,\n"
                "    .is_union   = %s,\n"
                "    .st_attrs   = %s,\n"
                "    .fields_attrs = %s,\n",
                st->flags, st->type == STRUCT_TYPE_UNION ? "true": "false",
                has_attrs ? st_attrs.s : "NULL",
                st->has_fields_attrs ? fields_attrs.s : "NULL");

        sb_adds(buf, LVL1 "{\n");
        if (iopc_is_class(st->type)) {
            sb_addf(buf, LVL2 ".class_attrs  = &%s__class_s,\n", tbase);
        } else {
            sb_addf(buf, LVL2".snmp_attrs  = &%s__snmp_attrs__s,\n", tbase);
        }
        sb_adds(buf, LVL1 "}\n");
        return 0;
    }

    if (iopc_is_snmp_st(st->type)) {
        throw_loc("snmp can only be used with iopc v4", st->loc);
    }
    if (st->flags) {
        sb_addf(buf, LVL1 ".flags      = %d,\n", st->flags);
    }
    if (st->type == STRUCT_TYPE_UNION) {
        sb_adds(buf, LVL1 ".is_union   = true,\n");
    }
    if (has_attrs) {
        sb_addf(buf, LVL1 ".st_attrs   = &%s__s_desc_attrs,\n", tbase);
    }
    if (st->has_fields_attrs) {
        sb_addf(buf, LVL1 ".fields_attrs = %s__desc_fields_attrs,\n",
                as_base);
    }
    if (st->type == STRUCT_TYPE_CLASS) {
        sb_addf(buf, LVL1 ".class_attrs  = &%s__class_s,\n", tbase);
    }
    return 0;
}

#undef LVL1
#undef LVL2
#undef LVL3
#undef LVL4

/** Build the range used to associate an IOP tag to a struct field. */
static iop_array_i32_t mp_iopc_struct_build_ranges(mem_pool_t *mp,
                                                   const iopc_struct_t *st)
{
    qv_t(i32) t;
    int last_tag = INT_MIN;

    assert(st->fields_by_tag.len == st->fields.len);
    mp_qv_init(mp, &t, 2 * st->fields_by_tag.len + 1);
    tab_enumerate(i, f, &st->fields_by_tag) {
        if (++last_tag != f->tag) {
            qv_append(&t, i);
            qv_append(&t, f->tag);
            last_tag = f->tag;
        }
    }
    qv_append(&t, st->fields_by_tag.len);
    mp_realloc_from(mp, &t.tab, t.size, t.len);

    return IOP_TYPED_ARRAY_TAB(i32, &t);
}

static void
write_class_attrs(sb_t *buf, const iopc_struct_t *st, const char *tbase,
                  const char *as_base)
{
    assert (iopc_is_class(st->type));
    sb_addf(buf,
            "static %siop_class_attrs_t %s__class_s = {\n",
            CONST, tbase);
    if (st->extends.len) {
        sb_addf(buf, "    .parent            = &%s__%s__s,\n",
                pp_under(st->extends.tab[0]->pkg->name),
                pp_to_c(st->extends.tab[0]->st->name));
    }
    if (st->nb_real_static_fields) {
        sb_addf(buf,
                "    .static_fields     = %s__static_fields,\n"
                "    .static_fields_len = %d,\n",
                as_base, st->nb_real_static_fields);
    }
    if (st->is_abstract) {
        sb_adds(buf, "    .is_abstract       = true,\n");
    }
    if (iopc_is_private(&st->attrs)) {
        sb_adds(buf, "    .is_private        = true,\n");
    }
    sb_addf(buf,
            "    .class_id          = %d,\n", st->class_id);
    sb_adds(buf, "};\n");
}

__must_check__ static int
write_struct(sb_t *buf, const iopc_struct_t *st, const iopc_pkg_t *pkg,
             const char *tbase, const char *real_tbase,
             const char *sname, const char *as_base,
             int rpc_oid, int range, bool has_attrs)
{
    if (iopc_is_class(st->type)) {
        write_class_attrs(buf, st, tbase, as_base);
    } else
    if (iopc_is_snmp_st(st->type)) {
        iopc_extends_t *xt = st->extends.tab[0];

        iopc_dump_snmp_attrs(buf, xt->st, xt->pkg, tbase, st->oid,
                             xt->is_snmp_root, false, false,
                             IOP_T_STRUCT);
    }
    if (st->contains_snmp_info) {
        iopc_dump_snmp_attrs(buf, st, pkg, tbase, rpc_oid, false,
                             true, false, IOP_T_STRUCT);
    }
    sb_addf(buf,
            "const iop_struct_t %s__s = {\n"
            "    .fullname   = LSTR_IMMED(\"%s.%s\"),\n"
            "    .fields     = %s__desc_fields,\n"
            "    .ranges     = iop__ranges__%d,\n"
            "    .ranges_len = countof(iop__ranges__%d) / 2,\n"
            "    .fields_len = countof(%s__desc_fields),\n",
            tbase, pretty_path_dot(pkg->name),
            sname, as_base, range, range, as_base);

    if (!iopc_is_snmp_obj(st->type)) {
        sb_addf(buf, "    .size       = sizeof(%s__t),\n", real_tbase);
    }
    RETHROW(iopc_put_struct_fields(buf, st, real_tbase, has_attrs, as_base));
    sb_adds(buf, "};\n");
    sb_addf(buf, "iop_struct_t const * const %s__sp = &%s__s;\n",
            tbase, tbase);

    return 0;
}

static int
iopc_struct_dump_src(sb_t *buf, const iopc_pkg_t *pkg,
                     const char *pkg_name,
                     iopc_struct_t *st, const qv_t(lstr) *paliases,
                     const char *iface_name, int rpc_oid)
{
    t_scope;
    const char *comment = get_struct_type_desc(st->type);
    const char *tname = pp_to_c(st->name);
    const char *iname = st->iface ? st->iface->name : NULL;
    char *tbase = iname ? t_fmt("%s__%s__%s", pkg_name, pp_to_c(iname), tname)
                        : t_fmt("%s__%s", pkg_name, tname);
    char *sname = iname ? t_fmt("%s.%s", iname, st->name)
                        : t_fmt("%s", st->name);
    char *as_base;
    int range;
    iop_array_i32_t t;
    bool has_attrs;

    sb_addf(buf, "/* %s %s.%s {""{{ */\n\n",
            comment, pretty_path_dot(pkg->name), sname);

    if (st->same_as) {
        iopc_struct_t *as = st->same_as;

        if (as->iface) {
            sb_addf(buf, "/* same as %s.%s.%s */\n\n",
                    pretty_path_dot(pkg->name), as->iface->name, as->name);
            as_base = t_fmt("%s__%s__%s", pkg_name, pp_to_c(as->iface->name),
                            pp_to_c(as->name));
        } else {
            sb_addf(buf, "/* same as %s.%s */\n\n",
                    pretty_path_dot(pkg->name), as->name);
            as_base = t_fmt("%s__%s", pkg_name, pp_to_c(as->name));
        }
        /* all the attributes and constraints work has already been done with
         * the as struct, so re-use it */
        st->flags               = as->flags;
        st->has_fields_attrs    = as->has_fields_attrs;
        st->has_constraints     = as->has_constraints;
    } else {
        qv_t(iopc_attrs) fields_attrs;

        as_base = tbase;

        qv_init(&fields_attrs);

        /* generate <tbase>__<field>__snmp_attrs__s for fields of snmpIface
         * rpcs */
        if (st->contains_snmp_info) {
            char *fbase;
            iopc_extends_t *xt;

            assert(st->fields_by_tag.len == st->fields.len);
            tab_for_each_entry(field, &st->fields_by_tag) {
                fbase = t_fmt("%s__%s", tbase, pp_to_c(field->name));
                xt = field->parents.tab[0];

                iopc_dump_snmp_attrs(buf, xt->st, xt->pkg, fbase,
                                     field->field_origin->tag,
                                     xt->is_snmp_root,
                                     false, false, field->field_origin->kind);
            }
        } else
        if (iopc_is_snmp_st(st->type)) {
            char *fbase;

            assert(st->fields_by_tag.len == st->fields.len);
            tab_for_each_entry(field, &st->fields_by_tag) {
                fbase = t_fmt("%s__%s", tbase, pp_to_c(field->name));

                iopc_dump_snmp_attrs(buf, st, pkg, fbase, field->tag,
                                     false, false, false, field->kind);
            }
        }

        /* check attributes and generate everything that is needed for
         * <tbase>__desc_fields_attrs (attributes, constraints func and help)
         */
        assert(st->fields_by_tag.len == st->fields.len);
        tab_for_each_entry(field, &st->fields_by_tag) {
            iopc_attrs_t attrs;

            iopc_attrs_init(&attrs);

            RETHROW(iopc_dump_field_attrs(buf, st, tbase, field, &attrs));
            if (attrs.checkf_name.len || attrs.flags) {
                st->has_fields_attrs = true;
            }
            qv_append(&fields_attrs, attrs);
        }

        /* generate <tbase>__desc_fields_attrs */
        if (st->has_fields_attrs) {
            SET_BIT(&st->flags, IOP_STRUCT_EXTENDED);
            sb_addf(buf,
                    "static iop_field_attrs_t const %s__desc_fields_attrs[] = {\n",
                    tbase);
            assert(st->fields_by_tag.len == st->fields.len);
            tab_enumerate(i, f, &st->fields_by_tag) {
                iopc_dump_field_attrs_src(buf, st, tbase, f,
                                          &fields_attrs.tab[i]);
            }
            sb_adds(buf, "};\n");
        }

        /* generate <tbase>__desc_fields */
        sb_addf(buf, "static iop_field_t %s%s__desc_fields[] = {\n", CONST,
                tbase);
        assert(st->fields_by_tag.len == st->fields.len);
        tab_enumerate(i, f, &st->fields_by_tag) {
            iopc_dump_field_src(buf, st, tbase, f, &fields_attrs.tab[i]);
        }
        sb_adds(buf,
                "};\n");

        qv_deep_wipe(&fields_attrs, iopc_attrs_wipe);

        iopc_struct_check_constraints(st);
        if (st->has_constraints) {
            SET_BIT(&st->flags, IOP_STRUCT_HAS_CONSTRAINTS);
        }

        /* generate static fields */
        if (st->nb_real_static_fields) {
            iopc_struct_dump_static_fields_src(buf, st, tbase);
        }

        if (iopc_is_class(st->type)) {
            SET_BIT(&st->flags, IOP_STRUCT_EXTENDED);
            SET_BIT(&st->flags, IOP_STRUCT_IS_CLASS);
            SET_BIT(&st->flags, IOP_STRUCT_STATIC_HAS_TYPE);
        } else
        if (iopc_is_snmp_obj(st->type)) {
            SET_BIT(&st->flags, IOP_STRUCT_EXTENDED);
            SET_BIT(&st->flags, IOP_STRUCT_IS_SNMP_OBJ);

            /* check @snmpParam attribute */
            tab_for_each_entry(attr, &st->attrs) {
                if (attr->desc->id == IOPC_ATTR_SNMP_PARAM) {
                    SET_BIT(&st->flags, IOP_STRUCT_IS_SNMP_PARAM);
                    break;
                }
            }
        } else
        if (iopc_is_snmp_tbl(st->type)) {
            SET_BIT(&st->flags, IOP_STRUCT_EXTENDED);
            SET_BIT(&st->flags, IOP_STRUCT_IS_SNMP_TBL);
        }
    }

    t = mp_iopc_struct_build_ranges(t_pool(), st);
    range = iopc_put_range(buf, &t);

    iopc_dump_attrs(&iopc_attr_kind_struct_g, &st->comments, &st->attrs,
                    tbase, buf, &has_attrs);
    if (has_attrs) {
        SET_BIT(&st->flags, IOP_STRUCT_EXTENDED);
    }

    RETHROW(write_struct(buf, st, pkg, tbase, tbase, sname, as_base, rpc_oid,
                         range, has_attrs));

    if (paliases) {
        tab_for_each_entry(alias, paliases) {
            const char *alias_tname;
            const char *alias_tbase;
            const char *alias_sname;

            alias_tname = pp_to_c(alias.s);
            alias_tbase = iname ? t_fmt("%s__%s__%s", pkg_name,
                                        pp_to_c(iname), alias_tname)
                                : t_fmt("%s__%s", pkg_name, alias_tname);
            alias_sname = iname ? t_fmt("%s.%s", iname, alias.s) : alias.s;
            RETHROW(write_struct(buf, st, pkg, alias_tbase, tbase,
                                 alias_sname, as_base, rpc_oid, range,
                                 has_attrs));
        }
    }

    sb_adds(buf, "\n/* }""}} */\n");

    return 0;
}

/* }}} */
/* {{{ RPC source writing. */

static void
iopc_dump_rpc_defines(sb_t *buf, const char *ibase, const iopc_field_t *field,
                      const char *alias_name)
{
    t_scope;
    const char *name = alias_name ? alias_name : field->name;
    const char *tbase_arg = t_fmt("%s__%s", ibase, pp_to_c(name));
    const char *tbase_ref = t_fmt("%s__%s",
                                  pp_under(field->type_path),
                                  pp_to_c(field->type_name));

    if (alias_name == NULL) {
        /* These defines are not needed for RPC aliases (c.f. WRITE_STRUCT) */
        sb_addf(buf, "#define %s__desc_fields  %s__desc_fields\n",
                tbase_arg, tbase_ref);
        sb_addf(buf, "#define %s__s_ranges     %s__s_ranges\n",
                tbase_arg, tbase_ref);
    }
    sb_addf(buf, "#define %s__s            %s__s\n", tbase_arg,
            tbase_ref);
}

static bool iopc_fun_has_alias(const iopc_fun_t *fun)
{
    tab_for_each_entry(attr, &fun->attrs) {
        if (attr->desc->id == IOPC_ATTR_ALIAS) {
            return true;
        }
    }
    return false;
}

static inline void
t_iopc_get_aliases(const iopc_fun_t *fun, const char *suffix,
                   qv_t(lstr) *aliases)
{
    /* build a vector of aliases of this RPC */
    qv_deep_clear(aliases, lstr_wipe);
    tab_for_each_entry(attr, &fun->attrs) {
        if (attr->desc->id == IOPC_ATTR_ALIAS) {
            tab_for_each_entry(arg, &attr->args) {
                lstr_t alias = t_lstr_fmt("%*pM%s", LSTR_FMT_ARG(arg.v.s),
                                          suffix);

                qv_append(aliases, alias);
            }
        }
    }
}

static void
iopc_register_fun_struct(sb_t *buf, const char *ibase,
                         const iopc_fun_struct_t *fun_st,
                         const char *falias_name, const char *falias_sfx,
                         const char *fun_st_name)
{
    t_scope;

    if (falias_name) {
        falias_name = t_fmt("%s_%s", falias_name, falias_sfx);
    }

    if (iopc_fun_struct_is_void(fun_st)) {
        sb_addf(buf,
                "        .%s    = &iop__void__s,\n", fun_st_name);
    } else {
        if (fun_st->is_anonymous) {
            sb_addf(buf,
                    "        .%s    = &%s__%s__s,\n",
                    fun_st_name, ibase,
                    pp_to_c(falias_name ?: fun_st->anonymous_struct->name));
        } else {
            sb_addf(buf,
                    "        .%s    = &%s__%s__s,\n",
                    fun_st_name, ibase,
                    pp_to_c(falias_name ?: fun_st->existing_struct->name));
        }
    }
}

static void
iopc_register_fun(sb_t *buf, const char *ibase, const iopc_fun_t *f,
                  const char *falias_name)
{
    sb_addf(buf,
        "    {\n"
        "        .name      = LSTR_IMMED(\"%s\"),\n"
        "        .tag       = %d,\n",
        falias_name ?: f->name, f->tag);

    iopc_register_fun_struct(buf, ibase, &f->arg, falias_name, "args",
                             "args  ");
    iopc_register_fun_struct(buf, ibase, &f->res, falias_name, "res",
                             "result");
    iopc_register_fun_struct(buf, ibase, &f->exn, falias_name, "exn",
                             "exn   ");

    if (f->fun_is_async) {
        sb_addf(buf,
                "        .async     = true,\n");
    }

    /* handle flags */
    {
        unsigned flags = 0;

        if (falias_name) {
            SET_BIT(&flags, IOP_RPC_IS_ALIAS);
        } else
        if (iopc_fun_has_alias(f)) {
            SET_BIT(&flags, IOP_RPC_HAS_ALIAS);
        }
        if (flags) {
            sb_addf(buf, "        .flags     = %u,\n", flags);
        }
    }
    sb_adds(buf, "    },\n");
}

static inline void
iopc_iface_dump_rpc_attrs(sb_t *buf, const char *ibase, iopc_iface_t *iface)
{
    unsigned n_func_and_alias = 0;
    qv_t(iopc_attrs) rpc_attrs;
    bool dump_attrs = false;

    qv_init(&rpc_attrs);
    tab_for_each_entry(f, &iface->funs) {
        iopc_attrs_t attrs;

        n_func_and_alias++;
        iopc_attrs_init(&attrs);
        iopc_dump_rpc_attrs(buf, ibase, f, &attrs, &n_func_and_alias);
        if (attrs.attrs_len)
            dump_attrs = true;
        qv_append(&rpc_attrs, attrs);
    }

    if (dump_attrs) {
        const iopc_attr_kind_t *attr_kind = &iopc_attr_kind_rpc_g;

        SET_BIT(&iface->flags, IOP_IFACE_EXTENDED);
        sb_addf(buf,
                "static %s const %s__%s[] = {\n",
                attr_kind->attrs_typename, ibase, attr_kind->attrs_var_sfx);
        tab_enumerate(pos, f, &iface->funs) {
            t_scope;
            iopc_attrs_t attrs = rpc_attrs.tab[pos];
            int aliases_count = 0;

            iopc_dump_rpc_attrs_src(buf, &attrs);

            /* dump attributes for aliases
             * these attributes are the same as for *f but IOPC_ATTR_ALIAS */
            tab_for_each_entry(attr, &f->attrs) {
                if (attr->desc->id == IOPC_ATTR_ALIAS) {
                    aliases_count = attr->args.len;
                    break;
                }
            }
            attrs.attrs_len -= aliases_count;
            CLR_BIT(&attrs.flags, IOP_RPC_ALIAS);
            assert (!attrs.attrs_len || attrs.flags);
            attrs.attrs_name = t_lstr_fmt("%*pM_na",
                                          LSTR_FMT_ARG(attrs.attrs_name));
            while (aliases_count--) {
                iopc_dump_rpc_attrs_src(buf, &attrs);
            }
        }
        sb_adds(buf, "};\n");
    }
    qv_deep_wipe(&rpc_attrs, iopc_attrs_wipe);
}

static int
iopc_iface_struct_dump_src(sb_t *buf, const iopc_pkg_t *pkg,
                           const char *pkg_name, const char *ibase,
                           const iopc_fun_t *fun,
                           const iopc_fun_struct_t *fun_st, const char *type)
{
    t_scope;
    qv_t(lstr) aliases;

    if (iopc_fun_struct_is_void(fun_st)) {
        return 0;
    }
    t_qv_init(&aliases, 0);
    t_iopc_get_aliases(fun, type, &aliases);

    if (fun_st->is_anonymous) {
        RETHROW(iopc_struct_dump_src(buf, pkg, pkg_name,
                                     fun_st->anonymous_struct, &aliases, NULL,
                                     0));
    } else {
        /* When the function argument is just a reference to another
         * structure, we just yield several #define. */
        iopc_dump_rpc_defines(buf, ibase, fun_st->existing_struct, NULL);
        tab_for_each_entry(alias, &aliases) {
            iopc_dump_rpc_defines(buf, ibase, fun_st->existing_struct,
                                  alias.s);
        }
    }

    return 0;
}

static int
iopc_iface_dump_src(sb_t *buf, const iopc_pkg_t *pkg,
                    const char *pkg_name, iopc_iface_t *iface)
{
    t_scope;
    const char *iname = pp_to_c(iface->name);
    char *ibase = t_fmt("%s__%s", pkg_name, iname);
    qv_t(lstr) aliases;
    bool has_attrs;

    t_qv_init(&aliases, 16);
    sb_addf(buf, "/* Interface %s.%s {""{{ */\n",
            pretty_path_dot(pkg->name), iface->name);

    if (iface->type == IFACE_TYPE_SNMP_IFACE) {
        SET_BIT(&iface->flags, IOP_IFACE_IS_SNMP_IFACE);

        tab_for_each_entry(fun, &iface->funs) {
            if (!iopc_fun_struct_is_void(&fun->arg)) {
                /* snmpIface can only have "args" and anonymous funs */
                t_iopc_get_aliases(fun, "Args", &aliases);
                if (fun->arg.is_anonymous) {
                    RETHROW(iopc_struct_dump_src(buf, pkg, pkg_name,
                                                 fun->arg.anonymous_struct,
                                                 &aliases,
                                                 pp_to_c(iface->name),
                                                 fun->tag));
                } else {
                    throw_loc("should not happen", fun->loc);
                }
            }
        }
    } else {
        tab_for_each_entry(fun, &iface->funs) {
            iopc_iface_struct_dump_src(buf, pkg, pkg_name, ibase, fun,
                                       &fun->arg, "Args");
            iopc_iface_struct_dump_src(buf, pkg, pkg_name, ibase, fun,
                                       &fun->res, "Res");
            iopc_iface_struct_dump_src(buf, pkg, pkg_name, ibase, fun,
                                       &fun->exn, "Exn");
        }
    }

    sb_addf(buf, "static iop_rpc_t %s%s__if_funs[] = {\n", CONST, ibase);
    tab_for_each_entry(f, &iface->funs) {
        iopc_register_fun(buf, ibase, f, NULL);
        t_iopc_get_aliases(f, "", &aliases);
        tab_for_each_entry(alias, &aliases) {
            iopc_register_fun(buf, ibase, f, alias.s);
        }
    }
    sb_adds(buf, "};\n");

    if (iface->type == IFACE_TYPE_SNMP_IFACE) {
        iopc_extends_t *xt = iface->extends.tab[0];

        iopc_dump_snmp_attrs(buf, xt->st, xt->pkg, ibase, iface->oid, false,
                             false, true, IOP_T_STRUCT);
    }

    iopc_iface_dump_rpc_attrs(buf, ibase, iface);

    iopc_dump_attrs(&iopc_attr_kind_iface_g, &iface->comments, &iface->attrs,
                    ibase, buf, &has_attrs);
    if (has_attrs) {
        SET_BIT(&iface->flags, IOP_IFACE_HAS_ATTRS);
    }

    sb_addf(buf,
            "const iop_iface_t %s__if = {\n"
            "    .fullname   = LSTR_IMMED(\"%s.%s\"),\n"
            "    .funs       = %s__if_funs,\n"
            "    .funs_len   = countof(%s__if_funs),\n",
            ibase, pretty_path_dot(pkg->name),
            iface->name, ibase, ibase);
    if (iface->flags) {
        sb_addf(buf, "    .flags      = %d,\n", iface->flags);
    }
    if (TST_BIT(&iface->flags, IOP_IFACE_EXTENDED)) {
        sb_addf(buf, "    .rpc_attrs  = %s__rpc_desc_attrs,\n", ibase);
    }
    if (TST_BIT(&iface->flags, IOP_IFACE_HAS_ATTRS)) {
        sb_addf(buf, "    .iface_attrs  = &%s__desc_if_attrs,\n", ibase);
    }
    if (TST_BIT(&iface->flags, IOP_IFACE_IS_SNMP_IFACE)) {
        sb_addf(buf, "    .snmp_iface_attrs = &%s__snmp_attrs__s,\n", ibase);
    }
    sb_adds(buf, "};\n");
    sb_addf(buf, "const iop_iface_t * const %s__ifp = &%s__if;\n\n",
            ibase, ibase);
    sb_adds(buf, "/* }""}} */\n");

    return 0;
}

static void
iopc_module_dump_src(sb_t *buf, iopc_pkg_t *pkg,
                     const char *pkg_name, const iopc_struct_t *mod)
{
    t_scope;
    char *mbase = t_fmt("%s__%s", pkg_name, pp_to_c(mod->name));
    uint16_t flags = 0;
    bool ifaces_have_comments = false;
    bool mod_has_attrs;

    sb_addf(buf,
            "/* Module %s.%s {""{{ */\n"
            "\n"
            "static iop_iface_alias_t const %s__aliases[] = {\n",
            pretty_path_dot(pkg->name), mod->name, mbase);
    assert(mod->fields_by_tag.len == mod->fields.len);
    for (int i = 0; i < mod->fields_by_tag.len; i++) {
        iopc_field_t *f = mod->fields_by_tag.tab[i];

        sb_addf(buf,
                "    {\n"
                "        .name  = LSTR_IMMED(\"%s\"),\n"
                "        .iface = &%s__%s__if,\n"
                "        .tag   = %d,\n"
                "    },\n",
                f->name, pp_under(f->type_path), pp_to_c(f->type_name),
                f->tag);
        if (has_help(&f->comments)) {
            ifaces_have_comments = true;
        }
    }
    sb_adds(buf, "};\n");

    if (ifaces_have_comments) {
        SB_1k(help_body);
        const iopc_attr_kind_t *attr_kind = &iopc_attr_kind_mod_iface_g;

        SET_BIT(&flags, IOP_MOD_EXTENDED);
        assert(mod->fields_by_tag.len == mod->fields.len);
        tab_for_each_entry(f, &mod->fields_by_tag) {
            t_scope;
            const char *var_pfx;
            int f_nb_attrs;
            unsigned f_flags;

            var_pfx = t_fmt("%s__%s", mbase, t_camelcase_to_c_str(f->name));
            iopc_dump_attr_table(attr_kind, &f->comments, NULL, var_pfx, buf,
                                 &f_flags, &f_nb_attrs);
            iopc_dump_attrs_ref(&help_body, f_flags, f_nb_attrs,
                                var_pfx, true, attr_kind->ext);
        }
        iopc_dump_attrs_ref_body(attr_kind, mbase, LSTR_SB_V(&help_body),
                                 true, buf);
    }

    iopc_dump_attrs(&iopc_attr_kind_mod_g, &mod->comments, NULL, mbase, buf,
                    &mod_has_attrs);
    if (mod_has_attrs) {
        SET_BIT(&flags, IOP_MOD_EXTENDED);
    }

    sb_addf(buf,
            "iop_mod_t const %s__mod = {\n"
            "    .fullname   = LSTR_IMMED(\"%s.%s\"),\n"
            "    .ifaces     = %s__aliases,\n"
            "    .ifaces_len = countof(%s__aliases),\n",
            mbase, pretty_path_dot(pkg->name), mod->name,
            mbase, mbase);
    if (flags) {
        sb_addf(buf,
            "    .flags      = %u,\n", flags);
    }
    if (has_help(&mod->comments)) {
        sb_addf(buf,
            "    .mod_attrs  = &%s__m_desc_attrs,\n", mbase);
    }
    if (ifaces_have_comments) {
        sb_addf(buf,
            "    .ifaces_attrs = %s__m_desc_if_attrs,\n", mbase);
    }
    sb_addf(buf,
            "};\n"
            "iop_mod_t const * const %s__modp = &%s__mod;\n\n"
            "/* }""}} */\n", mbase, mbase);
}

/* }}} */
/* {{{ Package source writing. */

static void
iopc_pkg_dump_src(sb_t *buf, iopc_pkg_t *pkg,
                  const char *pkg_name,
                  qv_t(iopc_pkg) *t_deps,
                  qv_t(iopc_pkg) *i_deps)
{
    t_scope;
    qv_t(iopc_pkg) deps;

    t_qv_init(&deps, 1024);
    qv_extend_tab(&deps, t_deps);
    qv_extend_tab(&deps, i_deps);
    iopc_depends_uniquify(&deps);

    sb_addf(buf,
            "/* Package %s {""{{ */\n"
            "\n"
            "static const iop_pkg_t *const %s__deps[] = {\n",
            pretty_path_dot(pkg->name), pkg_name);
    for (int i = 0; i < deps.len; i++) {
        sb_addf(buf, "    &%s__pkg,\n", pp_under(deps.tab[i]->name));
    }

    sb_addf(buf,
            "    NULL,\n"
            "};\n"
            "\n"
            "static const iop_enum_t *const %s__enums[] = {\n",
            pkg_name);
    for (int i = 0; i < pkg->enums.len; i++) {
        sb_addf(buf, "    &%s__%s__e,\n", pkg_name, pp_to_c(pkg->enums.tab[i]->name));
    }
    sb_addf(buf,
            "    NULL,\n"
            "};\n"
            "\n"
            "static const iop_struct_t *const %s__structs[] = {\n",
            pkg_name);
    for (int i = 0; i < pkg->structs.len; i++) {
        sb_addf(buf, "    &%s__%s__s,\n", pkg_name, pp_to_c(pkg->structs.tab[i]->name));
    }
    sb_addf(buf,
            "    NULL,\n"
            "};\n"
            "\n"
            "static const iop_iface_t *const %s__ifaces[] = {\n",
            pkg_name);
    for (int i = 0; i < pkg->ifaces.len; i++) {
        sb_addf(buf, "    &%s__%s__if,\n", pkg_name, pp_to_c(pkg->ifaces.tab[i]->name));
    }
    sb_addf(buf,
            "    NULL,\n"
            "};\n"
            "\n"
            "static const iop_mod_t *const %s__mods[] = {\n",
            pkg_name);
    for (int i = 0; i < pkg->modules.len; i++) {
        sb_addf(buf, "    &%s__%s__mod,\n", pkg_name, pp_to_c(pkg->modules.tab[i]->name));
    }
    sb_addf(buf,
            "    NULL,\n"
            "};\n"
            "\n"
            "iop_pkg_t const %s__pkg = {\n"
            "    .name    = LSTR_IMMED(\"%s\"),\n"
            "    .deps    = %s__deps,\n"
            "    .enums   = %s__enums,\n"
            "    .structs = %s__structs,\n"
            "    .ifaces  = %s__ifaces,\n"
            "    .mods    = %s__mods,\n"
            "};\n"
            "iop_pkg_t const * const %s__pkgp = &%s__pkg;\n"
            "\n"
            "/* }""}} */\n",
            pkg_name, pretty_path_dot(pkg->name),
            pkg_name, pkg_name, pkg_name, pkg_name, pkg_name,
            pkg_name, pkg_name);
}

#define RO_WARN \
    "/***** THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY ! *****/\n"

static bool strendswith(const char *s, const char *needle, const char **endp)
{
    size_t nlen = strlen(needle);
    size_t slen = strlen(s);

    if (nlen > slen)
        return false;
    if (endp)
        *endp = s + slen - nlen;
    return strequal(s + slen - nlen, needle);
}

static size_t path_count_atoms(const char *s)
{
    size_t n = 0;

    if (*s == 0) {
        return 0;
    }
    if (*s == '/') {
        s++;
    }
    while ((s = strchr(s, '/'))) {
        n++;
        s++;
    }
    return n + 1;
}

static size_t common_prefix(const char *s, const char *t)
{
    size_t n = 0;

    while (s[n] && s[n] == t[n])
        n++;
    return n;
}

static int put_include(sb_t *sb, const char *ext,
                       iopc_pkg_t *pkg, const iopc_pkg_t *us)
{
    const char *iop_path = pretty_path(pkg->name);

    sb_adds(sb, "#include \"");
    if (_G.resolve_includes) {
        char our_path[PATH_MAX], dep_path[PATH_MAX];
        int pfx, n;
        char *p;

        path_dirname(dep_path, sizeof(dep_path), us->file);
        path_canonify(our_path, sizeof(our_path), dep_path);
        path_canonify(dep_path, sizeof(dep_path), pkg->file);
        if (!strendswith(dep_path, iop_path, (const char **)&p))
            goto no_rel;
        assert (p > dep_path && p[-1] == '/');
        --p;
        dep_path[p - dep_path] = '\0';
        pfx = common_prefix(our_path, dep_path);
        while (pfx > 0 && our_path[pfx - 1] != '/')
            pfx--;
        if (pfx == 1)
            goto no_rel;
        n = path_count_atoms(our_path + pfx);
        for (int j = 0; j < n; j++) {
            sb_adds(sb, "../");
        }
        if (dep_path[pfx] == '/')
            pfx++;
        if (dep_path[pfx])
            sb_addf(sb, "%s/", dep_path + pfx);
    }
    sb_addf(sb, "%*pM%s\"\n", (int)strlen(iop_path) - 4, iop_path, ext);
    return 0;

  no_rel:
    throw_error("[%s] unable to make a relative #include path for %s",
                pretty_path(pkg->name), iop_path);
}

int iopc_do_c(iopc_pkg_t *pkg, const char *outdir)
{
    SB_8k(buf);
    qv_t(iopc_pkg) t_deps, t_weak_deps, i_deps;
    const char *pkg_name;
    char path[PATH_MAX];
    int res = 0;

#define IOPC_DO_C_RETHROW(e)  \
    do {                                                                     \
        if ((res = (e)) < 0) {                                               \
            goto end;                                                        \
        }                                                                    \
    } while (0)

    /*----- prepare stuff -----*/
    qv_init(&pp_g);
    qv_inita(&t_deps, 1024);
    qv_inita(&t_weak_deps, 1024);
    qv_inita(&i_deps, 1024);

    pkg_name = pp_under(pkg->name);
    iopc_pkg_get_deps(pkg, IOPC_PKG_GET_DEPS_INCLUDE_ALL,
                      &t_deps, &t_weak_deps, &i_deps);

    iopc_set_path(outdir, pkg, "-tdef.iop.h", sizeof(path), path,
                  !!iopc_do_c_g.iop_compat_header);

    /*----- dump the typedef header ------*/
    sb_sets(&buf, RO_WARN);
    sb_addf(&buf,
            "#ifndef IOP_HEADER_GUARD_%s_TYPEDEFS_H\n"
            "#define IOP_HEADER_GUARD_%s_TYPEDEFS_H\n"
            "\n", pkg_name, pkg_name);
    if (iopc_do_c_g.iop_compat_header) {
        sb_adds(&buf, iopc_do_c_g.iop_compat_header);
        sb_addc(&buf, '\n');
    } else {
        sb_adds(&buf,
                "#include <lib-common/core.h>\n"
                "#include <lib-common/iop/internals.h>\n"
                "\n");
    }

    tab_for_each_entry(en, &pkg->enums) {
        iopc_enum_dump_tdef_hdr(&buf, pkg_name, en);
    }
    tab_for_each_entry(st, &pkg->structs) {
        iopc_struct_dump_tdef_hdr(&buf, pkg_name, st, NULL);

        if (iopc_is_snmp_st(st->type)) {
            sb_addf(&buf,
                    "/*----- snmp fields of struct %s.%s -----*/\n",
                    pretty_path_dot(pkg->name), st->name);
            tab_for_each_entry(f, &st->fields) {
                iopc_snmp_field_dump_tdef_hdr(&buf, pkg_name, st, f);
            }
        }
    }
    sb_adds(&buf, "#endif\n");

    IOPC_DO_C_RETHROW(iopc_write_file(&buf, path));

    /*----- dump the types header -----*/
    sb_sets(&buf, RO_WARN);
    sb_addf(&buf,
            "#ifndef IOP_HEADER_GUARD_%s_TYPES_H\n"
            "#define IOP_HEADER_GUARD_%s_TYPES_H\n"
            "\n"
            "#include \"%s-tdef.iop.h\"\n"
            "\n", pkg_name, pkg_name, pretty_path_base(pkg->name));

    tab_for_each_entry(dep, &t_weak_deps) {
        IOPC_DO_C_RETHROW(put_include(&buf, "-tdef.iop.h", dep, pkg));
    }
    tab_for_each_entry(dep, &t_deps) {
        IOPC_DO_C_RETHROW(put_include(&buf, "-t.iop.h", dep, pkg));
    }
    if (t_deps.len || t_weak_deps.len) {
        sb_adds(&buf, "\n");
    }

    sb_adds(&buf,
            "#if __has_feature(nullability)\n"
            "#pragma GCC diagnostic push\n"
            "#pragma GCC diagnostic error \"-Wnullability-completeness\"\n"
            "#endif\n\n");

    tab_for_each_entry(en, &pkg->enums) {
        iopc_enum_dump_hdr(&buf, pkg_name, en);
    }
    tab_for_each_entry(st, &pkg->structs) {
        if (st->type == STRUCT_TYPE_UNION) {
            iopc_union_dump_hdr(&buf, pkg_name, st);
        } else {
            iopc_struct_dump_hdr(&buf, pkg, pkg_name, st, NULL);
        }

        if (iopc_is_snmp_st(st->type)) {
            tab_for_each_entry(field, &st->fields) {
               iopc_snmp_field_dump_hdr(&buf, pkg_name, st, field);
            }
        }
    }

    sb_adds(&buf,
            "#if __has_feature(nullability)\n"
            "#pragma GCC diagnostic pop\n"
            "#endif\n\n");

    sb_adds(&buf, "#endif\n");

    strcpy(path + strlen(path) - strlen("-tdef.iop.h"), "-t.iop.h");
    IOPC_DO_C_RETHROW(iopc_write_file(&buf, path));

    /*----- dump the iface header -----*/
    sb_sets(&buf, RO_WARN);
    sb_addf(&buf,
            "#ifndef IOP_HEADER_GUARD_%s_H\n"
            "#define IOP_HEADER_GUARD_%s_H\n"
            "\n"
            "#include \"%s-t.iop.h\"\n",
            pkg_name, pkg_name, pretty_path_base(pkg->name));
    tab_for_each_entry(dep, &t_deps) {
        IOPC_DO_C_RETHROW(put_include(&buf, ".iop.h", dep, pkg));
    }
    tab_for_each_entry(dep, &i_deps) {
        IOPC_DO_C_RETHROW(put_include(&buf, ".iop.h", dep, pkg));
    }
    sb_adds(&buf, "\n");
    tab_for_each_entry(iface, &pkg->ifaces) {
        qv_sort(iopc_fun)(&iface->funs,
                          ^int (iopc_fun_t * const *f1,
                                iopc_fun_t * const *f2) {
            return (*f1)->tag - (*f2)->tag;
        });
        iopc_iface_dump_tdef_hdr(&buf, pkg_name, iface);
    }
    sb_adds(&buf, "\n");
    tab_for_each_entry(iface, &pkg->ifaces) {
        iopc_iface_dump_hdr(&buf, pkg, pkg_name, iface);
    }
    tab_for_each_entry(mod, &pkg->modules) {
        iopc_module_dump_hdr(&buf, pkg, pkg_name, mod);
    }
    iopc_pkg_dump_hdr(&buf, pkg, pkg_name);
    sb_adds(&buf, "#endif\n");

    strcpy(path + strlen(path) - strlen("-t.iop.h"), ".iop.h");
    IOPC_DO_C_RETHROW(iopc_write_file(&buf, path));

    /*----- dump the C file -----*/
    sb_sets(&buf, RO_WARN);
    sb_addf(&buf,
            "#ifndef linux\n"
            "#  warning \"%s assumed linux alignments\"\n"
            "#endif\n", pretty_path(pkg->name));
#ifdef __x86_64__
    sb_addf(&buf,
            "#ifndef __x86_64__\n"
            "#  warning \"%s assumed x86_64 alignments\"\n"
            "#endif\n", pretty_path(pkg->name));
#endif
#ifdef __i386__
    sb_addf(&buf,
            "#ifndef __i386__\n"
            "#  warning \"%s assumed i386 alignments\"\n"
            "#endif\n", pretty_path(pkg->name));
#endif
    sb_addf(&buf,
            "\n"
            "#include \"%s.iop.h\"\n",
            pretty_path_base(pkg->name));
    tab_for_each_entry(dep, &t_weak_deps) {
        IOPC_DO_C_RETHROW(put_include(&buf, ".iop.h", dep, pkg));
    }
    sb_adds(&buf, "\n");
    tab_for_each_entry(en, &pkg->enums) {
        iopc_enum_dump_src(&buf, pkg, pkg_name, en);
    }
    tab_for_each_entry(st, &pkg->structs) {
        IOPC_DO_C_RETHROW(iopc_struct_dump_src(&buf, pkg, pkg_name, st,
                                               NULL, NULL, 0));
    }
    tab_for_each_entry(iface, &pkg->ifaces) {
        IOPC_DO_C_RETHROW(iopc_iface_dump_src(&buf, pkg, pkg_name, iface));
    }
    tab_for_each_entry(mod, &pkg->modules) {
        iopc_module_dump_src(&buf, pkg, pkg_name, mod);
    }
    iopc_pkg_dump_src(&buf, pkg, pkg_name, &t_deps, &i_deps);
    sb_addc(&buf, '\n');

    path[strlen(path) - 1] = 'c';
    IOPC_DO_C_RETHROW(iopc_write_file(&buf, path));

#undef IOPC_DO_C_RETHROW

    /*----- collect memory -----*/
  end:
    qv_wipe(&t_deps);
    qv_wipe(&t_weak_deps);
    qv_wipe(&i_deps);
    qv_deep_wipe(&pp_g, p_delete);
    iopc_put_range_cleanup();
    return res;
}

/* }}} */
/* {{{ IOP²: iopc_pkg_t to iop_pkg_t */
/* {{{ Helpers */

static lstr_t mp_build_fullname(mem_pool_t *mp, const iopc_pkg_t *pkg,
                                const char *name)
{
    return mp_lstr_fmt(mp, "%s.%s", pretty_path_dot(pkg->name), name);
}

/* }}} */
/* {{{ IOP struct/union */

static int mp_iopc_field_to_desc(mem_pool_t *mp, const iopc_field_t *f,
                                 const iopc_struct_t *st, uint16_t *offset,
                                 iop_field_t *fdesc, sb_t *err)
{
    uint16_t size;

    if (f->repeat == IOP_R_DEFVAL) {
        sb_sets(err, "default values are not supported yet");
        return -1;
    }

    *offset = ROUND_UP(*offset, f->align);

    /* The "size" is not the same between iop_field_t and iopc_field_t:
     *
     *    iopc_field_t: size of the field (as returned by fieldtypeof)
     *    iop_field_t: size of the underlying type except for class
     */
    if (iop_type_is_scalar(f->kind)) {
        if (f->repeat == IOP_R_OPTIONAL) {
            iop_opt_type_get_size_and_alignment(f->kind, &size, NULL);
        } else {
            iop_scalar_type_get_size_and_alignment(f->kind, &size, NULL);
        }
    } else {
        if (iopc_field_type_is_class(f)) {
            size = sizeof(void *);
        } else
        if (f->has_external_type) {
            size = f->external_st->size;
        } else {
            size = f->struct_def->size;
        }
    }

    *fdesc = (iop_field_t){
        .name = mp_lstr_dups(mp, f->name, -1),
        .tag = f->tag,
        .tag_len = iopc_tag_len(f->tag),
        .repeat = f->repeat,
        .type = f->kind,
        .data_offs = *offset,
        .flags = iopc_field_build_flags(f, st, NULL), /* TODO attrs */
        /* TODO default value */
        .size = size,
    };

    if (!iop_type_is_scalar(fdesc->type)) {
        if (f->has_external_type) {
            fdesc->u1.st_desc = f->external_st;
        } else {
            /* TODO We're going to have to load dependancies first if we want
             * that to work in multi-package contexts. */
            fdesc->u1.st_desc = f->struct_def->desc;
        }

        assert (fdesc->u1.st_desc);
    } else
    if (fdesc->type == IOP_T_ENUM) {
        if (f->has_external_type) {
            fdesc->u1.en_desc = f->external_en;
        } else {
            /* TODO Ditto. */
            fdesc->u1.en_desc = f->enum_def->desc;
        }

        assert (fdesc->u1.en_desc);
    }

    if (st->type != STRUCT_TYPE_UNION) {
        *offset += f->size;
    }

    return 0;
}

static iop_struct_t *
mp_iopc_struct_to_desc(mem_pool_t *mp, iopc_struct_t *st,
                       const iopc_pkg_t *pkg, sb_t *err)
{
    iop_struct_t *st_desc;
    iop_field_t *fields;
    uint16_t offset = 0;
    iop_array_i32_t ranges;

    if (st->type == STRUCT_TYPE_UNION) {
        offset = sizeof(uint16_t);
    }

    assert(st->fields_by_tag.len == st->fields.len);
    fields = mp_new_raw(mp, iop_field_t, st->fields_in_c_struct_order.len);
    tab_for_each_entry(f, &st->fields_in_c_struct_order) {
        if (mp_iopc_field_to_desc(mp, f, st, &offset, &fields[f->field_pos],
                                  err) < 0)
        {
            sb_prependf(err, "field `%s': ", f->name);
            return NULL;
        }
    }

    if (st->type == STRUCT_TYPE_UNION) {
        /* The anonymous union field offset depends on its alignment, which
         * depends of the IOP union field with the biggest alignment. This
         * loop realigns all the fields offsets on the biggest offset.
         */
        tab_for_each_pos(pos, &st->fields_in_c_struct_order) {
            fields[pos].data_offs = offset;
        }
    }

    ranges = mp_iopc_struct_build_ranges(mp, st);

    {
        iop_struct_t _st_desc = {
            .fullname = mp_build_fullname(mp, pkg, st->name),
            .fields = fields,
            .fields_len = st->fields_in_c_struct_order.len,
            .ranges = ranges.tab,
            .ranges_len = ranges.len / 2,
            .size = st->size, /* TODO Check correctness */
            .flags = st->flags,
            .is_union = (st->type == STRUCT_TYPE_UNION),
            /* TODO st_attrs */
            /* TODO field_attrs */
            /* TODO class_attrs */
        };

        st_desc = mp_new_raw(mp, iop_struct_t, 1);
        /* XXX Work-around all the const fields in 'iop_struct_t'. */
        p_copy(st_desc, &_st_desc, 1);
        st->desc = st_desc;
    };

    return st_desc;
}

/* }}} */
/* {{{ IOP enum */

static iop_enum_t *mp_iopc_enum_to_desc(mem_pool_t *mp,
                                        iopc_enum_t *en,
                                        const iopc_pkg_t *pkg)
{
    iop_enum_t *en_desc;
    iop_array_i32_t ranges;
    lstr_t *names;
    int32_t *values;
    int pos = 0;

    ranges = mp_iopc_enum_build_ranges(mp, en);
    names = mp_new_raw(mp, lstr_t, en->values.len);
    values = mp_new_raw(mp, int32_t, en->values.len);
    tab_for_each_entry(f, &en->values) {
        names[pos] = mp_lstr_dups(mp, f->name, -1);
        values[pos] = f->value;
        pos++;
    }

    {
        iop_enum_t _en_desc = {
            .name = mp_lstr_dup(mp, LSTR(en->name)),
            .fullname = mp_build_fullname(mp, pkg, en->name),
            .names = names,
            .values = values,
            .ranges = ranges.tab,
            .ranges_len = ranges.len / 2,
            .enum_len = en->values.len,
            /* TODO attrs */
            /* TODO aliases */
        };

        en_desc = mp_new_raw(mp, iop_enum_t, 1);
        p_copy(en_desc, &_en_desc, 1);
        en->desc = en_desc;
    }

    return en_desc;
}

/* }}} */
/* {{{ IOP package */

iop_pkg_t *mp_iopc_pkg_to_desc(mem_pool_t *mp, iopc_pkg_t *pkg, sb_t *err)
{
    iop_pkg_t *pkg_desc;
    const iop_struct_t **structs;
    const iop_struct_t **wst;
    const iop_enum_t **enums;
    const iop_enum_t **wen;

    tab_for_each_entry(st, &pkg->structs) {
        iopc_struct_optimize(st);
    }

    enums = mp_new_raw(mp, const iop_enum_t *, pkg->enums.len + 1);
    wen = enums;
    tab_for_each_entry(en, &pkg->enums) {
        *wen++ = mp_iopc_enum_to_desc(mp, en, pkg);
    }
    *wen = NULL;

    structs = mp_new_raw(mp, const iop_struct_t *, pkg->structs.len + 1);
    wst = structs;
    tab_for_each_entry(st, &pkg->structs) {
        *wst = mp_iopc_struct_to_desc(mp, st, pkg, err);
        if (!*wst) {
            sb_prependf(err, "struct %s: ", st->name);
            return NULL;
        }

        wst++;
    }
    *wst = NULL;

    {
        iop_pkg_t _pkg_desc = {
            .name = mp_lstr_dups(mp, pretty_path_dot(pkg->name), -1),
            .enums = enums,
            .structs = structs,
            /* TODO (later) ifaces, mods */
            /* TODO deps */
        };

        pkg_desc = mp_new_raw(mp, iop_pkg_t, 1);
        /* XXX Work-around all the const fields in 'iop_pkg_t'. */
        p_copy(pkg_desc, &_pkg_desc, 1);
    }

    return pkg_desc;
}

/* }}} */
/* }}} */
/* {{{ Module. */

static int iopc_lang_c_initialize(void *arg)
{
    qm_init_cached(rg, &range_h_g);

    return 0;
}

static int iopc_lang_c_shutdown(void)
{
    qm_deep_wipe(rg, &range_h_g, lstr_wipe, IGNORE);

    return 0;
}

MODULE_BEGIN(iopc_lang_c)
MODULE_END()

/* }}} */
