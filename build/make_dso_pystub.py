#!/usr/bin/env python3
###########################################################################
#                                                                         #
# Copyright 2025 INTERSEC SA                                              #
#                                                                         #
# Licensed under the Apache License, Version 2.0 (the "License");         #
# you may not use this file except in compliance with the License.        #
# You may obtain a copy of the License at                                 #
#                                                                         #
#     http://www.apache.org/licenses/LICENSE-2.0                          #
#                                                                         #
# Unless required by applicable law or agreed to in writing, software     #
# distributed under the License is distributed on an "AS IS" BASIS,       #
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.#
# See the License for the specific language governing permissions and     #
# limitations under the License.                                          #
#                                                                         #
###########################################################################

import argparse
import os.path as osp
import pathlib
import sys
import textwrap
from typing import NamedTuple, TextIO

# Import iopy
sys.path.insert(0, osp.join(osp.dirname(__file__), '..', 'src', 'iopy'))
import iopy  # pylint: disable=import-error


class ModuleNameComponents(NamedTuple):
    module_fullname: str
    module_iop_fullname: str
    module_iop_pkg: str
    module_name: str


def build_module_name_component(module_fullname: str) -> ModuleNameComponents:
    module_iop_fullname = module_fullname.replace('.', '_')
    module_pkg, module_name = module_fullname.rsplit('.', 1)
    module_iop_pkg = module_pkg.replace('.', '_')
    return ModuleNameComponents(
        module_fullname=module_fullname,
        module_iop_fullname=module_iop_fullname,
        module_iop_pkg=module_iop_pkg,
        module_name=module_name,
    )


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description='Dump the pystubs of an IOPy DSO')
    parser.add_argument('--dso-path',
                        help='The path of the IOPy DSO to load',
                        type=pathlib.Path, required=True)
    parser.add_argument('--output-pystub',
                        help=(
                            'The output file where to write the python stub '
                            'file'
                        ),
                        type=pathlib.Path, required=True)

    return parser.parse_args()


def dump_preambule(output_file: TextIO) -> None:
    output_file.write(textwrap.dedent(
        """\
        ######################################################
        # THIS FILE IS AUTOGENERATED DO NOT MODIFY DIRECTLY! #
        ######################################################
        # ruff: noqa: CPY001, E501, F401, I001, N801, N802, N815, PYI015, \
RUF012, RUF100

        import asyncio
        import typing

        import iopy

        """,
    ))


def dump_import_packages(packages: list[str], output_file: TextIO) -> None:
    output_file.writelines(
        f'import {pkg_name}__iop\n' for pkg_name in packages)
    output_file.write('\n')


def dump_channel_type(plugin: iopy.Plugin, channel_type: str,
                      module_type: str,
                      module_names: list[ModuleNameComponents],
                      output_file: TextIO) -> None:
    output_file.write(f'class {channel_type}(iopy.{channel_type}):\n')
    output_file.writelines(
        f'    {module_name_comp.module_iop_fullname}: '
        f'{module_name_comp.module_iop_pkg}__iop.'
        f'{module_name_comp.module_name}_{module_type}\n'
        for module_name_comp in module_names
    )
    output_file.write('\n')


def dump_channel_types(plugin: iopy.Plugin,
                       module_names: list[ModuleNameComponents],
                       output_file: TextIO) -> None:
    dump_channel_type(plugin, 'Channel', 'Module', module_names, output_file)
    dump_channel_type(plugin, 'AsyncChannel', 'AsyncModule', module_names,
                      output_file)
    dump_channel_type(plugin, 'ChannelServer', 'ModuleServer', module_names,
                      output_file)


def dump_connect_methods(plugin: iopy.Plugin, output_file: TextIO) -> None:
    text = """
    @typing.overload
    def connect(
        self, uri: str, *,
        default_timeout: float | None = None,
        connect_timeout: float | None = None,
        no_act_timeout: float = 0.0,
        timeout: float | None = None,
        _timeout: float | None = None,
        _login: str | None = None,
        _group: str | None = None,
        _password: str | None = None,
        _kind: str | None = None,
        _workspace_id: int | None = None,
        _dealias: bool | None = None,
        _hdr: ic__iop.Hdr | None = None,
    ) -> Channel: ...

    @typing.overload
    def connect(
        self, *, host: str, port: int,
        default_timeout: float | None = None,
        connect_timeout: float | None = None,
        no_act_timeout: float = 0.0,
        timeout: float | None = None,
        _timeout: float | None = None,
        _login: str | None = None,
        _group: str | None = None,
        _password: str | None = None,
        _kind: str | None = None,
        _workspace_id: int | None = None,
        _dealias: bool | None = None,
        _hdr: ic__iop.Hdr | None = None,
    ) -> Channel: ...

    @typing.overload  # type: ignore[override]
    def async_connect(
        self, uri: str, *,
        default_timeout: float | None = None,
        connect_timeout: float | None = None,
        no_act_timeout: float = 0.0,
        timeout: float | None = None,
        _timeout: float | None = None,
        _login: str | None = None,
        _group: str | None = None,
        _password: str | None = None,
        _kind: str | None = None,
        _workspace_id: int | None = None,
        _dealias: bool | None = None,
        _hdr: ic__iop.Hdr | None = None,
    ) -> asyncio.Future[AsyncChannel]: ...

    @typing.overload
    def async_connect(
        self, *, host: str, port: int,
        default_timeout: float | None = None,
        connect_timeout: float | None = None,
        no_act_timeout: float = 0.0,
        timeout: float | None = None,
        _timeout: float | None = None,
        _login: str | None = None,
        _group: str | None = None,
        _password: str | None = None,
        _kind: str | None = None,
        _workspace_id: int | None = None,
        _dealias: bool | None = None,
        _hdr: ic__iop.Hdr | None = None,
    ) -> asyncio.Future[AsyncChannel]: ...

    def channel_server(self) -> ChannelServer: ...

    # pylint: disable=invalid-name
    def ChannelServer(self) -> ChannelServer: ...
    """

    output_file.write(text.rstrip())
    output_file.write('\n')


def dump_plugin(plugin: iopy.Plugin, packages: list[str],
                module_names: list[ModuleNameComponents],
                output_file: TextIO) -> None:
    output_file.write('class Plugin(iopy.Plugin):\n')
    output_file.writelines(
        f'    {pkg_name}: {pkg_name}__iop.Package\n' for pkg_name in packages)

    # Dump modules
    output_file.write('\n')
    output_file.write('    modules = {\n')
    output_file.writelines(
        f"        '{module_name_comp.module_fullname}': "
        f'{module_name_comp.module_iop_pkg}__iop.'
        f'{module_name_comp.module_name}_Module(),\n'
        for module_name_comp in module_names
    )
    output_file.write('    }\n')

    dump_connect_methods(plugin, output_file)


def process_dso(dso_path: pathlib.Path, output_pystub: pathlib.Path) -> None:
    plugin = iopy.Plugin(str(dso_path))

    packages = sorted(
        pkg_name for pkg_name, pkg_type
        in plugin.__dict__.items()
        if isinstance(pkg_type, iopy.Package)
    )

    module_names = sorted(
        build_module_name_component(module_fullname)
        for module_fullname in plugin.modules
    )

    with open(output_pystub, 'w') as output_file:
        dump_preambule(output_file)
        dump_import_packages(packages, output_file)
        dump_channel_types(plugin, module_names, output_file)
        dump_plugin(plugin, packages, module_names, output_file)


def main() -> None:
    args = parse_args()
    process_dso(args.dso_path, args.output_pystub)


if __name__ == '__main__':
    main()
