/***************************************************************************/
/*                                                                         */
/* Copyright 2019 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include <math.h>

#include "unix.h"
#include "iop-yaml.h"
#include "iop-helpers.in.c"
#include "log.h"

static struct iop_yaml_g {
    logger_t logger;
    logger_t parse_logger;
    logger_t unpack_logger;
} iop_yaml_g = {
#define _G iop_yaml_g
    .logger = LOGGER_INIT(NULL, "iop-yaml", LOG_INHERITS),
    .parse_logger = LOGGER_INIT(&_G.logger, "parse", LOG_INHERITS),
    .unpack_logger = LOGGER_INIT(&_G.logger, "unpack", LOG_INHERITS),
};

/* {{{ yaml -> AST */
/* {{{ AST types definitions */

typedef struct yaml_data_t yaml_data_t;
typedef struct yaml_scalar_t yaml_scalar_t;
typedef struct yaml_obj_t yaml_obj_t;

/* All possible types for YAML scalar values */
typedef enum yaml_scalar_type_t {
    /* raw string, or delimited with "" */
    YAML_SCALAR_STRING,
    YAML_SCALAR_DOUBLE,
    YAML_SCALAR_UINT,
    YAML_SCALAR_INT,
    /* true or false */
    YAML_SCALAR_BOOL,
    /* ~ or null */
    YAML_SCALAR_NULL
} yaml_scalar_type_t;

/* Position in the parsed string */
typedef struct yaml_pos_t {
    uint32_t line_nb;
    uint32_t col_nb;
    /* Pointer to this position in the string. Very useful for informative
     * logs and errors */
    const char *s;
} yaml_pos_t;

#define YAML_POS_FMT  "%u:%u"
#define YAML_POS_ARG(p)  p.line_nb, p.col_nb

struct yaml_scalar_t {
    union {
        lstr_t s;
        double d;
        uint64_t u;
        int64_t i;
        bool b;
    };
    yaml_scalar_type_t type;
};

typedef enum yaml_data_type_t {
    /* Scalar value */
    YAML_DATA_SCALAR,
    /* Sequence, ie array of data */
    YAML_DATA_SEQ,
    /* Object, ie list of (string, data) pairs */
    YAML_DATA_OBJ
} yaml_data_type_t;

struct yaml_data_t {
    /* Position in the parsed string where the data started */
    yaml_pos_t pos_start;
    /* Position in the parsed string where the data ended */
    yaml_pos_t pos_end;
    union {
        yaml_scalar_t scalar;
        struct {
            yaml_data_t *seq;
            uint32_t seq_len;
        };
        yaml_obj_t *obj;
    };
    yaml_data_type_t type;
};
qvector_t(yaml_data, yaml_data_t);
qm_kvec_t(yaml_data, lstr_t, yaml_data_t, qhash_lstr_hash, qhash_lstr_equal);

struct yaml_obj_t {
    qm_t(yaml_data) fields;
    /* LSTR_NULL_V if untyped */
    lstr_t tag;
};

/* }}} */
/* {{{ Parsing types definitions */

typedef struct yaml_env_t {
    /* Memory pool to use for internal allocations. */
    mem_pool_t *mp;

    /* String to parse. */
    pstream_t ps;

    /* Current line number. */
    uint32_t line_number;

    /* Pointer to the newline character that started the current line (ie
     * the newline character separating the previous line from the current
     * one).
     * Used to compute current column number of ps->s */
    const char *pos_newline;

    /* Error buffer. */
    sb_t err;
} yaml_env_t;

/* }}} */
/* {{{ Utils */

static const char *yaml_scalar_get_type(const yaml_scalar_t *scalar)
{
    switch (scalar->type) {
      case YAML_SCALAR_STRING:
        return "a string value";
      case YAML_SCALAR_DOUBLE:
        return "a double value";
      case YAML_SCALAR_UINT:
        return "an unsigned integer value";
      case YAML_SCALAR_INT:
        return "an integer value";
      case YAML_SCALAR_BOOL:
        return "a boolean value";
      case YAML_SCALAR_NULL:
        return "a null value";
    }

    assert (false);
    return NULL;
}

static const char *yaml_data_get_type(const yaml_data_t *data)
{
    switch (data->type) {
      case YAML_DATA_OBJ:
        return (data->obj->tag.s) ? "a tagged object" : "an object";
      case YAML_DATA_SEQ:
        return "a sequence";
      case YAML_DATA_SCALAR:
        return yaml_scalar_get_type(&data->scalar);
    }

    assert (false);
    return NULL;
}

static lstr_t yaml_data_get_span(const yaml_data_t *data)
{
    return LSTR_INIT_V(data->pos_start.s,
                       data->pos_end.s - data->pos_start.s);
}

static uint32_t yaml_env_get_column_nb(const yaml_env_t *env)
{
    return env->ps.s - env->pos_newline;
}

static yaml_pos_t yaml_env_get_pos(const yaml_env_t *env)
{
    return (yaml_pos_t){
        .line_nb = env->line_number,
        .col_nb = yaml_env_get_column_nb(env),
        .s = env->ps.s,
    };
}

static inline void yaml_env_skipc(yaml_env_t *env)
{
    IGNORE(ps_getc(&env->ps));
}

static void
yaml_env_init_data_with_end(const yaml_env_t *env, yaml_data_type_t type,
                            yaml_pos_t pos_start, yaml_pos_t pos_end,
                            yaml_data_t *out)
{
    p_clear(out, 1);
    out->type = type;
    out->pos_start = pos_start;
    out->pos_end = pos_end;
}

static void
yaml_env_init_data(const yaml_env_t *env, yaml_data_type_t type,
                   yaml_pos_t pos_start, yaml_data_t *out)
{
    yaml_env_init_data_with_end(env, type, pos_start, yaml_env_get_pos(env),
                                out);
}

/* }}} */
/* {{{ Errors */

typedef enum yaml_error_t {
    YAML_ERR_BAD_KEY,
    YAML_ERR_BAD_STRING,
    YAML_ERR_MISSING_DATA,
    YAML_ERR_WRONG_DATA,
    YAML_ERR_WRONG_INDENT,
    YAML_ERR_WRONG_OBJECT,
} yaml_error_t;

static int yaml_env_set_err(yaml_env_t *env, yaml_error_t type,
                            const char *msg)
{
    yaml_pos_t pos = yaml_env_get_pos(env);

    sb_setf(&env->err, YAML_POS_FMT ": ", YAML_POS_ARG(pos));

    switch (type) {
      case YAML_ERR_BAD_KEY:
        sb_addf(&env->err, "invalid key, %s", msg);
        break;
      case YAML_ERR_BAD_STRING:
        sb_addf(&env->err, "expected string, %s", msg);
        break;
      case YAML_ERR_MISSING_DATA:
        sb_addf(&env->err, "missing data, %s", msg);
        break;
      case YAML_ERR_WRONG_DATA:
        sb_addf(&env->err, "wrong type of data, %s", msg);
        break;
      case YAML_ERR_WRONG_INDENT:
        sb_addf(&env->err, "wrong indentation, %s", msg);
        break;
      case YAML_ERR_WRONG_OBJECT:
        sb_addf(&env->err, "wrong object, %s", msg);
        break;
    }

    return -1;
}

/* }}} */
/* {{{ Parser */

static int yaml_env_parse_data(yaml_env_t *env, const uint32_t min_indent,
                               yaml_data_t *out);

static void yaml_env_ltrim(yaml_env_t *env)
{
    bool in_comment = false;

    while (!ps_done(&env->ps)) {
        int c = ps_peekc(env->ps);

        if (c == '#') {
            in_comment = true;
        } else
        if (c == '\n') {
            env->line_number++;
            env->pos_newline = env->ps.s;
            in_comment = false;
        } else
        if (!isspace(c) && !in_comment) {
            break;
        }
        yaml_env_skipc(env);
    }
}

static int
yaml_env_parse_tagged_obj(yaml_env_t *env, const uint32_t min_indent,
                          yaml_data_t *out)
{
    /* TODO: reject tags starting with anything but a letter */
    /* a-zA-Z0-9. */
    static const ctype_desc_t ctype_tag = { {
        0x00000000, 0x03ff4000, 0x07fffffe, 0x07fffffe,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
    } };
    yaml_pos_t pos_start = yaml_env_get_pos(env);
    pstream_t tag;

    assert (ps_peekc(env->ps) == '!');
    yaml_env_skipc(env);

    tag = ps_get_span(&env->ps, &ctype_tag);
    if (ps_len(&tag) <= 0) {
        return yaml_env_set_err(env, YAML_ERR_WRONG_DATA,
                                "expected a string after '!'");
    }

    RETHROW(yaml_env_parse_data(env, min_indent, out));
    switch (out->type) {
      case YAML_DATA_SEQ:
      case YAML_DATA_SCALAR:
        return yaml_env_set_err(env, YAML_ERR_WRONG_DATA,
                                "can only use a tag on an object");
      case YAML_DATA_OBJ:
        if (out->obj->tag.s) {
            return yaml_env_set_err(env, YAML_ERR_WRONG_OBJECT,
                                    "two tags have been declared");
        }
        break;
    }

    out->obj->tag = LSTR_PS_V(&tag);
    out->pos_start = pos_start;
    return 0;
}

static bool
ps_startswith_yaml_seq_prefix(const pstream_t *ps)
{
    if (!ps_has(ps, 2)) {
        return false;
    }

    return ps->s[0] == '-' && isspace(ps->s[1]);
}

static int yaml_env_parse_seq(yaml_env_t *env, const uint32_t min_indent,
                              yaml_data_t *out)
{
    qv_t(yaml_data) datas;
    yaml_pos_t pos_start = yaml_env_get_pos(env);
    yaml_pos_t pos_end = {0};

    mp_qv_init(env->mp, &datas, 0);

    assert (ps_startswith_yaml_seq_prefix(&env->ps));

    for (;;) {
        yaml_data_t elem;
        uint32_t last_indent;

        /* skip '-' */
        yaml_env_skipc(env);

        RETHROW(yaml_env_parse_data(env, min_indent + 1, &elem));
        pos_end = elem.pos_end;
        qv_append(&datas, elem);

        yaml_env_ltrim(env);
        if (ps_done(&env->ps)) {
            break;
        }

        last_indent = yaml_env_get_column_nb(env);
        if (last_indent < min_indent) {
            /* we go down on indent, so the seq is over */
            break;
        }
        if (last_indent > min_indent) {
            return yaml_env_set_err(env, YAML_ERR_WRONG_INDENT,
                                    "line not aligned with current sequence");
        } else
        if (!ps_startswith_yaml_seq_prefix(&env->ps)) {
            return yaml_env_set_err(env, YAML_ERR_WRONG_DATA,
                                    "expected another element of sequence");
        }
    }

    yaml_env_init_data_with_end(env, YAML_DATA_SEQ, pos_start, pos_end, out);
    out->seq = datas.tab;
    out->seq_len = datas.len;
    return 0;
}

static int yaml_env_parse_raw_obj(yaml_env_t *env, const uint32_t min_indent,
                                  yaml_data_t *out)
{
    qm_t(yaml_data) fields;
    yaml_pos_t pos_start = yaml_env_get_pos(env);
    yaml_pos_t pos_end = {0};

    mp_qm_init(yaml_data, env->mp, &fields, 0);

    for (;;) {
        pstream_t ps_key;
        yaml_data_t val;
        lstr_t key;
        uint32_t last_indent;
        int32_t pos;

        ps_key = ps_get_span(&env->ps, &ctype_isalnum);
        if (ps_len(&ps_key) == 0) {
            return yaml_env_set_err(env, YAML_ERR_BAD_KEY,
                                    "only alpha-numeric characters allowed");
        } else
        if (ps_getc(&env->ps) != ':') {
            return yaml_env_set_err(env, YAML_ERR_BAD_KEY, "missing colon");
        }

        key = LSTR_PS_V(&ps_key);
        pos = qm_reserve(yaml_data, &fields, &key, 0);
        if (pos & QHASH_COLLISION) {
            return yaml_env_set_err(env, YAML_ERR_BAD_KEY,
                                    "key is already declared in the object");
        }

        RETHROW(yaml_env_parse_data(env, min_indent + 1, &val));

        fields.values[pos] = val;
        pos_end = val.pos_end;

        yaml_env_ltrim(env);
        if (ps_done(&env->ps)) {
            break;
        }

        last_indent = yaml_env_get_column_nb(env);
        if (last_indent < min_indent) {
            /* we go down on indent, so the obj is over */
            break;
        }
        if (last_indent > min_indent) {
            return yaml_env_set_err(env, YAML_ERR_WRONG_INDENT,
                                    "line not aligned with current object");
        }
    }

    yaml_env_init_data_with_end(env, YAML_DATA_OBJ, pos_start, pos_end, out);
    out->obj = mp_new(env->mp, yaml_obj_t, 1);
    out->obj->fields = fields;
    return 0;
}

static pstream_t yaml_get_scalar_ps(pstream_t *ps)
{
    /* '\n' and '#' */
    static const ctype_desc_t ctype_scalarend = { {
        0x00000400, 0x00000008, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
    } };
    pstream_t scalar;

    scalar = ps_get_cspan(ps, &ctype_scalarend);
    /* need to rtrim to remove extra spaces */
    ps_rtrim(&scalar);

    return scalar;
}

static int yaml_env_parse_scalar(yaml_env_t *env, yaml_data_t *out)
{
    lstr_t line;
    yaml_pos_t pos_start = yaml_env_get_pos(env);
    pstream_t span;

    if (ps_peekc(env->ps) == '"') {
        int line_nb = 0;
        int col_nb = 0;
        sb_t buf;
        int res;

        yaml_env_skipc(env);
        mp_sb_init(env->mp, &buf, 128);
        /* XXX use a json util for escaping handling. To be factorized
         * outside of the json file however. */
        res = iop_json_parse_str(&env->ps, &buf, &line_nb, &col_nb, '"');

        if (res >= 0) {
            yaml_env_init_data(env, YAML_DATA_SCALAR, pos_start, out);
            out->scalar.type = YAML_SCALAR_STRING;
            out->scalar.s = LSTR_SB_V(&buf);
            return 0;
        } else
        if (res == IOP_JERR_UNCLOSED_STRING) {
            return yaml_env_set_err(env, YAML_ERR_BAD_STRING,
                                    "missing closing '\"'");
        } else
        if (IOP_JERR_EXP_SMTH) {
            return yaml_env_set_err(env, YAML_ERR_BAD_STRING,
                                    "invalid backslash");
        }

        assert (false);
        return yaml_env_set_err(env, YAML_ERR_BAD_STRING, "invalid string");
    }

    /* get scalar string, ie up to newline or comment */
    span = yaml_get_scalar_ps(&env->ps);
    /* this is caught by the ps_done check in the beginning of parse_data */
    assert (ps_len(&span) > 0);

    line = mp_lstr_dup(env->mp, LSTR_PS_V(&span));
    lstr_ascii_tolower(&line);
    yaml_env_init_data(env, YAML_DATA_SCALAR, pos_start, out);

    /* special strings */
    if (lstr_equal(line, LSTR("~")) || lstr_equal(line, LSTR("null"))) {
        out->scalar.type = YAML_SCALAR_NULL;
        return 0;
    } else
    if (lstr_equal(line, LSTR("true"))) {
        out->scalar.type = YAML_SCALAR_BOOL;
        out->scalar.b = true;
        return 0;
    } else
    if (lstr_equal(line, LSTR("false"))) {
        out->scalar.type = YAML_SCALAR_BOOL;
        out->scalar.b = false;
        return 0;
    } else
    if (lstr_equal(line, LSTR("-.inf"))) {
        out->scalar.type = YAML_SCALAR_DOUBLE;
        out->scalar.d = -INFINITY;
        return 0;
    } else
    if (lstr_equal(line, LSTR(".inf"))) {
        out->scalar.type = YAML_SCALAR_DOUBLE;
        out->scalar.d = INFINITY;
        return 0;
    } else
    if (lstr_equal(line, LSTR(".nan"))) {
        out->scalar.type = YAML_SCALAR_DOUBLE;
        out->scalar.d = NAN;
        return 0;
    }

    /* try to parse it as a integer, then as a float. Otherwise, it is
     * a string */
    if (line.s[0] == '-') {
        int64_t i;

        if (lstr_to_int64(line, &i) == 0) {
            out->scalar.type = YAML_SCALAR_INT;
            out->scalar.i = i;
            return 0;
        }
    } else {
        uint64_t u;

        if (lstr_to_uint64(line, &u) == 0) {
            out->scalar.type = YAML_SCALAR_UINT;
            out->scalar.u = u;
            return 0;
        }
    }

    {
        double d;

        if (lstr_to_double(line, &d) == 0) {
            out->scalar.type = YAML_SCALAR_DOUBLE;
            out->scalar.d = d;
            return 0;
        }
    }

    out->scalar.type = YAML_SCALAR_STRING;
    out->scalar.s = LSTR_PS_V(&span);
    return 0;
}

static int yaml_env_parse_data(yaml_env_t *env, const uint32_t min_indent,
                               yaml_data_t *out)
{
    pstream_t saved_ps;
    pstream_t key;
    uint32_t cur_indent;

    yaml_env_ltrim(env);
    if (ps_done(&env->ps)) {
        return yaml_env_set_err(env, YAML_ERR_MISSING_DATA,
                                "unexpected end of line");
    }

    cur_indent = yaml_env_get_column_nb(env);
    if (cur_indent < min_indent) {
        return yaml_env_set_err(env, YAML_ERR_WRONG_INDENT,
                                "missing element");
    }

    if (ps_peekc(env->ps) == '!') {
        RETHROW(yaml_env_parse_tagged_obj(env, min_indent, out));
        goto end;
    }

    if (ps_startswith_yaml_seq_prefix(&env->ps)) {
        RETHROW(yaml_env_parse_seq(env, cur_indent, out));
        goto end;
    }

    /* try to parse a key */
    saved_ps = env->ps;
    key = ps_get_span(&env->ps, &ctype_isalnum);
    if (ps_len(&key) > 0 && ps_peekc(env->ps) == ':') {
        env->ps = saved_ps;
        RETHROW(yaml_env_parse_raw_obj(env, cur_indent, out));
        goto end;
    }
    env->ps = saved_ps;

    /* otherwise, parse the line as a scalar */
    RETHROW(yaml_env_parse_scalar(env, out));

  end:
    if (logger_is_traced(&_G.parse_logger, 2)) {
        logger_trace_scope(&_G.parse_logger, 2);
        logger_cont("parsed %s from "YAML_POS_FMT" up to "YAML_POS_FMT,
                    yaml_data_get_type(out), YAML_POS_ARG(out->pos_start),
                    YAML_POS_ARG(out->pos_end));
        if (out->type == YAML_DATA_SCALAR) {
            logger_cont(": %*pM", LSTR_FMT_ARG(yaml_data_get_span(out)));
        }
    }
    return 0;
}

/* }}} */
/* }}} */
/* {{{ yunpack */

typedef struct yunpack_error_t {
    /* the yaml data that caused the error */
    const yaml_data_t * nonnull data;
    /* details of the error */
    sb_t buf;
} yunpack_error_t;

typedef struct yunpack_env_t {
    mem_pool_t *mp;

    yunpack_error_t err;

    /* Only IOP_UNPACK_FORBID_PRIVATE is handled. */
    int flags;
} yunpack_env_t;

/* {{{ Yaml scalar to iop field */

/* FIXME: compare with JSON to have as few type mismatch as possible, for
 * backward-compatibility */

typedef enum yunpack_res_t {
    YUNPACK_INVALID_B64_VAL = -4,
    YUNPACK_INVALID_ENUM_VAL = -3,
    YUNPACK_TYPE_MISMATCH = -2,
    YUNPACK_OOB = -1,
    YUNPACK_OK = 0,
} yunpack_res_t;

static yunpack_res_t
yaml_nil_to_iop_field(const iop_field_t * nonnull fdesc, void * nonnull out)
{
    if (fdesc->repeat == IOP_R_REPEATED) {
        lstr_t *arr = out;

        /* null value on an array means empty array */
        p_clear(arr, 1);
        return YUNPACK_OK;
    }

    switch (fdesc->type) {
      case IOP_T_STRING:
      case IOP_T_XML:
      case IOP_T_DATA:
        *(lstr_t *)out = LSTR_NULL_V;
        return YUNPACK_OK;
      case IOP_T_VOID:
        return YUNPACK_OK;
      default:
        return YUNPACK_TYPE_MISMATCH;
    }
}

static yunpack_res_t
yaml_string_to_iop_field(mem_pool_t *mp, const lstr_t str,
                         const iop_field_t * nonnull fdesc,
                         void * nonnull out)
{
    switch (fdesc->type) {
      case IOP_T_STRING:
      case IOP_T_XML:
        *(lstr_t *)out = mp_lstr_dup(mp, str);
        return YUNPACK_OK;

      case IOP_T_DATA: {
        sb_t  sb;
        /* TODO: factorize this with iop-json, iop-xml, etc */
        int   blen = DIV_ROUND_UP(str.len * 3, 4);
        char *buf  = mp_new_raw(mp, char, blen + 1);
        lstr_t *data = out;

        sb_init_full(&sb, buf, 0, blen + 1, &mem_pool_static);
        if (sb_add_lstr_unb64(&sb, str) < 0) {
            mp_delete(mp, &buf);
            return YUNPACK_INVALID_B64_VAL;
        }
        data->data = buf;
        data->len  = sb.len;
        return YUNPACK_OK;
      }

      case IOP_T_ENUM: {
        bool found;
        int i;

        i = iop_enum_from_lstr_desc(fdesc->u1.en_desc, str, &found);
        if (!found) {
            return YUNPACK_INVALID_ENUM_VAL;
        }
        *(int32_t *)out = i;
        return 0;
      }

      default:
        return YUNPACK_TYPE_MISMATCH;
    }
}

static void
set_string_from_stream(mem_pool_t * nonnull mp,
                       const yaml_data_t * nonnull data,
                       lstr_t * nonnull out)
{
    *out = mp_lstr_dups(mp, data->pos_start.s,
                        data->pos_end.s - data->pos_start.s);
}

static yunpack_res_t
yaml_double_to_iop_field(mem_pool_t * nonnull mp,
                         const yaml_data_t * nonnull data,
                         double d, const iop_field_t * nonnull fdesc,
                         void * nonnull out)
{
    switch (fdesc->type) {
      case IOP_T_DOUBLE:
        *(double *)out = d;
        return YUNPACK_OK;
      case IOP_T_STRING:
        set_string_from_stream(mp, data, out);
        return YUNPACK_OK;
      default:
        return YUNPACK_TYPE_MISMATCH;
    }
}

static int
yaml_uint_to_iop_field(mem_pool_t * nonnull mp,
                       const yaml_data_t * nonnull data,
                       uint64_t u, const iop_field_t * nonnull fdesc,
                       void * nonnull out)
{
#define CHECK_MAX(v, max)  THROW_IF(v > max, YUNPACK_OOB)

    switch (fdesc->type) {
      case IOP_T_I8:
        CHECK_MAX(u, INT8_MAX);
        *(int8_t *)out = u;
        return YUNPACK_OK;
      case IOP_T_U8:
        CHECK_MAX(u, UINT8_MAX);
        *(uint8_t *)out = u;
        return YUNPACK_OK;
      case IOP_T_I16:
        CHECK_MAX(u, INT16_MAX);
        *(int16_t *)out = u;
        return YUNPACK_OK;
      case IOP_T_U16:
        CHECK_MAX(u, UINT16_MAX);
        *(uint16_t *)out = u;
        return YUNPACK_OK;
      case IOP_T_I32:
        CHECK_MAX(u, INT32_MAX);
        *(int32_t *)out = u;
        return YUNPACK_OK;
      case IOP_T_U32:
        CHECK_MAX(u, UINT32_MAX);
        *(uint32_t *)out = u;
        return YUNPACK_OK;
      case IOP_T_I64:
        CHECK_MAX(u, INT64_MAX);
        *(int64_t *)out = u;
        return YUNPACK_OK;
      case IOP_T_U64:
        *(uint64_t *)out = u;
        return YUNPACK_OK;
      case IOP_T_STRING:
        set_string_from_stream(mp, data, out);
        return YUNPACK_OK;
      default:
        return YUNPACK_TYPE_MISMATCH;
    }

#undef CHECK_MAX
}

static int
yaml_int_to_iop_field(int64_t i, const iop_field_t * nonnull fdesc,
                      void * nonnull out)
{
#define CHECK_RANGE(v, min, max)  THROW_IF(v < min || v > max, YUNPACK_OOB)

    switch (fdesc->type) {
      case IOP_T_I8:
        CHECK_RANGE(i, INT8_MIN, INT8_MAX);
        *(int8_t *)out = i;
        return YUNPACK_OK;
      case IOP_T_U8:
        CHECK_RANGE(i, 0, UINT8_MAX);
        *(uint8_t *)out = i;
        return YUNPACK_OK;
      case IOP_T_I16:
        CHECK_RANGE(i, INT16_MIN, INT16_MAX);
        *(int16_t *)out = i;
        return YUNPACK_OK;
      case IOP_T_U16:
        CHECK_RANGE(i, 0, UINT16_MAX);
        *(uint16_t *)out = i;
        return YUNPACK_OK;
      case IOP_T_I32:
        CHECK_RANGE(i, INT32_MIN, INT32_MAX);
        *(int32_t *)out = i;
        return YUNPACK_OK;
      case IOP_T_U32:
        CHECK_RANGE(i, 0, UINT32_MAX);
        *(uint32_t *)out = i;
        return YUNPACK_OK;
      case IOP_T_I64:
        *(int64_t *)out = i;
        return YUNPACK_OK;
      case IOP_T_U64:
        CHECK_RANGE(i, 0, INT64_MAX);
        *(uint64_t *)out = i;
        return YUNPACK_OK;
      default:
        return YUNPACK_TYPE_MISMATCH;
    }
}

#undef CHECK_RANGE

static int
yaml_bool_to_iop_field(mem_pool_t * nonnull mp,
                       const yaml_data_t * nonnull data,
                       bool b, const iop_field_t * nonnull fdesc,
                       void * nonnull out)
{
    switch (fdesc->type) {
      case IOP_T_BOOL:
        *(bool *)out = b;
        return YUNPACK_OK;
      case IOP_T_STRING:
        set_string_from_stream(mp, data, out);
        return YUNPACK_OK;
      default:
        return YUNPACK_TYPE_MISMATCH;
    }
}

static yunpack_res_t
yaml_scalar_to_iop_field(const yunpack_env_t * nonnull env,
                         const yaml_data_t * nonnull data,
                         const iop_field_t * nonnull fdesc,
                         void * nonnull out)
{
    const yaml_scalar_t *scalar = &data->scalar;

    switch (scalar->type) {
      case YAML_SCALAR_NULL:
        return yaml_nil_to_iop_field(fdesc, out);
      case YAML_SCALAR_STRING:
        return yaml_string_to_iop_field(env->mp, scalar->s, fdesc, out);
      case YAML_SCALAR_DOUBLE:
        return yaml_double_to_iop_field(env->mp, data, scalar->d, fdesc, out);
      case YAML_SCALAR_UINT:
        return yaml_uint_to_iop_field(env->mp, data, scalar->u, fdesc, out);
      case YAML_SCALAR_INT:
        return yaml_int_to_iop_field(scalar->i, fdesc, out);
      case YAML_SCALAR_BOOL:
        return yaml_bool_to_iop_field(env->mp, data, scalar->b, fdesc, out);
    }

    assert (false);
    return YUNPACK_TYPE_MISMATCH;
}

/* }}} */
/* {{{ Yaml data to union */

static int
yaml_data_to_iop_field(yunpack_env_t * nonnull env,
                       const yaml_data_t * nonnull data,
                       const iop_struct_t * nonnull st_desc,
                       const iop_field_t * nonnull fdesc,
                       void * nonnull out);

static int
yaml_data_to_union(yunpack_env_t * nonnull env,
                   const yaml_data_t * nonnull data,
                   const iop_struct_t * nonnull st_desc, void * nonnull out)
{
    if (data->type != YAML_DATA_OBJ) {
        sb_setf(&env->err.buf, "cannot unpack %s into a union",
                yaml_data_get_type(data));
        goto error;
    }

    if (data->obj->tag.s) {
        sb_setf(&env->err.buf, "specifying a tag is not allowed");
        goto error;
    }

    if (qm_len(yaml_data, &data->obj->fields) != 1) {
        sb_setf(&env->err.buf, "a single key must be specified");
        goto error;
    }

    qm_for_each_key_value_p(yaml_data, key, val, &data->obj->fields) {
        const iop_field_t *field_desc = NULL;

        iop_field_find_by_name(st_desc, key, NULL, &field_desc);
        if (!field_desc) {
            sb_setf(&env->err.buf, "unknown field `%pL`", &key);
            goto error;
        }

        iop_union_set_tag(st_desc, field_desc->tag, out);
        RETHROW(yaml_data_to_iop_field(env, val, st_desc, field_desc,
                                       (char *)out + field_desc->data_offs));
    }

    return 0;

  error:
    sb_prependf(&env->err.buf, "cannot unpack YAML as a `%pL` IOP union: ",
                &st_desc->fullname);
    env->err.data = data;
    return -1;
}

/* }}} */
/* {{{ Yaml obj to iop field */

static uint32_t
get_nb_fields_in_class(const iop_struct_t * nonnull st)
{
    uint32_t nb_fields = 0;

    while (st) {
        nb_fields += st->fields_len;
        st = st->class_attrs->parent;
    }

    return nb_fields;
}

static int
check_class(yunpack_env_t * nonnull env,
            const iop_struct_t * nonnull st)
{
    if (st->class_attrs->is_abstract) {
        sb_setf(&env->err.buf, "`%pL` is abstract and cannot be unpacked",
                &st->fullname);
        return -1;
    }

    if (env->flags & IOP_UNPACK_FORBID_PRIVATE
    &&  st->class_attrs->is_private)
    {
        sb_setf(&env->err.buf, "`%pL` is private and cannot be unpacked",
                &st->fullname);
        return -1;
    }

    return 0;
}

static int
yaml_data_to_typed_struct(yunpack_env_t * nonnull env,
                          const yaml_data_t * nonnull data,
                          const iop_struct_t * nonnull st,
                          void * nonnull out)
{
    byte *seen;
    const iop_struct_t *real_st = st;
    uint32_t nb_fields;

    if (st->is_union) {
        return yaml_data_to_union(env, data, st, out);
    }

    if (data->obj->tag.s) {
        real_st = iop_get_class_by_fullname(st, data->obj->tag);
        if (!real_st) {
            sb_setf(&env->err.buf, "unknown type `%pL` provided in tag, or "
                    "not a child of `%pL`", &data->obj->tag, &st->fullname);
            real_st = st;
            goto error;
        }
        if (!iop_class_is_a(real_st, st)) {
            sb_setf(&env->err.buf, "provided tag `%pL` is not a child of "
                    "`%pL`", &real_st->fullname, &st->fullname);
            real_st = st;
            goto error;
        }
    }

    if (iop_struct_is_class(real_st)) {
        void **out_class = out;

        if (check_class(env, real_st) < 0) {
            goto error;
        }
        nb_fields = get_nb_fields_in_class(real_st);

        *out_class = mp_imalloc(env->mp, real_st->size, 8, MEM_RAW);
        *(const iop_struct_t **)(*out_class) = real_st;
        out = *out_class;
    } else {
        nb_fields = real_st->fields_len;
    }

    seen = p_alloca(byte, BITS_TO_ARRAY_LEN(byte, nb_fields));

    switch (data->type) {
      case YAML_DATA_SCALAR:
        if (data->scalar.type == YAML_SCALAR_NULL) {
            goto check_missing_fields;
        }
        /* FALLTHROUGH */
      case YAML_DATA_SEQ:
        sb_setf(&env->err.buf, "cannot unpack %s into a struct",
                yaml_data_get_type(data));
        goto error;
      case YAML_DATA_OBJ:
        break;
    }

    qm_for_each_key_value_p(yaml_data, key, val, &data->obj->fields) {
        int ifield;
        const iop_struct_t *field_st = NULL;
        const iop_field_t *field_desc = NULL;

        ifield = iop_field_find_by_name(real_st, key, &field_st, &field_desc);
        if (!field_desc) {
            sb_setf(&env->err.buf, "unknown field `%pL`", &key);
            goto error;
        }

        /* this is already rejected by the yaml parser */
        assert (ifield >= 0 && !TST_BIT(seen, ifield));
        SET_BIT(seen, ifield);

        if (field_desc && env->flags & IOP_UNPACK_FORBID_PRIVATE) {
            const iop_field_attrs_t *attrs;

            attrs = iop_field_get_attrs(field_st, field_desc);
            if (attrs && TST_BIT(&attrs->flags, IOP_FIELD_PRIVATE)) {
                sb_setf(&env->err.buf, "unknown field `%pL`", &key);
                goto error;
            }
        }

        /* FIXME: check constraints */

        RETHROW(yaml_data_to_iop_field(env, val, field_st, field_desc,
                                       (char *)out + field_desc->data_offs));
    }

  check_missing_fields:
    st = real_st;
    for (uint32_t n = 0, i = 0; n < nb_fields; n++, i++) {
        const iop_field_t *fdesc;

        if (n >= st->fields_len) {
            assert (iop_struct_is_class(st));
            assert (iop_struct_is_class(st->class_attrs->parent));
            st = st->class_attrs->parent;
            i = 0;
        }

        if (TST_BIT(seen, n)) {
            continue;
        }

        fdesc = &st->fields[i];
        if (iop_skip_absent_field_desc(env->mp, out, st, fdesc) < 0) {
            sb_setf(&env->err.buf, "missing field `%pL`", &fdesc->name);
            goto error;
        }
    }

    return 0;

  error:
    sb_prependf(&env->err.buf, "cannot unpack YAML as a `%pL` IOP struct: ",
                &real_st->fullname);
    env->err.data = data;
    return -1;
}

static void yaml_set_type_mismatch_err(yunpack_env_t * nonnull env,
                                       const yaml_data_t * nonnull data,
                                       const iop_field_t * nonnull fdesc)
{
    sb_setf(&env->err.buf, "cannot set %s in a field of type %s",
            yaml_data_get_type(data),
            iop_type_get_string_desc(fdesc->type));
    env->err.data = data;
}

/* }}} */
/* {{{ Yaml seq to iop field */

static int
yaml_seq_to_iop_field(yunpack_env_t * nonnull env,
                      const yaml_data_t * nonnull data,
                      const iop_struct_t * nonnull st_desc,
                      const iop_field_t * nonnull fdesc, void * nonnull out)
{
    lstr_t *arr = out;
    int size = 0;

    if (fdesc->repeat != IOP_R_REPEATED) {
        sb_sets(&env->err.buf, "cannot set a sequence in a non-array field");
        env->err.data = data;
        return -1;
    }

    p_clear(arr, 1);
    assert (data->type == YAML_DATA_SEQ);
    for (uint32_t i = 0; i < data->seq_len; i++) {
        void *elem_out;

        if (arr->len >= size) {
            size = p_alloc_nr(size);
            arr->data = mp_irealloc(env->mp, arr->data,
                                    arr->len * fdesc->size,
                                    size * fdesc->size, 8, 0);
        }
        elem_out = (void *)(((char *)arr->data) + arr->len * fdesc->size);
        RETHROW(yaml_data_to_iop_field(env, &data->seq[i], st_desc, fdesc,
                                       elem_out));
        arr->len++;
    }

    return 0;
}

/* }}} */

static int
yaml_data_to_iop_field(yunpack_env_t *env, const yaml_data_t * nonnull data,
                       const iop_struct_t * nonnull st_desc,
                       const iop_field_t * nonnull fdesc,
                       void * nonnull out)
{
    if (fdesc->repeat == IOP_R_OPTIONAL && !iop_field_is_class(fdesc)) {
        out = iop_field_set_present(env->mp, fdesc, out);
    }

    if (fdesc->type == IOP_T_STRUCT || fdesc->type == IOP_T_UNION) {
        if (iop_field_is_reference(fdesc)) {
           /* reference fields must be dereferenced */
            out = iop_field_ptr_alloc(env->mp, fdesc, out);
        }
        if (yaml_data_to_typed_struct(env, data, fdesc->u1.st_desc, out) < 0)
        {
            goto err;
        }
        return 0;
    }

    switch (data->type) {
      case YAML_DATA_SCALAR:
        switch (yaml_scalar_to_iop_field(env, data, fdesc, out)) {
          case YUNPACK_OK:
            break;
          case YUNPACK_INVALID_B64_VAL:
            sb_setf(&env->err.buf, "the value must be encoded in base64");
            env->err.data = data;
            goto err;
          case YUNPACK_INVALID_ENUM_VAL:
            sb_setf(&env->err.buf,
                    "the value is not valid for the enum `%pL`",
                    &fdesc->u1.en_desc->name);
            env->err.data = data;
            goto err;
          case YUNPACK_TYPE_MISMATCH:
            yaml_set_type_mismatch_err(env, data, fdesc);
            goto err;
          case YUNPACK_OOB:
            sb_setf(&env->err.buf,
                    "the value is out of range for the field of type %s",
                    iop_type_get_string_desc(fdesc->type));
            env->err.data = data;
            goto err;
          default:
            assert (false);
            return -1;
        }
        break;

      case YAML_DATA_OBJ:
        /* should have been covered by test on IOP_T_STRUCT earlier */
        yaml_set_type_mismatch_err(env, data, fdesc);
        goto err;

      case YAML_DATA_SEQ:
        if (yaml_seq_to_iop_field(env, data, st_desc, fdesc, out) < 0) {
            goto err;
        }
        break;

      default:
        assert (false);
        return -1;
    }

    logger_trace(&_G.unpack_logger, 2,
                 "unpack %s from "YAML_POS_FMT" up to "YAML_POS_FMT
                 " into field %pL of struct %pL",
                 yaml_data_get_type(data), YAML_POS_ARG(data->pos_start),
                 YAML_POS_ARG(data->pos_end), &fdesc->name,
                 &st_desc->fullname);
    return 0;

  err:
    sb_prependf(&env->err.buf, "cannot set field `%pL`: ", &fdesc->name);
    return -1;
}

static void yaml_env_init_from_ps(yaml_env_t *env, pstream_t ps)
{
    env->ps = ps;
    env->line_number = 1;
    /* -1 so that the computation of the column number works for the first
     * line */
    env->pos_newline = ps.s - 1;
}

static void yunpack_err_pretty_print(const yunpack_error_t *err,
                                     const iop_struct_t * nonnull st,
                                     sb_t *out)
{
    /* TODO: do a pretty print of the actual YAML data, for example:
     *
     * <filename>:<line_nb>:<col_nb>
     *     c: string
     *        ^^^^^^
     * cannot set field c: cannot set a string value in a field of type int
     */
    sb_setf(out, YAML_POS_FMT": cannot unpack YAML as object of type "
            "`%pL`: %pL", YAML_POS_ARG(err->data->pos_start), &st->fullname,
            &err->buf);
}

int t_iop_yunpack_ps(pstream_t * nonnull ps, const iop_struct_t * nonnull st,
                     void * nonnull out, sb_t * nonnull out_err)
{
    t_SB_1k(err);
    yaml_env_t parse_env;
    yunpack_env_t unpack_env;
    yaml_data_t data;

    p_clear(&parse_env, 1);
    yaml_env_init_from_ps(&parse_env, *ps);
    parse_env.mp = t_pool();
    parse_env.err = err;

    if (yaml_env_parse_data(&parse_env, 0, &data) < 0) {
        sb_setsb(out_err, &parse_env.err);
        return -1;
    }

    p_clear(&unpack_env, 1);
    unpack_env.mp = t_pool();
    unpack_env.err.buf = err;
    /* The YAML packer is made for public interfaces. Use flags that makes
     * sense in this context. In the future, they might be overridden if
     * some internal use-cases are found. */
    unpack_env.flags = IOP_UNPACK_FORBID_PRIVATE;
    if (yaml_data_to_typed_struct(&unpack_env, &data, st, out) < 0) {
        yunpack_err_pretty_print(&unpack_env.err, st, out_err);
        return -1;
    }

    return 0;
}

int
t_iop_yunpack_ptr_ps(pstream_t * nonnull ps, const iop_struct_t * nonnull st,
                     void * nullable * nonnull out, sb_t * nonnull out_err)
{
    *out = mp_irealloc(t_pool(), *out, 0, st->size, 8, MEM_RAW);
    return t_iop_yunpack_ps(ps, st, *out, out_err);
}

/* }}} */
/* {{{ ypack */

#define YAML_STD_INDENT  2

/* FIXME: need massive factorisation with iop-json.blk */

typedef struct iop_ypack_env_t {
    iop_jpack_writecb_f *write_cb;
    void *priv;
    unsigned flags;
} iop_ypack_env_t;

static int do_write(const iop_ypack_env_t *env, const void *_buf, int len)
{
    const uint8_t *buf = _buf;
    int pos = 0;

    while (pos < len) {
        int res = (*env->write_cb)(env->priv, buf + pos, len - pos);

        if (res < 0) {
            if (ERR_RW_RETRIABLE(errno))
                continue;
            return -1;
        }
        pos += res;
    }
    return len;
}

static int do_indent(const iop_ypack_env_t *env, int indent)
{
    static lstr_t spaces = LSTR_IMMED("                                    ");
    int todo = indent;

    while (todo > 0) {
        int res = (*env->write_cb)(env->priv, spaces.s,
                                   MIN(spaces.len, todo));

        if (res < 0) {
            if (ERR_RW_RETRIABLE(errno)) {
                continue;
            }
            return -1;
        }
        todo -= res;
    }

    return indent;
}

#define WRITE(data, len)                                                     \
    do {                                                                     \
        res += RETHROW(do_write(env, data, len));                            \
    } while (0)
#define PUTS(s)  WRITE(s, strlen(s))
#define PUTLSTR(s)  WRITE(s.data, s.len)

#define INDENT(lvl)                                                          \
    do {                                                                     \
        res += RETHROW(do_indent(env, lvl));                                 \
    } while (0)

#define PUTU(u)                                                              \
    do {                                                                     \
        uint64_t _u = (u);                                                   \
                                                                             \
        WRITE(ibuf, sprintf(ibuf, "%ju", _u));                               \
    } while (0)
#define PUTD(i)                                                              \
    do {                                                                     \
        int64_t _i = (i);                                                    \
                                                                             \
        WRITE(ibuf, sprintf(ibuf, "%jd", _i));                               \
    } while (0)

/* ints:   sign, 20 digits, and NUL -> 22
 * double: sign, digit, dot, 17 digits, e, sign, up to 3 digits NUL -> 25
 */
#define IBUF_LEN  25

static bool yaml_string_must_be_quoted(const lstr_t s)
{
    /* '!', '&', '*', '-', '"' and '.'. Technically, '-' is only forbidden
     * if followed by a space, but it is simpler that way. */
    static ctype_desc_t const yaml_invalid_raw_string_start = { {
        0x00000000, 0x00006446, 0x00000000, 0x00000000,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
    } };
    /* printable ascii characters minus ':' and '#'. Also should be
     * followed by space to be forbidden, but simpler that way. */
    static ctype_desc_t const yaml_raw_string_contains = { {
        0x00000000, 0xfbfffff7, 0xffffffff, 0xffffffff,
        0x00000000, 0x00000000, 0x00000000, 0x00000000,
    } };

    if (s.len == 0) {
        return true;
    }

    /* cannot start with those characters */
    if (ctype_desc_contains(&yaml_invalid_raw_string_start, s.s[0])) {
        return true;
    }
    /* cannot contain those characters */
    if (!lstr_match_ctype(s, &yaml_raw_string_contains)) {
        return true;
    }
    if (lstr_equal(s, LSTR("~")) || lstr_equal(s, LSTR("null"))) {
        return true;
    }

    return false;
}

static int write_string(lstr_t val, iop_type_t type,
                        const iop_ypack_env_t *env)
{
    SB_8k(sb);
    int res = 0;

    if (type == IOP_T_DATA) {
        if (val.len) {
            sb_reset(&sb);
            sb_addlstr_b64(&sb, val, -1);
            WRITE(sb.data, sb.len);
            return res;
        }
    }

    if (yaml_string_must_be_quoted(val)) {
        pstream_t ps = ps_initlstr(&val);

        PUTS("\"");
        while (!ps_done(&ps)) {
            /* r:32-127 -s:'\\"' */
            static ctype_desc_t const safe_chars = { {
                0x00000000, 0xfffffffb, 0xefffffff, 0xffffffff,
                    0x00000000, 0x00000000, 0x00000000, 0x00000000,
            } };
            const uint8_t *p = ps.b;
            size_t nbchars;
            int c;

            nbchars = ps_skip_span(&ps, &safe_chars);
            WRITE(p, nbchars);

            if (ps_done(&ps)) {
                break;
            }

            /* Assume broken utf-8 is mixed latin1 */
            c = ps_getuc(&ps);
            if (unlikely(c < 0)) {
                c = ps_getc(&ps);
            }
            switch (c) {
              case '"':  PUTS("\\\""); break;
              case '\\': PUTS("\\\\"); break;
              case '\a': PUTS("\\a"); break;
              case '\b': PUTS("\\b"); break;
              case '\e': PUTS("\\e"); break;
              case '\f': PUTS("\\f"); break;
              case '\n': PUTS("\\n"); break;
              case '\r': PUTS("\\r"); break;
              case '\t': PUTS("\\t"); break;
              case '\v': PUTS("\\v"); break;
              default: {
                char ibuf[IBUF_LEN];

                WRITE(ibuf, sprintf(ibuf, "\\u%04x", c));
              } break;
            }
        }
        PUTS("\"");
    } else {
        PUTLSTR(val);
    }

    return res;
}

static int
iop_ypack_typed_struct(const iop_struct_t *desc, const void *value,
                       const iop_ypack_env_t *env, unsigned indent,
                       bool to_indent);

/* We expect the caller to have left us in a situation where we are already
 * indented by "indent" spaces.
 */
static int
iop_ypack_raw_struct(const iop_struct_t *desc, const void *value,
                     const iop_ypack_env_t *env, unsigned indent,
                     bool to_indent)
{
    const iop_field_t *fstart;
    const iop_field_t *fend;
    char ibuf[IBUF_LEN];
    int res = 0;
    bool first = !to_indent;

    if (desc->is_union) {
        fstart = get_union_field(desc, value);
        fend = fstart + 1;
    } else {
        fstart = desc->fields;
        fend = desc->fields + desc->fields_len;
    }

    for (const iop_field_t *fdesc = fstart; fdesc < fend; fdesc++) {
        bool repeated = fdesc->repeat == IOP_R_REPEATED;
        const void *ptr;
        int n;
        bool is_skipped = false;

        ptr = iop_json_get_n_and_ptr(desc, env->flags, fdesc, value, &n,
                                     &is_skipped);
        if (is_skipped) {
            continue;
        }

        if (first) {
            first = false;
        } else {
            PUTS("\n");
            INDENT(indent);
        }

        PUTLSTR(fdesc->name);
        PUTS(":");
        if (n == 0) {
            PUTS(" ~");
            continue;
        }

        for (int j = 0; j < n; j++) {
            unsigned field_indent = indent;

            if (repeated) {
                PUTS("\n");
                field_indent += YAML_STD_INDENT;
                INDENT(field_indent);
                PUTS("-");
            }

            switch (fdesc->type) {
                const void *v;

#define CASE(n) \
              case IOP_T_I##n:                                               \
                PUTS(" ");                                                   \
                PUTD(IOP_FIELD(int##n##_t, ptr, j));                         \
                break;                                                       \
              case IOP_T_U##n:                                               \
                PUTS(" ");                                                   \
                PUTD(IOP_FIELD(uint##n##_t, ptr, j));                        \
                break;
              CASE(8); CASE(16); CASE(32); CASE(64);
#undef CASE

              case IOP_T_ENUM:
                v = iop_enum_to_str_desc(fdesc->u1.en_desc,
                                         IOP_FIELD(int, ptr, j)).s;
                PUTS(" ");
                if (likely(v)) {
                    PUTS(v);
                } else {
                    /* if not found, dump the integer */
                    PUTU(IOP_FIELD(int, ptr, j));
                }
                break;

              case IOP_T_BOOL:
                if (IOP_FIELD(bool, ptr, j)) {
                    PUTS(" true");
                } else {
                    PUTS(" false");
                }
                break;

              case IOP_T_DOUBLE: {
                double d = IOP_FIELD(double, ptr, j);
                int inf = isinf(d);

                PUTS(" ");
                if (inf == 1) {
                    PUTS(".Inf");
                } else
                if (inf == -1) {
                    PUTS("-.Inf");
                } else
                if (isnan(d)) {
                    PUTS(".NaN");
                } else {
                    WRITE(ibuf, sprintf(ibuf, "%g", d));
                }
              } break;

              case IOP_T_UNION:
              case IOP_T_STRUCT: {
                v = iop_json_get_struct_field_value(fdesc, ptr, j);
                /* Write the field inline. */
                if (repeated) {
                    PUTS(" ");
                    field_indent += 2;
                } else {
                    field_indent += YAML_STD_INDENT;
                }
                res += RETHROW(iop_ypack_typed_struct(fdesc->u1.st_desc, v,
                                                      env, field_indent,
                                                      true));
              } break;

              case IOP_T_STRING:
              case IOP_T_XML:
              case IOP_T_DATA: {
                const lstr_t *sv = &IOP_FIELD(const lstr_t, ptr, j);

                /* Write the field inline. */
                PUTS(" ");
                res += RETHROW(write_string(*sv, fdesc->type, env));
              } break;

              case IOP_T_VOID:
                PUTS(" ~");
                break;

              default:
                abort();
            }
        }
    }

    return res;
}

static int
iop_ypack_typed_struct(const iop_struct_t *desc, const void *value,
                       const iop_ypack_env_t *env, unsigned indent,
                       bool to_indent)
{
    int res = 0;
    int type_header_len = 0;

    if (iop_struct_is_class(desc)) {
        qv_t(iop_struct) parents;
        const iop_struct_t *real_desc = *(const iop_struct_t **)value;

        e_assert(panic, !real_desc->class_attrs->is_abstract,
                 "packing of abstract class '%*pM' is forbidden",
                 LSTR_FMT_ARG(real_desc->fullname));

        /* If this assert fails, you are exporting private classes through
         * a public interface... this is BAD!
         */
        assert (!real_desc->class_attrs->is_private);

        /* Write type of class */
        if (desc != real_desc
        ||  !(env->flags & IOP_JPACK_SKIP_OPTIONAL_CLASS_NAMES))
        {
            if (to_indent) {
                PUTS(" !");
            } else {
                PUTS("!");
            }
            PUTLSTR(real_desc->fullname);
            to_indent = true;
            type_header_len = res;
        }

        /* We want to write the fields in the order "master -> children", and
         * not "children -> master", so first build a qvector of the parents.
         */
        qv_inita(&parents, 8);
        do {
            qv_append(&parents, real_desc);
            real_desc = real_desc->class_attrs->parent;
        } while (real_desc);

        /* Write fields of different levels */
        for (int pos = parents.len; pos-- > 0; ) {
            bool first_field = pos == parents.len - 1;

            res += RETHROW(iop_ypack_raw_struct(parents.tab[pos], value, env,
                                                indent,
                                                to_indent || !first_field));
        }
        qv_wipe(&parents);

    } else {
        res += RETHROW(iop_ypack_raw_struct(desc, value, env, indent,
                                            to_indent));
    }

    if (res == type_header_len) {
        if (to_indent) {
            PUTS(" ~");
        } else {
            PUTS("~");
        }
    }

    return res;
}

#undef WRITE
#undef PUTS
#undef INDENT
#undef PUTU
#undef PUTI

int iop_ypack(const iop_struct_t *desc, const void *value,
              iop_jpack_writecb_f *writecb, void *priv, unsigned flags)
{
    const iop_ypack_env_t env = {
        .write_cb = writecb,
        .priv = priv,
        .flags = flags,
    };

    return iop_ypack_typed_struct(desc, value, &env, 0, false);
}

/* }}} */
/* {{{ Module */

static int iop_yaml_initialize(void *arg)
{
    return 0;
}

static int iop_yaml_shutdown(void)
{
    return 0;
}

MODULE_BEGIN(iop_yaml)
    /* There is an implicit dependency on "log" */
MODULE_END()

/* }}} */
/* {{{ Tests */

/* LCOV_EXCL_START */

#include "z.h"

/* {{{ Helpers */

static int z_yaml_test_parse_fail(const char *yaml, const char *expected_err)
{
    t_scope;
    SB_1k(err);
    yaml_env_t env;
    yaml_data_t data;

    p_clear(&env, 1);
    yaml_env_init_from_ps(&env, ps_initstr(yaml));
    env.mp = t_pool();
    env.err = err;

    Z_ASSERT_NEG(yaml_env_parse_data(&env, 0, &data));
    Z_ASSERT_STREQUAL(env.err.data, expected_err,
                      "wrong error message on yaml string `%s`", yaml);

    Z_HELPER_END;
}

/* out parameter first to let the yaml string be last, which makes it
 * much easier to write multiple lines without horrible indentation */
static int z_t_yaml_test_parse_success(yaml_data_t *data, const char *yaml)
{
    SB_1k(err);
    yaml_env_t env;

    p_clear(&env, 1);
    yaml_env_init_from_ps(&env, ps_initstr(yaml));
    env.mp = t_pool();
    env.err = err;

    p_clear(data, 1);
    Z_ASSERT_N(yaml_env_parse_data(&env, 0, data),
               "yaml parsing failed: %pL", &env.err);

    Z_HELPER_END;
}

static int
z_check_yaml_data(const yaml_data_t *data, yaml_data_type_t type,
                  uint32_t start_line, uint32_t start_col,
                  uint32_t end_line, uint32_t end_col)
{
    Z_ASSERT_EQ(data->type, type);
    Z_ASSERT_EQ(data->pos_start.line_nb, start_line);
    Z_ASSERT_EQ(data->pos_start.col_nb, start_col);
    Z_ASSERT_EQ(data->pos_end.line_nb, end_line);
    Z_ASSERT_EQ(data->pos_end.col_nb, end_col);

    Z_HELPER_END;
}

static int
z_check_yaml_scalar(const yaml_data_t *data, yaml_scalar_type_t type,
                    uint32_t start_line, uint32_t start_col,
                    uint32_t end_line, uint32_t end_col)
{
    Z_HELPER_RUN(z_check_yaml_data(data, YAML_DATA_SCALAR, start_line,
                                   start_col, end_line, end_col));
    Z_ASSERT_EQ(data->scalar.type, type);

    Z_HELPER_END;
}

/* }}} */

/* Here are unit-tests about YAML->AST parsing.
 * The IOP packing/unpacking are in zchk-iop.c */

Z_GROUP_EXPORT(yaml)
{
    MODULE_REQUIRE(iop_yaml);

    /* {{{ Parsing errors */

    Z_TEST(parsing_errors, "errors when parsing yaml") {
        /* unexpected EOF */
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "",
            "1:1: missing data, unexpected end of line"
        ));
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "  # my comment",
            "1:15: missing data, unexpected end of line"
        ));
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "key:",
            "1:5: missing data, unexpected end of line"
        ));

        /* wrong object continuation */
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "a: 5\nb",
            "2:2: invalid key, missing colon"
        ));
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "a: 5\n_:",
            "2:1: invalid key, only alpha-numeric characters allowed"
        ));

        /* wrong explicit string */
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "\" unfinished string",
            "1:2: expected string, missing closing '\"'"
        ));

        /* wrong escaped code */
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "\"\\",
            "1:2: expected string, invalid backslash"
        ));

        /* wrong tag */
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "!-",
            "1:2: wrong type of data, expected a string after '!'"
        ));
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "!\"my type\"\n"
            "a: 5",
            "1:2: wrong type of data, expected a string after '!'"
        ));
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "!tag\n"
            "3",
            "2:2: wrong type of data, can only use a tag on an object"
        ));
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "!tag1\n"
            "!tag2\n"
            "a: 2",
            "3:5: wrong object, two tags have been declared"
        ));

        /* wrong list continuation */
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "- 2\n"
            "-3",
            "2:1: wrong type of data, expected another element of sequence"
        ));

        /* wrong indent */
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "a: 2\n"
            " b: 3",
            "2:2: wrong indentation, line not aligned with current object"
        ));
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "- 2\n"
            " - 3",
            "2:2: wrong indentation, line not aligned with current sequence"
        ));
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "a: 1\n"
            "b:\n"
            "c: 3",
            "3:1: wrong indentation, missing element"
        ));

        /* wrong object */
        Z_HELPER_RUN(z_yaml_test_parse_fail(
            "a: 1\n"
            "a: 2",
            "2:3: invalid key, key is already declared in the object"
        ));
    } Z_TEST_END;

    /* }}} */
    /* {{{ Parsing scalars */

    Z_TEST(parsing_scalar, "test parsing of scalars") {
        t_scope;
        yaml_data_t data;

        /* string */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "unquoted string"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_STRING,
                                         1, 1, 1, 16));
        Z_ASSERT_LSTREQUAL(data.scalar.s, LSTR("unquoted string"));

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "\" quoted: 5 \""));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_STRING,
                                         1, 1, 1, 14));
        Z_ASSERT_LSTREQUAL(data.scalar.s, LSTR(" quoted: 5 "));

        /* null */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "~"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_NULL,
                                         1, 1, 1, 2));

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "null"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_NULL,
                                         1, 1, 1, 5));

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "NulL"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_NULL,
                                         1, 1, 1, 5));

        /* bool */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "true"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_BOOL,
                                         1, 1, 1, 5));
        Z_ASSERT(data.scalar.b);

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "TrUE"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_BOOL,
                                         1, 1, 1, 5));
        Z_ASSERT(data.scalar.b);

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "false"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_BOOL,
                                         1, 1, 1, 6));
        Z_ASSERT(!data.scalar.b);

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "FALse"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_BOOL,
                                         1, 1, 1, 6));
        Z_ASSERT(!data.scalar.b);

        /* uint */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "0"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_UINT,
                                         1, 1, 1, 2));
        Z_ASSERT_EQ(data.scalar.u, 0UL);

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "153"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_UINT,
                                         1, 1, 1, 4));
        Z_ASSERT_EQ(data.scalar.u, 153UL);

        /* int */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "-0"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_INT,
                                         1, 1, 1, 3));
        Z_ASSERT_EQ(data.scalar.i, 0L);

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "-153"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_INT,
                                         1, 1, 1, 5));
        Z_ASSERT_EQ(data.scalar.i, -153L);

        /* double */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "0.5"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_DOUBLE,
                                         1, 1, 1, 4));
        Z_ASSERT_EQ(data.scalar.d, 0.5);

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "-1e3"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_DOUBLE,
                                         1, 1, 1, 5));
        Z_ASSERT_EQ(data.scalar.d, -1000.0);

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, "-.Inf"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_DOUBLE,
                                         1, 1, 1, 6));
        Z_ASSERT_EQ(isinf(data.scalar.d), -1);

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, ".INf"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_DOUBLE,
                                         1, 1, 1, 5));
        Z_ASSERT_EQ(isinf(data.scalar.d), 1);

        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data, ".NAN"));
        Z_HELPER_RUN(z_check_yaml_scalar(&data, YAML_SCALAR_DOUBLE,
                                         1, 1, 1, 5));
        Z_ASSERT(isnan(data.scalar.d));
    } Z_TEST_END;

    /* }}} */
    /* {{{ Parsing objects */

    Z_TEST(parsing_obj, "test parsing of objects") {
        t_scope;
        yaml_data_t data;
        yaml_data_t field;
        yaml_data_t field2;
        lstr_t key;

        /* one liner */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data,
            "a: 2"
        ));
        Z_HELPER_RUN(z_check_yaml_data(&data, YAML_DATA_OBJ, 1, 1, 1, 5));
        Z_ASSERT_NULL(data.obj->tag.s);
        Z_ASSERT(qm_len(yaml_data, &data.obj->fields) == 1);
        key = LSTR("a");
        field = qm_get(yaml_data, &data.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_scalar(&field, YAML_SCALAR_UINT,
                                         1, 4, 1, 5));
        Z_ASSERT_EQ(field.scalar.u, 2UL);

        /* with tag */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data,
            "!tag1 a: 2"
        ));
        Z_HELPER_RUN(z_check_yaml_data(&data, YAML_DATA_OBJ, 1, 1, 1, 11));
        Z_ASSERT_LSTREQUAL(data.obj->tag, LSTR("tag1"));
        Z_ASSERT(qm_len(yaml_data, &data.obj->fields) == 1);
        key = LSTR("a");
        field = qm_get(yaml_data, &data.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_scalar(&field, YAML_SCALAR_UINT,
                                         1, 10, 1, 11));
        Z_ASSERT_EQ(field.scalar.u, 2UL);

        /* imbricated objects */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data,
            "a: 2\n"
            "inner: b: 3\n"
            "       c: -4\n"
            "inner2: !tag\n"
            "  d: ~\n"
            "  e: my-label\n"
            "f: 1.2"
        ));
        Z_HELPER_RUN(z_check_yaml_data(&data, YAML_DATA_OBJ, 1, 1, 7, 7));
        Z_ASSERT_NULL(data.obj->tag.s);
        Z_ASSERT(qm_len(yaml_data, &data.obj->fields) == 4);

        /* a */
        key = LSTR("a");
        field = qm_get(yaml_data, &data.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_scalar(&field, YAML_SCALAR_UINT,
                                         1, 4, 1, 5));
        Z_ASSERT_EQ(field.scalar.u, 2UL);

        /* inner */
        key = LSTR("inner");
        field = qm_get(yaml_data, &data.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_data(&field, YAML_DATA_OBJ, 2, 8, 3, 13));
        Z_ASSERT_NULL(field.obj->tag.s);
        Z_ASSERT(qm_len(yaml_data, &field.obj->fields) == 2);

        key = LSTR("b");
        field2 = qm_get(yaml_data, &field.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_scalar(&field2, YAML_SCALAR_UINT,
                                         2, 11, 2, 12));
        Z_ASSERT_EQ(field2.scalar.u, 3UL);
        key = LSTR("c");
        field2 = qm_get(yaml_data, &field.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_scalar(&field2, YAML_SCALAR_INT,
                                         3, 11, 3, 13));
        Z_ASSERT_EQ(field2.scalar.i, -4L);

        /* inner2 */
        key = LSTR("inner2");
        field = qm_get(yaml_data, &data.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_data(&field, YAML_DATA_OBJ, 4, 9, 6, 14));
        Z_ASSERT_LSTREQUAL(field.obj->tag, LSTR("tag"));
        Z_ASSERT(qm_len(yaml_data, &field.obj->fields) == 2);

        key = LSTR("d");
        field2 = qm_get(yaml_data, &field.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_scalar(&field2, YAML_SCALAR_NULL,
                                         5, 6, 5, 7));
        key = LSTR("e");
        field2 = qm_get(yaml_data, &field.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_scalar(&field2, YAML_SCALAR_STRING,
                                         6, 6, 6, 14));
        Z_ASSERT_LSTREQUAL(field2.scalar.s, LSTR("my-label"));

        /* f */
        key = LSTR("f");
        field = qm_get(yaml_data, &data.obj->fields, &key);
        Z_HELPER_RUN(z_check_yaml_scalar(&field, YAML_SCALAR_DOUBLE,
                                         7, 4, 7, 7));
        Z_ASSERT_EQ(field.scalar.d, 1.2);
    } Z_TEST_END;

    /* }}} */
    /* {{{ Parsing sequences */

    Z_TEST(parsing_seq, "test parsing of sequences") {
        t_scope;
        yaml_data_t data;
        yaml_data_t elem;

        /* one liner */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data,
            "- a"
        ));
        Z_HELPER_RUN(z_check_yaml_data(&data, YAML_DATA_SEQ, 1, 1, 1, 4));
        Z_ASSERT_EQ(data.seq_len, 1U);
        Z_HELPER_RUN(z_check_yaml_scalar(&data.seq[0], YAML_SCALAR_STRING,
                                         1, 3, 1, 4));
        Z_ASSERT_LSTREQUAL(data.seq[0].scalar.s, LSTR("a"));

        /* imbricated sequences */
        Z_HELPER_RUN(z_t_yaml_test_parse_success(&data,
            "- \"a: 2\"\n"
            "- - 5\n"
            "  - -5\n"
            "- ~\n"
            "-\n"
            "  - TRUE\n"
            "- FALSE\n"
        ));

        Z_HELPER_RUN(z_check_yaml_data(&data, YAML_DATA_SEQ, 1, 1, 7, 8));
        Z_ASSERT_EQ(data.seq_len, 5U);

        /* "a: 2" */
        elem = data.seq[0];
        Z_HELPER_RUN(z_check_yaml_scalar(&elem, YAML_SCALAR_STRING,
                                         1, 3, 1, 9));
        Z_ASSERT_LSTREQUAL(elem.scalar.s, LSTR("a: 2"));

        /* subseq */
        elem = data.seq[1];
        Z_HELPER_RUN(z_check_yaml_data(&elem, YAML_DATA_SEQ, 2, 3, 3, 7));
        Z_ASSERT_EQ(elem.seq_len, 2U);
        Z_HELPER_RUN(z_check_yaml_scalar(&elem.seq[0], YAML_SCALAR_UINT,
                                         2, 5, 2, 6));
        Z_ASSERT_EQ(elem.seq[0].scalar.u, 5UL);
        Z_HELPER_RUN(z_check_yaml_scalar(&elem.seq[1], YAML_SCALAR_INT,
                                         3, 5, 3, 7));
        Z_ASSERT_EQ(elem.seq[1].scalar.i, -5L);

        /* null */
        elem = data.seq[2];
        Z_HELPER_RUN(z_check_yaml_scalar(&elem, YAML_SCALAR_NULL,
                                         4, 3, 4, 4));

        /* subseq */
        elem = data.seq[3];
        Z_HELPER_RUN(z_check_yaml_data(&elem, YAML_DATA_SEQ, 6, 3, 6, 9));
        Z_ASSERT_EQ(elem.seq_len, 1U);
        Z_HELPER_RUN(z_check_yaml_scalar(&elem.seq[0], YAML_SCALAR_BOOL,
                                         6, 5, 6, 9));
        Z_ASSERT(elem.seq[0].scalar.b);

        /* false */
        elem = data.seq[4];
        Z_HELPER_RUN(z_check_yaml_scalar(&elem, YAML_SCALAR_BOOL,
                                         7, 3, 7, 8));
        Z_ASSERT(!elem.scalar.b);
    } Z_TEST_END;

    /* }}} */

    MODULE_RELEASE(iop_yaml);
} Z_GROUP_END

/* LCOV_EXCL_STOP */

/* }}} */
