/***************************************************************************/
/*                                                                         */
/* Copyright 2022 INTERSEC SA                                              */
/*                                                                         */
/* Licensed under the Apache License, Version 2.0 (the "License");         */
/* you may not use this file except in compliance with the License.        */
/* You may obtain a copy of the License at                                 */
/*                                                                         */
/*     http://www.apache.org/licenses/LICENSE-2.0                          */
/*                                                                         */
/* Unless required by applicable law or agreed to in writing, software     */
/* distributed under the License is distributed on an "AS IS" BASIS,       */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.*/
/* See the License for the specific language governing permissions and     */
/* limitations under the License.                                          */
/*                                                                         */
/***************************************************************************/

#include <math.h>
#include <lib-common/qps.h>
#include <lib-common/qps-bitmap.h>
#include <lib-common/qps-hat.h>
#include <lib-common/parseopt.h>

/* {{{ qpsstress definitions (enum, structure, ...) */
/* {{{ qpsstress steps and object types */

typedef enum qpsstress_step_t {
    QPS_ALLOC,
    QPS_REALLOC,
    QPS_DEALLOC,
    QPS_WDEREF,
    QPS_SNAPSHOT,
    QPS_SNAPSHOT_WAIT,
    QPS_REOPEN,

    QPS_OBJ_CREATE,
    QPS_OBJ_SET,
    QPS_OBJ_MULTIPLE_SET,
    QPS_OBJ_GET,
    QPS_OBJ_MULTIPLE_GET,
    QPS_OBJ_RM_ENTRY,
    QPS_OBJ_MULTIPLE_RM_ENTRY,
    QPS_OBJ_CLEAR,
    QPS_OBJ_DELETE,

    QPS_HAT_RESET_ENUMERATOR,
    QPS_HAT_MV_ENUMERATOR,
    QPS_HAT_MV_ENUMERATOR_TO,
    QPS_HAT_CHECK_ENUMERATOR,
    QPS_HAT_SET_ENUMERATOR,
    QPS_HAT_COMPUTE_COUNTS,
    QPS_HAT_COMPUTE_MEMORY,
    QPS_HAT_FIX_STORED0,

    QPS_BITMAP_COMPUTE_STATS,

    QPS_MAX_CASES
} qpsstress_step_t;

typedef enum qps_obj_type_t {
    QPS_GENERIC_TYPE,
    QPS_QHAT,
    QPS_QBITMAP,
    QPS_MAX_TYPES_OBJECTS
} qps_obj_type_t;

/* }}} */
/* {{{ qpsstress instructions linked with steps */

typedef struct {
    uint8_t val_len;
    bool is_nullable;
} qpsstress_obj_create_t;

typedef struct {
    uint32_t key;
    uint32_t nbr_iter;
    uint32_t gap_keys;
} qpsstress_obj_mul_op_t;

typedef struct {
    uint16_t count;
    bool safe;
} qpsstress_obj_mv_en_t;

typedef struct {
    bool en_path;
    bool safe;
} qpsstress_obj_check_en_t;

typedef struct {
    int pos;
    qps_obj_type_t type;
    union {
        qpsstress_obj_create_t create;
        qpsstress_obj_mul_op_t mul_op;
        qpsstress_obj_mv_en_t move;
        qpsstress_obj_check_en_t check;
        uint32_t key;
        bool do_stats;
        bool compute_memory_overhead;
    };
} qpsstress_obj_instr_t;

typedef struct {
    qps_handle_t h;
    union {
        size_t expected_sz;
        qpsstress_obj_instr_t obj_instr;
    };
} qpsstress_instr_t;

typedef struct {
    qpsstress_step_t step;
    qpsstress_instr_t instr;
} qpsstress_replay_t;

typedef union {
    struct {
        qhat_enumerator_t *hat_en;
        bool safe_en_needed;
    };
    void *extra_info;
} qps_obj_ctx_t;

typedef struct {
    union {
        void *obj_ptr;
        qhat_t *hat;
        qps_bitmap_t *qbitmap;
    };
    qps_obj_ctx_t ctx;
} qps_obj_t;

/* }}} */
/* {{{ Management of all objects in qpsstress */

typedef struct {
    qps_obj_type_t type;
    qps_handle_t h;
} qpsstress_obj_handle_t;

qvector_t(qps_handle_vec, qv_t(i32));
qvector_t(qps_obj_vec, qps_obj_t);

qvector_t(qps_obj_vec_type, qv_t(qps_obj_vec));
qvector_t(qps_index_vec_type, qv_t(i32));

/* Description of steps which can be played in qpstress. */
typedef void (*qpsstress_step_f)(qpsstress_instr_t *instr);
typedef struct qpsstress_step_desc_t {
    const char * const name;
    const qpsstress_step_f run_step;
} qpsstress_step_desc_t;

/* }}} */

static const char *qpsstress_usage_g = "QPS_PATH [REPLAY_FILE]\n\n"
"Stress QPS in (QPS_PATH) folder and abort on the first issue. If a replay "
"file\nis provided, play it before performing QPS operations randomly. This "
"tool is\nnot supposed to be used outside Intersec R&D.\n\n"
"Options:\n"
"--------";

struct {
    const char *path;
    bool opt_help;
    bool opt_protect_en_access;
    bool opt_old_alloc_strategy;

    qps_t *qps;
    bool has_snapshotted;

    qv_t(qps_handle_vec) vec_type_h;       /* Vector of handles per type. */
    qv_t(qps_handle_vec) vec_type_snap_h;  /* Snapshoted handles per type. */

    qv_t(qps_obj_vec_type) vec_loaded_obj;/* Vector of loaded objects per
                                             type. */

    qv_t(qps_index_vec_type) free_list;     /* Per type, vector of indexes
                                             * which are currently free. */
    qv_t(qps_index_vec_type) snap_free_list;/* Like above, after snapshots. */

    struct {
        bool opt_end_app;
        lstr_t file_content;
        ctype_desc_t sep;
        pstream_t ps;
        qpsstress_replay_t last_step;
    } replay;
} _G;

const qpsstress_step_desc_t g_list_steps[QPS_MAX_CASES];

static popt_t qpsstress_popt_g[] = {
    OPT_FLAG('h', "help", &_G.opt_help, "show this help"),
    OPT_FLAG('o', "old-alloc", &_G.opt_old_alloc_strategy, "go back "
             "to the legacy allocation strategy for handles (less "
             "stimulation on QPS allocator)"),
    OPT_FLAG('e', "end-app-after-replay", &_G.replay.opt_end_app, "stop the "
             "application at the end of a replay (no random events "
             "afterwards)"),
    OPT_FLAG('s', "safe-en-after-insert-remove", &_G.opt_protect_en_access,
             "perform only safe accesses on enumerators until next or "
             "goto operation is triggered when keys are inserted/removed "
             "(avoid partial sync leading to segfaults or asserts)"),
    OPT_END(),
};

/* }}} */
/* {{{ QPS stress helpers related to logs */

#define log_step_may_fail e_debug
#define log_step_extra_info e_debug
#define log_before_step e_info
#define log_after_step e_info

/* }}} */
/* {{{ Check patterns and corruption in QPS */

#define CHECK_PATTERN_AND_HANDLE
#ifdef CHECK_PATTERN_AND_HANDLE

/** Define structure stored in QPS at the beginning of handle memory. */
typedef struct blk_data {
    uint32_t app_sz32;  /* Size of app_data field (i.e. after CRC field) */
    uint32_t crc;       /* CRC based on handle id value and app_sz32 field. */
    uint32_t app_data[];
} blk_data;

#define PATTERN_VAL_8(h) (h & 0xff)
#define PATTERN_VAL_32(h)                                                    \
    (PATTERN_VAL_8(h) << 24 | PATTERN_VAL_8(h) << 16 |                       \
     PATTERN_VAL_8(h) << 8 | PATTERN_VAL_8(h))

#define BLK_APP_DATA_SIZE_FROM_QPS_BLK_T32(blk_sz)                           \
    (((blk_sz) - offsetof(blk_data, app_data)) / sizeof(uint32_t))

#define BLK_APP_DATA_SIZE_T32(data)                                          \
    ((data)->app_sz32)
#define BLK_APP_DATA_SIZE_T8(data)                                           \
    (BLK_APP_DATA_SIZE_T32(data) * sizeof(uint32_t))
#define BLK_SIZE_T8(data)                                                    \
    (BLK_APP_DATA_SIZE_T8(data) + offsetof(blk_data, app_data))

/** FIXME: Should we really duplicate this function from qps.blk? */
/** Retrieve the associated QPS pointer from a "basic" pointer. */
static qps_ptr_t qps_encode(const void *ptr)
{
    return (qps_ptr_t){
        .pgno = qps_pg_of(ptr),
        .addr = cast(uintptr_t, ptr) & QPS_PAGE_MASK,
    };
}

static void print_h_info(qps_handle_t h)
{
    qps_ptr_t hptr = *qps_handle_slot(_G.qps, h);
    uint8_t *instr = qps_handle_deref(_G.qps, h);
    size_t sz = qps_sizeof(_G.qps, instr);
    qps_ptr_t hptr_hdr = qps_encode((void*)cast(uintptr_t, instr - 8));
    qps_ptr_t hptr_end = qps_encode((void*)cast(uintptr_t, instr + sz - 1));

    e_error("error processing handle %u (size: %zu)", h, sz);
    e_error("\thdr starting at " QPS_PTR_FMT " (%p)", QPS_PTR_ARG(hptr_hdr),
            instr - 8);
    e_error("\tdata starts at  " QPS_PTR_FMT " (%p)", QPS_PTR_ARG(hptr),
            instr);
    e_error("\tdata ends at    " QPS_PTR_FMT  " (%p)",
            QPS_PTR_ARG(hptr_end), instr + sz - 1);
}

static void
set_blk_data_hdr(blk_data *data_hdr, qps_handle_t h, size_t new_sz)
{
    data_hdr->app_sz32 = (new_sz - offsetof(blk_data, app_data)) /
                         sizeof(uint32_t) ;
    data_hdr->crc = icrc32(h, &data_hdr->app_sz32, offsetof(blk_data, crc));
}

static void check_handle_data(blk_data *instr, qps_handle_t h, size_t new_sz)
{
    const uint32_t pattern = PATTERN_VAL_32(h);
    uint32_t check_sz32;

    /* Detect any corruption of this CRC in handle memory now. */
    assert(icrc32(h, &instr->app_sz32, offsetof(blk_data, crc)) ==
           instr->crc);

    /* The following line catches the case where realloc has been performed in
     * tlsf map (with bigger size) but pattern is not yet fully copied. */
    check_sz32 = MIN(BLK_APP_DATA_SIZE_T32(instr),
                     BLK_APP_DATA_SIZE_FROM_QPS_BLK_T32(new_sz));

    /* Check pattern for current handle in QPS */
    for (uint32_t i = 0; i < check_sz32 / sizeof(uint32_t); i++) {
        if (instr->app_data[i] != pattern) {
            print_h_info(h);
            e_error("expected pattern byte is 0x%08x, found 0x%08x after "
                    "%zu byte(s) --> %p", pattern, instr->app_data[i],
                    offsetof(blk_data, app_data) + sizeof(uint32_t) * i,
                    &instr->app_data[i]);
            e_error("qps generation is %u, map generation is %u",
                    _G.qps->generation, qps_map_of(instr)->hdr.generation);
            assert(false);
        }
    }
}

static void set_handle_data(void *ptr, qps_handle_t h, size_t new_sz)
{
    blk_data *instr = ptr;

    assert(new_sz >= QPS_ALLOC_MIN && (new_sz % sizeof(uint32_t) == 0));
    set_blk_data_hdr(instr, h, new_sz);
    memset(instr->app_data, PATTERN_VAL_8(h), BLK_APP_DATA_SIZE_T8(instr));
}

static void check_blk_header(blk_data *instr, size_t sz)
{
    assert(((sz & 0x3) == 0) && ((cast(uintptr_t, instr) & 0x3) == 0));
}

static void check_blk_header_and_data(qps_handle_t h)
{
    blk_data *instr = qps_handle_deref(_G.qps, h);
    size_t sz = qps_sizeof(_G.qps, instr);

    check_blk_header(instr, sz);
    check_handle_data(instr, h, sz);
}

static void check_blk_then_set_handle_data(qps_handle_t h)
{
    blk_data *instr = qps_handle_deref(_G.qps, h);
    size_t sz = qps_sizeof(_G.qps, instr);

    check_blk_header(instr, sz);
    check_handle_data(instr, h, sz);
    if (BLK_SIZE_T8(instr) != sz) {
        /* Size allocated has been changed for handle, redo header and
         * pattern. */
        set_handle_data(instr, h, sz);
    }
}

#else /* ! CHECK_PATTERN_AND_HANDLE */

#define set_handle_data(...)                ((void)0)
#define check_blk_header_and_data(...)      ((void)0)
#define check_blk_then_set_handle_data(...) ((void)0)

#endif

static void check_qps(void)
{
    if (!_G.qps->handles_max) {
        return;
    }

    __qps_check_maps(_G.qps, true);
    if (_G.has_snapshotted) {
        assert (__qps_check_consistency(_G.path, "stress-consistency") >= 0);
        _G.has_snapshotted = false;
    }
}

/* }}} */
/* {{{ Helpers */

static void init_qpsstress_vectors(void)
{
    qv_init(&_G.vec_type_h);
    qv_init(&_G.vec_type_snap_h);
    qv_init(&_G.vec_loaded_obj);
    qv_init(&_G.free_list);
    qv_init(&_G.snap_free_list);

    qv_growlen0(&_G.vec_type_h, QPS_MAX_TYPES_OBJECTS);
    qv_growlen0(&_G.vec_type_snap_h, QPS_MAX_TYPES_OBJECTS);
    qv_growlen0(&_G.vec_loaded_obj, QPS_MAX_TYPES_OBJECTS);
    qv_growlen0(&_G.free_list, QPS_MAX_TYPES_OBJECTS);
    qv_growlen0(&_G.snap_free_list, QPS_MAX_TYPES_OBJECTS);
}

static void
dealloc_slot_for_qps_obj(qps_obj_type_t type, qps_obj_t *obj)
{
    p_delete(&obj->obj_ptr);
    p_delete(&obj->ctx.extra_info);
}

static void dealloc_qpsstress_objs(void)
{
    tab_for_each_pos(type, &_G.vec_loaded_obj) {
        tab_for_each_pos(pos, &_G.vec_loaded_obj.tab[type]) {
            qps_obj_t *slot_obj = &_G.vec_loaded_obj.tab[type].tab[pos];

            dealloc_slot_for_qps_obj(type, slot_obj);
        }
    }
}

static void destroy_qpsstress_vectors(void)
{
    qv_deep_wipe(&_G.vec_type_h, qv_wipe);
    qv_deep_wipe(&_G.vec_type_snap_h, qv_wipe);

    dealloc_qpsstress_objs();
    qv_deep_wipe(&_G.vec_loaded_obj, qv_wipe);

    qv_deep_wipe(&_G.free_list, qv_wipe);
    qv_deep_wipe(&_G.snap_free_list, qv_wipe);
}

static int max_of_qps_obj_reached(qps_obj_type_t type) {
    const int limit_objs_per_type = 5;
    qv_t(qps_obj_vec) *v = &_G.vec_loaded_obj.tab[type];
    qv_t(i32) *v_free = &_G.free_list.tab[type];

    /* Ensure there is a limit in QPS object creation, so we don't grow too
     * much in QPS. */
    return v->len < limit_objs_per_type || v_free->len ? 0 : -1;
}

static size_t request_memory_size(qpsstress_step_t step, size_t old_size)
{
    size_t sz = 0;

    if (!_G.opt_old_alloc_strategy) {
        /** This define allows a wider range of size for a handle which can be
         * either stored in tlsf or QPS page maps.  */
        sz = (rand() & ((QPS_M_ALLOC_MAX << 1) - 1));
    } else if (step == QPS_ALLOC) {
        sz = 24U + ((int)sqrt(1 + rand())) % 4096;
    } else if (step == QPS_REALLOC) {
        sz = old_size + ((int)sqrt(1 + rand())) % 4096;
    } else {
        assert(0);
    }

    return sz;
}

static qps_handle_t get_random_handle(qps_obj_type_t type, int *pos)
{
    /* Retrieve the handle vector associated with type and return a valid
     * handle if available. */
    qv_t(i32) *v = &_G.vec_type_h.tab[type];
    qv_t(i32) *v_free = &_G.free_list.tab[type];
    qps_handle_t h = QPS_HANDLE_NULL;
    int p = -1;

    if (v->len == v_free->len) {
        goto end_fct;
    }

    p = rand() % v->len;

    while (v->tab[p] < 0) {
        if (++p == v->len) {
            p = 0;
        }
    }
    h = v->tab[p];

end_fct:
    if (pos) {
        *pos = p;
    }
    return h;
}

static int find_pos_from_handle(qps_obj_type_t type, qps_handle_t h)
{
    qv_t(i32) *v; /* Vector pointing on the existing handles for the current
                     type of QPS objects. */
    int pos = -1;

    if (unlikely(h >= _G.qps->handles_max)) {
        /* Ensure handle id is below qps_t::handles_max, so we don't have to
         * manage the case in qv_find() where -1 can actually be stored in
         * vector. */
        return pos;
    }

    assert(type < QPS_MAX_TYPES_OBJECTS);
    v = &_G.vec_type_h.tab[type];
    pos = qv_find(i32)(v, h, false, ^int (int32_t const *i1,
                                          int32_t const *i2) {
        return CMP((*i1), (*i2));
    });

    return pos;
}

static void register_handle_for_type(qps_obj_type_t type, qps_handle_t h)
{
    qv_t(i32) *v = &_G.vec_type_h.tab[type];
    qv_t(i32) *v_free = &_G.free_list.tab[type];

    if (v_free->len == 0) {
        qv_append(v, h);

        if (type != QPS_GENERIC_TYPE) {
            /* For QPS objects, only append QPS object vector if there is no
             * free available space AND the type requested is not a generic
             * one (i.e. for Qhat, QPS bitmaps). */
            qv_growlen0(&_G.vec_loaded_obj.tab[type], 1);
        }
    } else {
        int pos = *tab_last(v_free);

        qv_shrink(v_free, 1);
        v->tab[pos] = h;
    }
}

static void unregister_handle_for_type(qps_obj_type_t type, int pos)
{
    qv_t(i32) *v = &_G.vec_type_h.tab[type];
    qv_t(i32) *v_free = &_G.free_list.tab[type];

    v->tab[pos] = -1;
    qv_append(v_free, pos);
}

/* }}} */
/* {{{ QPS generic operations */

static void qalloc(qpsstress_instr_t *instr)
{
    qps_handle_t h = QPS_HANDLE_NULL;
    void *ptr;
    size_t g;

    log_step_may_fail("step=%d (%s): allocating handle, size=%zu", QPS_ALLOC,
                      __FUNCTION__, instr->expected_sz);
    ptr = qps_alloc(_G.qps, &h, instr->expected_sz);
    assert((h != QPS_HANDLE_NULL) && ptr);
    g = qps_sizeof(_G.qps, ptr);
    set_handle_data(ptr, h, g);
    log_after_step("step=%d (%s): h=%d, size=%zu, got=%zu", QPS_ALLOC,
                   __FUNCTION__, h, instr->expected_sz, g);
    register_handle_for_type(QPS_GENERIC_TYPE, h);
}

static void qrealloc(qpsstress_instr_t *instr)
{
    void *p = qps_handle_deref(_G.qps, instr->h);
    size_t o = qps_sizeof(_G.qps, p);
    size_t g;

    if (_G.opt_old_alloc_strategy && o >= 4096) {
        return;
    }
    log_step_may_fail("step=%d (%s): reallocating h=%d, new_size=%zu",
                      QPS_REALLOC, __FUNCTION__, instr->h,
                      instr->expected_sz);
    p = qps_realloc(_G.qps, instr->h, instr->expected_sz);
    assert(p);
    g = qps_sizeof(_G.qps, p);
    assert(g >= instr->expected_sz);
    check_blk_then_set_handle_data(instr->h);
    log_after_step("step=%d (%s): h=%d, size=%zu, old=%zu, got=%zu",
                   QPS_REALLOC, __FUNCTION__, instr->h, instr->expected_sz, o,
                   g);
}

static void qwderef(qpsstress_instr_t *instr)
{
    log_before_step("step=%d (%s): h=%d", QPS_WDEREF, __FUNCTION__, instr->h);
    qps_handle_w_deref(_G.qps, instr->h);

    /* Moving handle from RO tlsf map into RW tlsf map can actually change the
     * size of the object for a bigger one. We need to check the data move
     * prior to set additional pattern for this extra allocation block. */
    check_blk_then_set_handle_data(instr->h);
}

static void qdealloc(qpsstress_instr_t *instr)
{
    int pos = find_pos_from_handle(QPS_GENERIC_TYPE, instr->h);

    assert(pos != -1);
    log_before_step("step=%d (%s): h=%d", QPS_DEALLOC, __FUNCTION__,
                    instr->h);
    check_blk_header_and_data(instr->h);
    qps_free(_G.qps, instr->h);
    unregister_handle_for_type(QPS_GENERIC_TYPE, pos);
}

static void qsnapshot(qpsstress_instr_t *instr)
{
    tab_for_each_pos(pos, &_G.vec_type_h) {
        qv_splice(&_G.vec_type_snap_h.tab[pos], 0,
                  _G.vec_type_snap_h.tab[pos].len,
                  _G.vec_type_h.tab[pos].tab, _G.vec_type_h.tab[pos].len);

        qv_splice(&_G.snap_free_list.tab[pos], 0,
                  _G.snap_free_list.tab[pos].len,
                  _G.free_list.tab[pos].tab, _G.free_list.tab[pos].len);
    }

    log_before_step("step=%d (%s): >>>>>>>>>>>>>>>", QPS_SNAPSHOT,
                    __FUNCTION__);
    qps_snapshot(_G.qps, NULL, 0, ^(uint32_t gen) {
    });
}

static void qsnapshot_wait(qpsstress_instr_t *instr)
{
    log_before_step("step=%d (%s): <<<<<<<<<<<<<<<", QPS_SNAPSHOT_WAIT,
                    __FUNCTION__);
    qps_snapshot_wait(_G.qps);
    qps_gc_run(_G.qps);
    /* Previous call can actually make some addresses unavailable for QPS
     * object management, deallocate memory so pointers are redirected to
     * the correct location in QPS. */
    dealloc_qpsstress_objs();
}

static void qreopen(qpsstress_instr_t *instr)
{
    tab_for_each_pos(pos, &_G.vec_type_h) {
        qv_splice(&_G.vec_type_h.tab[pos], 0, _G.vec_type_h.tab[pos].len,
                  _G.vec_type_snap_h.tab[pos].tab,
                  _G.vec_type_snap_h.tab[pos].len);

        qv_splice(&_G.free_list.tab[pos], 0, _G.free_list.tab[pos].len,
                  _G.snap_free_list.tab[pos].tab,
                  _G.snap_free_list.tab[pos].len);
    }

    dealloc_qpsstress_objs();

    log_before_step("step=%d (%s): =========================================",
                    QPS_REOPEN, __FUNCTION__);
    qps_close(&_G.qps);
    _G.qps = qps_open(_G.path, "stress", NULL);
    qps_gc_run(_G.qps);
}

/* }}} */
/* {{{ QPS operations on QPS objects like Qhat, Qbitmap */

static qps_obj_type_t get_random_qps_object_type(void)
{
    qps_obj_type_t type = QPS_GENERIC_TYPE;
    while (type == QPS_GENERIC_TYPE) {
        type = rand() % QPS_MAX_TYPES_OBJECTS;
    }
    return type;
}

static uint32_t get_random_qhat_value_len(void)
{
    /* Return a power of 2^N with N in [0; 4] */
    return 1 << (rand() % 5);
}

static bool get_random_bool(void)
{
    return rand() & 0x1 ? true : false;
}

static uint32_t get_random_qps_obj_key(void)
{
    return (uint32_t)rand();
}

static void restrict_change_key_value(uint32_t min_key_allowed, uint32_t *key)
{
    if (!min_key_allowed || (*key >= min_key_allowed)) {
        /* No restriction applies. */
        return;
    }

    /* Find a way to move forward on key value. */
    if (min_key_allowed < UINT32_MAX - *key) {
        *key += min_key_allowed;
    } else {
        /* Stay on the key or move by one to avoid overflow. */
        *key = min_key_allowed == UINT32_MAX ? min_key_allowed :
                                               min_key_allowed + (*key & 1);
    }
}

static void get_random_qps_mul_op(qpsstress_obj_mul_op_t *mul_op)
{
    int r = rand();

    mul_op->key = get_random_qps_obj_key();
    mul_op->nbr_iter = (r >> 8) & 0xFFFF;
    mul_op->gap_keys = r & 0xFF;
    mul_op->gap_keys = mul_op->gap_keys ?: 1;
}

static uint32_t get_random_mv_count_for_qhat_en(void)
{
    /* Arbitrary value (and not too big), so we can move in qhat using the
     * enumerator without spending too much time (< 1024 iterations). */
    return rand() & 0x3ff;
}

static void
alloc_slot_for_qps_obj(qps_obj_type_t type, qps_obj_t *obj)
{
    switch (type) {
    case QPS_QHAT:
        obj->hat = p_new(qhat_t, 1);
        /* Don't allocate yet the enumerator, as we might not use it and we
         * need also to know when it is created = valid. */
        break;
    case QPS_QBITMAP:
        obj->qbitmap = p_new(qps_bitmap_t, 1);
        break;

    default:
        assert(0);
        break;
    }
}

static int load_obj_from_instr(qpsstress_instr_t *instr, qps_obj_t **obj)
{
    qv_t(qps_obj_vec) *v_obj;
    qps_obj_type_t type = instr->obj_instr.type;

    if (instr->obj_instr.pos < 0) {
        instr->obj_instr.pos = find_pos_from_handle(type, instr->h);
        THROW_ERR_IF(instr->obj_instr.pos < 0);
    }

    /* Get the vector associated with this object and find the dedicated
     * slot */
    v_obj = &_G.vec_loaded_obj.tab[type];

    *obj = &v_obj->tab[instr->obj_instr.pos];
    if (likely((*obj)->obj_ptr)) {
        /* Already allocated and loaded from QPS */
        return 0;
    }

    alloc_slot_for_qps_obj(type, *obj);
    switch (type) {
    case QPS_QHAT:
        qhat_init((*obj)->hat, _G.qps, instr->h);
        break;
    case QPS_QBITMAP:
        qps_bitmap_init((*obj)->qbitmap, _G.qps, instr->h);
        break;

    default:
        assert(0);
        break;
    }
    return 0;
}

#define QHAT_SLOT_PATTERN(h, key) ((h ^ key) | 1)

static void set_qhat_slot(qhat_node_memory_t qhat_slot, qps_handle_t h,
                          uint32_t key, uint32_t qhat_value_len)
{
    uint32_t val = QHAT_SLOT_PATTERN(h, key);
    uint64_t val_64 = (((uint64_t)val << 32) | val);

    /* Depends on qhat::root::value_len so an explicit set must be applied
     * with the right memory len. */
    switch (bsr32(qhat_value_len)) {
    case 0:
        *(qhat_slot.u8) = val & 0xFF;
        break;

    case 1:
        *(qhat_slot.u16) = val & 0xFFFF;
        break;

    case 2:
        *(qhat_slot.u32) = val;
        break;

    case 4:
        *(qhat_slot.u64 + 1) = val_64;
        /* FALLTHROUGH */
    case 3:
        *(qhat_slot.u64) = val_64;
        break;

    default :
        assert(0);
        break;
    }
}

static void set_qhat_slot_from_key(qhat_t *hat, qps_handle_t h, uint32_t key)
{
    qhat_node_memory_t qhat_slot = { .raw = qhat_set(hat, key) };

    set_qhat_slot(qhat_slot, h, key, hat->root->value_len);
}

static void
check_qhat_slot(qhat_node_const_memory_t qhat_slot, qps_handle_t h,
                uint32_t key, uint32_t qhat_value_len)
{
    uint32_t val = QHAT_SLOT_PATTERN(h, key);
    uint64_t val_64 = (((uint64_t)val << 32) | val);

    if (!qhat_slot.raw) {
        /* Key not available: nothing to check. */
        return;
    }

    switch (bsr32(qhat_value_len)) {
    case 0:
        assert(*qhat_slot.u8 == (val & 0xFF) || *qhat_slot.u8 == 0);
        break;

    case 1:
        assert(*qhat_slot.u16 == (val & 0xFFFF) || *qhat_slot.u16 == 0);
        break;

    case 2:
        assert(*qhat_slot.u32 == val || *qhat_slot.u32 == 0);
        break;

    case 4:
        assert(*(qhat_slot.u64 + 1) == val_64 || *(qhat_slot.u64 + 1) == 0);
        /* FALLTHROUGH */

    case 3:
        assert(*qhat_slot.u64 == val_64 || *qhat_slot.u64 == 0);
        break;

    default :
        assert(0);
    }
}

#undef QHAT_SLOT_PATTERN

static void
check_qhat_slot_from_key(qhat_t *hat, qps_handle_t h, uint32_t key)
{
    qhat_node_const_memory_t qhat_slot = { .raw = qhat_get(hat, key) };

    check_qhat_slot(qhat_slot, h, key, hat->root->value_len);
}

static void check_qhat_slot_from_path(qhat_path_t *path, qps_handle_t h)
{
    qhat_node_const_memory_t qhat_slot = { .raw = qhat_get_path(path) };

    check_qhat_slot(qhat_slot, h, path->key, path->hat->root->value_len);
}

static void qobj_create(qpsstress_instr_t *instr)
{
    qps_handle_t h = QPS_HANDLE_NULL;
    qpsstress_obj_create_t *create_qobj = &instr->obj_instr.create;

    if (max_of_qps_obj_reached(instr->obj_instr.type) < 0) {
        return;
    }

    log_step_may_fail("step=%d (%s): allocating object for type=%d,"
                      "value_len=%u, is_nullable=%d", QPS_OBJ_CREATE,
                      __FUNCTION__, instr->obj_instr.type,
                      create_qobj->val_len, create_qobj->is_nullable);

    switch (instr->obj_instr.type) {
    case QPS_QHAT: {
        h = qhat_create(_G.qps, create_qobj->val_len,
                        create_qobj->is_nullable);
    } break;

    case QPS_QBITMAP:
        h = qps_bitmap_create(_G.qps, create_qobj->is_nullable);
        break;

    default:
        assert(0);
        break;
    }

    /* Object created in QPS but not yet loaded/allocated in this tool (until
     * a call to write or delete it is made). We just create a new slot for
     * pointer object here if slot is not already available (set to NULL). */
    assert(h != QPS_HANDLE_NULL);
    register_handle_for_type(instr->obj_instr.type, h);

    log_after_step("step=%d (%s): h=%u, type=%d, value_len=%u, "
                   "is_nullable=%d", QPS_OBJ_CREATE, __FUNCTION__, h,
                   instr->obj_instr.type, create_qobj->val_len,
                   create_qobj->is_nullable);
}

static inline void qhat_set_next_safe_en_access(qps_obj_t *hat_obj, bool safe)
{
    hat_obj->ctx.safe_en_needed = safe;
}

static inline void qhat_update_next_safe_en_access(qps_obj_t *hat_obj)
{
    qhat_enumerator_t *en;
    bool next_safe;

    if (!_G.opt_protect_en_access || !hat_obj->ctx.hat_en ||
        hat_obj->ctx.safe_en_needed)
    {
        return;
    }
    en = hat_obj->ctx.hat_en;

    /* We need to check the fully sync here from the Qhat path, as it is
     * requested by Qhat even for a simple modification (without changing Qhat
     * structure). */
    if (en->is_nullable) {
        next_safe = !(qps_bitmap_enumerator_is_sync(&en->bitmap) &&
                    qhat_path_is_fully_sync(&en->nu_trie.path));
    } else {
        next_safe = !qhat_path_is_fully_sync(&en->nn_trie.path);
    }
    qhat_set_next_safe_en_access(hat_obj, next_safe);
}

static inline bool
qhat_compute_en_safe_access(qps_obj_t *hat_obj, bool from_instr)
{
    if (_G.opt_protect_en_access) {
        return hat_obj->ctx.safe_en_needed || from_instr;
    }
    /* If the option above is not requested, the random/replay can resync
     * partially the enumerator and believe the access is ok, even if a
     * failure may occur (path is synchronized but the enumerator is not until
     * a full move with safe = true). */
    return !qhat_enumerator_is_sync(hat_obj->ctx.hat_en) || from_instr;
}

static inline void qobj_add_key(qps_obj_type_t type, qps_handle_t h,
                                uint32_t key, qps_obj_t *obj)
{
    switch (type) {
    case QPS_QHAT:
        set_qhat_slot_from_key(obj->hat, h, key);
        break;

    case QPS_QBITMAP:
        /* Give predictable behavior based on handle XOR key to set the
         * bit */
        if ((h ^ key) & 0x1) {
            qps_bitmap_set(obj->qbitmap, key);
        } else {
            qps_bitmap_reset(obj->qbitmap, key);
        }
        break;

    default:
        assert(0);
        break;
    }
}

static inline void qobj_get_key(qps_obj_type_t type, qps_handle_t h,
                                uint32_t key, qps_obj_t *obj)
{
    switch (type) {
    case QPS_QHAT:
        check_qhat_slot_from_key(obj->hat, h, key);
        break;

    case QPS_QBITMAP:
        qps_bitmap_get(obj->qbitmap, key);
        break;

    default:
        assert(0);
        break;
    }
}

static inline void qobj_rm_key(qps_obj_type_t type, qps_handle_t h,
                               uint32_t key, qps_obj_t *obj)
{
    switch (type) {
    case QPS_QHAT:
        qhat_remove(obj->hat, key, NULL);
        break;

    case QPS_QBITMAP:
        qps_bitmap_remove(obj->qbitmap, key);
        break;

    default:
        assert(0);
        break;
    }
}

static void qobj_apply_mul_op(qpsstress_step_t step, qpsstress_instr_t *instr)
{
    qps_obj_t *obj;
    qpsstress_obj_mul_op_t *mul_op = &instr->obj_instr.mul_op;

    if (load_obj_from_instr(instr, &obj) < 0) {
        return;
    }

    if (step == QPS_OBJ_SET || step == QPS_OBJ_GET ||
        step == QPS_OBJ_RM_ENTRY)
    {
        instr->obj_instr.mul_op.nbr_iter = 1;
        instr->obj_instr.mul_op.gap_keys = 1;
    }

    log_before_step("step=%d (%s): h=%u, type=%d, start_key=%u, gap=%u, "
                    "nbr_iter=%u", step, g_list_steps[step].name, instr->h,
                    instr->obj_instr.type, mul_op->key, mul_op->gap_keys,
                    mul_op->nbr_iter);

    for (uint32_t i = 0; i < mul_op->nbr_iter; i++) {
        uint32_t key = mul_op->key + (i * mul_op->gap_keys);

        switch (step) {
        case QPS_OBJ_SET:
        case QPS_OBJ_MULTIPLE_SET:
            qobj_add_key(instr->obj_instr.type, instr->h, key, obj);
            break;
        case QPS_OBJ_GET:
        case QPS_OBJ_MULTIPLE_GET:
            qobj_get_key(instr->obj_instr.type, instr->h, key, obj);
            break;
        case QPS_OBJ_RM_ENTRY:
        case QPS_OBJ_MULTIPLE_RM_ENTRY:
            qobj_rm_key(instr->obj_instr.type, instr->h, key, obj);
            break;
        default:
            assert(0);
            break;
        }
    }

    if (instr->obj_instr.type == QPS_QHAT) {
        qhat_update_next_safe_en_access(obj);
    }
}

#define DECLARE_QOBJ_MUL_OP_FUNC(_func, _step)                               \
    static void _func(qpsstress_instr_t *instr)                              \
    {                                                                        \
        qobj_apply_mul_op(_step, instr);                                     \
    }                                                                        \

DECLARE_QOBJ_MUL_OP_FUNC(qobj_set, QPS_OBJ_SET)
DECLARE_QOBJ_MUL_OP_FUNC(qobj_mul_set, QPS_OBJ_MULTIPLE_SET)
DECLARE_QOBJ_MUL_OP_FUNC(qobj_get, QPS_OBJ_GET)
DECLARE_QOBJ_MUL_OP_FUNC(qobj_mul_get, QPS_OBJ_MULTIPLE_GET)
DECLARE_QOBJ_MUL_OP_FUNC(qobj_rm_entry, QPS_OBJ_RM_ENTRY)
DECLARE_QOBJ_MUL_OP_FUNC(qobj_mul_rm_entry, QPS_OBJ_MULTIPLE_RM_ENTRY)

#undef DECLARE_QOBJ_MUL_OP_FUNC

#define PERFORM_BASIC_QOBJ_OP(_instr, _step, _func, _do_dealloc)             \
    do {                                                                     \
        qps_obj_t *obj;                                                      \
                                                                             \
        if (load_obj_from_instr(_instr, &obj) < 0) {                         \
            return;                                                          \
        }                                                                    \
                                                                             \
        log_before_step("step=%d (%s): h=%u, type=%d", _step, __FUNCTION__,  \
                        _instr->h, _instr->obj_instr.type);                  \
                                                                             \
        switch (_instr->obj_instr.type) {                                    \
        case QPS_QHAT:                                                       \
            qhat_##_func(obj->hat);                                          \
            p_delete(&obj->ctx.hat_en);                                      \
            break;                                                           \
                                                                             \
        case QPS_QBITMAP:                                                    \
            qps_bitmap_##_func(obj->qbitmap);                                \
            break;                                                           \
                                                                             \
        default:                                                             \
            break;                                                           \
        }                                                                    \
                                                                             \
        if (_do_dealloc) {                                                   \
            dealloc_slot_for_qps_obj(_instr->obj_instr.type, obj);           \
            unregister_handle_for_type(_instr->obj_instr.type,               \
                                       _instr->obj_instr.pos);               \
        }                                                                    \
                                                                             \
    } while (0)

static void qobj_clear(qpsstress_instr_t *instr)
{
    PERFORM_BASIC_QOBJ_OP(instr, QPS_OBJ_CLEAR, clear, false);
}

static void qobj_delete(qpsstress_instr_t *instr)
{
    PERFORM_BASIC_QOBJ_OP(instr, QPS_OBJ_DELETE, destroy, true);
}

static void qhat_reset_en_(qps_obj_t *hat_obj)
{
    *hat_obj->ctx.hat_en = qhat_get_enumerator(hat_obj->hat);
    qhat_set_next_safe_en_access(hat_obj, false);
}

static qps_obj_t *
retrieve_qhat_obj_with_en_from_handle(qpsstress_instr_t *instr)
{
    qps_obj_t *hat_obj;

    if (load_obj_from_instr(instr, &hat_obj) < 0) {
        return NULL;
    }

    /* Check if enumerator structure has been allocated already or not. */
    if (hat_obj->ctx.hat_en == NULL) {
        /* Allocate memory enumerator for this qhat then initialize it. */
        hat_obj->ctx.hat_en = p_new_raw(qhat_enumerator_t, 1);
        p_clear(hat_obj->ctx.hat_en, 1);

        qhat_reset_en_(hat_obj);
    }
    return hat_obj;
}

static void qhat_reset_en(qpsstress_instr_t *instr)
{
    qps_obj_t *hat_obj = retrieve_qhat_obj_with_en_from_handle(instr);

    if (hat_obj) {
        log_before_step("step=%d (%s): h=%u", QPS_HAT_RESET_ENUMERATOR,
                        __FUNCTION__, instr->h);
        qhat_reset_en_(hat_obj);
    }
}

static void qhat_mv_en(qpsstress_instr_t *instr)
{
    qps_obj_t *hat_obj = retrieve_qhat_obj_with_en_from_handle(instr);
    qhat_enumerator_t *en;
    qpsstress_obj_mv_en_t *move = &instr->obj_instr.move;

    if (!hat_obj || hat_obj->ctx.hat_en->end) {
        return;
    }
    en = hat_obj->ctx.hat_en;

    /* Override the access if necessary for a safe one, so we don't trigger
     * asserts. */
    move->safe = qhat_compute_en_safe_access(hat_obj, move->safe);

    log_before_step("step=%d (%s): h=%u, mv_count=%u, safe=%u",
                    QPS_HAT_MV_ENUMERATOR, __FUNCTION__, instr->h,
                    move->count, move->safe);

    for (uint32_t i = 0; i < move->count && !en->end; i++) {
        qhat_enumerator_next(en, move->safe);
    }

    if (!en->end) {
        qhat_path_t path = qhat_enumerator_get_path(en);

        check_qhat_slot_from_key(path.hat, instr->h, en->key);
    }
}

static void qhat_mv_en_to(qpsstress_instr_t *instr)
{
    qps_obj_t *hat_obj = retrieve_qhat_obj_with_en_from_handle(instr);
    qhat_enumerator_t *en;
    bool safe;

    if (!hat_obj || hat_obj->ctx.hat_en->end) {
        return;
    }
    en = hat_obj->ctx.hat_en;
    safe = qhat_compute_en_safe_access(hat_obj, false);

    /* Restriction on key which should be bigger or with the same value. */
    restrict_change_key_value(en->key, &instr->obj_instr.key);

    log_before_step("step=%d (%s): h=%u, key=%u (safe=%d)",
                    QPS_HAT_MV_ENUMERATOR_TO, __FUNCTION__, instr->h,
                    instr->obj_instr.key, safe);

    qhat_enumerator_go_to(en, instr->obj_instr.key, safe);
    if (!en->end) {
        qhat_path_t path = qhat_enumerator_get_path(en);

        assert(en->key >= instr->obj_instr.key);
        check_qhat_slot_from_key(path.hat, instr->h, en->key);
    }
}

static void qhat_check_en(qpsstress_instr_t *instr)
{
    qps_obj_t *hat_obj = retrieve_qhat_obj_with_en_from_handle(instr);
    qpsstress_obj_check_en_t *check = &instr->obj_instr.check;
    qhat_enumerator_t *en;

    if (!hat_obj || hat_obj->ctx.hat_en->end) {
        return;
    }
    en = hat_obj->ctx.hat_en;
    check->safe = qhat_compute_en_safe_access(hat_obj, check->safe);

    log_before_step("step=%d (%s): h=%u, en_path=%d, safe=%d",
                    QPS_HAT_CHECK_ENUMERATOR, __FUNCTION__, instr->h,
                    check->en_path, check->safe);

    if (instr->obj_instr.check.en_path && !hat_obj->ctx.safe_en_needed) {
        qhat_path_t path = qhat_enumerator_get_path(en);

        check_qhat_slot_from_path(&path, instr->h);
    } else if (instr->obj_instr.check.safe) {
        qhat_enumerator_get_value_safe(en);
    } else {
        qhat_enumerator_get_value_unsafe(en);
    }
}

static void qhat_set_current_en(qpsstress_instr_t *instr)
{
    qps_obj_t *hat_obj = retrieve_qhat_obj_with_en_from_handle(instr);
    qhat_enumerator_t *en;
    qhat_tree_enumerator_t *trie;

    if (!hat_obj || hat_obj->ctx.hat_en->end) {
        return;
    }
    en = hat_obj->ctx.hat_en;
    trie = en->is_nullable ? &en->nu_trie : &en->nn_trie;

    log_before_step("step=%d (%s): h=%u (safe=%d)", QPS_HAT_SET_ENUMERATOR,
                    __FUNCTION__, instr->h,
                    qhat_compute_en_safe_access(hat_obj, false));
    set_qhat_slot_from_key(trie->path.hat, instr->h, en->key);
    qhat_update_next_safe_en_access(hat_obj);
}

static void qhat_req_compute_counts(qpsstress_instr_t *instr)
{
    qps_obj_t *hat_obj;

    if (load_obj_from_instr(instr, &hat_obj) < 0) {
        return;
    }

    log_before_step("step=%d (%s): h=%u, enable=%d", QPS_HAT_COMPUTE_COUNTS,
                    __FUNCTION__, instr->h, instr->obj_instr.do_stats);
    qhat_compute_counts(hat_obj->hat, instr->obj_instr.do_stats);
}

static void qhat_req_compute_memory(qpsstress_instr_t *instr)
{
    qps_obj_t *hat_obj;

    if (load_obj_from_instr(instr, &hat_obj) < 0) {
        return;
    }

    log_before_step("step=%d (%s): h=%u, memory_overhead=%d",
                    QPS_HAT_COMPUTE_MEMORY, __FUNCTION__, instr->h,
                    instr->obj_instr.compute_memory_overhead);

    if (instr->obj_instr.compute_memory_overhead) {
        qhat_compute_memory_overhead(hat_obj->hat);
    } else {
        qhat_compute_memory(hat_obj->hat);
    }
}

static void qhat_req_fix0(qpsstress_instr_t *instr)
{
    qps_obj_t *hat_obj;

    if (load_obj_from_instr(instr, &hat_obj) < 0) {
        return;
    }

    log_before_step("step=%d (%s): h=%u", QPS_HAT_FIX_STORED0, __FUNCTION__,
                    instr->h);
    qhat_fix_stored0(hat_obj->hat);
}

static void qbitmap_req_compute_stats(qpsstress_instr_t *instr)
{
    qps_obj_t *bitmap_obj;
    size_t memory;
    uint32_t entries, slots;

    if (load_obj_from_instr(instr, &bitmap_obj) < 0) {
        return;
    }

    log_before_step("step=%d (%s): h=%u", QPS_BITMAP_COMPUTE_STATS,
                    __FUNCTION__, instr->h);
    qps_bitmap_compute_stats(bitmap_obj->qbitmap, &memory, &entries, &slots);
}

/* }}} */
/* {{{ QPS replay operations */

static void init_replay(const char *replay_file)
{
    ctype_desc_build(&_G.replay.sep, ": ,=");
    if (lstr_init_from_file(&_G.replay.file_content, replay_file, PROT_READ,
                            MAP_SHARED) < 0)
    {
        e_fatal("unable to open replay file \"%s\"", replay_file);
    }
    _G.replay.ps = ps_initlstr(&_G.replay.file_content);
}

static void end_replay(void)
{
    lstr_wipe(&_G.replay.file_content);
}

#define VALUE_REPLAY_1 (6)
#define VALUE_REPLAY_2 (8)
#define VALUE_REPLAY_3 (10)
#define VALUE_REPLAY_4 (12)
#define VALUE_REPLAY_5 (14)

static int extract_handle_replay(qv_t(lstr) *values)
{
    THROW_ERR_IF(lstr_to_uint(values->tab[VALUE_REPLAY_1],
                              &_G.replay.last_step.instr.h) < 0);
    return 0;
}

static int extract_qobj_type(qv_t(lstr) *values)
{
    uint32_t value;

    THROW_ERR_IF(lstr_to_uint(values->tab[VALUE_REPLAY_2], &value) < 0);
    _G.replay.last_step.instr.obj_instr.type = (qps_obj_type_t)value;
    return 0;
}

static int extract_qobj_key(qv_t(lstr) *values)
{
    THROW_ERR_IF(lstr_to_uint(values->tab[VALUE_REPLAY_3],
                              &_G.replay.last_step.instr.obj_instr.key) < 0);
    return 0;
}

static int extract_qobj_handle_and_type_and_key(qv_t(lstr) *values)
{
    THROW_ERR_IF(extract_handle_replay(values));
    THROW_ERR_IF(extract_qobj_type(values));
    THROW_ERR_IF(extract_qobj_key(values));

    return 0;
}

static qpsstress_replay_t *read_and_set_replay_step(pstream_t *line)
{
    t_scope;
    qv_t(lstr) values;
    uint32_t step = UINT32_MAX;
    uint32_t u32_val;

    t_qv_init(&values, 1);
    ps_split(*line, &_G.replay.sep, PS_SPLIT_SKIP_EMPTY, &values);

    /* Check for info lines from a qpsstress run, discard all others */
    THROW_NULL_IF(values.len < 4 || !lstr_equal(values.tab[1], LSTR("info")));

    /* Retrieve step kind */
    lstr_to_uint(values.tab[3], &step);
    THROW_NULL_IF(step >= QPS_MAX_CASES);
    _G.replay.last_step.step = (qpsstress_step_t) step;

    /* Initialize position of qps object to not found */
    _G.replay.last_step.instr.obj_instr.pos = -1;

    /* Collect data base on step kind */
    switch (step) {
    case QPS_ALLOC:
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_2], &u32_val) < 0);
        _G.replay.last_step.instr.expected_sz = u32_val;
        break;
    case QPS_REALLOC:
        THROW_NULL_IF(extract_handle_replay(&values));
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_2], &u32_val) < 0);
        _G.replay.last_step.instr.expected_sz = u32_val;
        break;
    case QPS_WDEREF:
    case QPS_DEALLOC:
        THROW_NULL_IF(extract_handle_replay(&values));
        break;
    case QPS_SNAPSHOT:
    case QPS_SNAPSHOT_WAIT:
    case QPS_REOPEN:
        break;
    case QPS_OBJ_CREATE:
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_2], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.type = u32_val;
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_3], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.create.val_len = u32_val;
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_4], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.create.is_nullable = u32_val;
        break;
    case QPS_OBJ_SET:
    case QPS_OBJ_GET:
    case QPS_OBJ_RM_ENTRY:
        THROW_NULL_IF(extract_qobj_handle_and_type_and_key(&values));
        break;
    case QPS_OBJ_MULTIPLE_SET:
    case QPS_OBJ_MULTIPLE_GET:
    case QPS_OBJ_MULTIPLE_RM_ENTRY:
        THROW_NULL_IF(extract_qobj_handle_and_type_and_key(&values));
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_4], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.mul_op.gap_keys = u32_val;
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_5], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.mul_op.nbr_iter = u32_val;
        break;
    case QPS_OBJ_CLEAR:
    case QPS_OBJ_DELETE:
        THROW_NULL_IF(extract_handle_replay(&values));
        THROW_NULL_IF(extract_qobj_type(&values));
        break;
    case QPS_HAT_RESET_ENUMERATOR:
    case QPS_HAT_SET_ENUMERATOR:
    case QPS_HAT_FIX_STORED0:
        _G.replay.last_step.instr.obj_instr.type = QPS_QHAT;
        THROW_NULL_IF(extract_handle_replay(&values));
        break;
    case QPS_HAT_CHECK_ENUMERATOR:
        _G.replay.last_step.instr.obj_instr.type = QPS_QHAT;
        THROW_NULL_IF(extract_handle_replay(&values));
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_2], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.check.en_path = (bool) u32_val;
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_3], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.check.safe = (bool) u32_val;
        break;
    case QPS_HAT_MV_ENUMERATOR:
        _G.replay.last_step.instr.obj_instr.type = QPS_QHAT;
        THROW_NULL_IF(extract_handle_replay(&values));
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_2], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.move.count = (uint16_t) u32_val;
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_3], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.move.safe = (bool) u32_val;
        break;
    case QPS_HAT_MV_ENUMERATOR_TO:
        _G.replay.last_step.instr.obj_instr.type = QPS_QHAT;
        THROW_NULL_IF(extract_handle_replay(&values));
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_2], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.key = u32_val;
        break;
    case QPS_HAT_COMPUTE_COUNTS:
        _G.replay.last_step.instr.obj_instr.type = QPS_QHAT;
        THROW_NULL_IF(extract_handle_replay(&values));
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_2], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.do_stats = u32_val;
        break;
    case QPS_HAT_COMPUTE_MEMORY:
        _G.replay.last_step.instr.obj_instr.type = QPS_QHAT;
        THROW_NULL_IF(extract_handle_replay(&values));
        THROW_NULL_IF(lstr_to_uint(values.tab[VALUE_REPLAY_2], &u32_val) < 0);
        _G.replay.last_step.instr.obj_instr.compute_memory_overhead = u32_val;
        break;
    case QPS_BITMAP_COMPUTE_STATS:
        _G.replay.last_step.instr.obj_instr.type = QPS_QBITMAP;
        THROW_NULL_IF(extract_handle_replay(&values));
        break;
    default:
        assert(0);
        break;
    }

    return &_G.replay.last_step;
}

#undef VALUE_REPLAY_1
#undef VALUE_REPLAY_2
#undef VALUE_REPLAY_3
#undef VALUE_REPLAY_4
#undef VALUE_REPLAY_5

static qpsstress_replay_t *get_replay_step(void)
{
    qpsstress_replay_t *res = NULL;

    if (_G.replay.file_content.len) {
        static const char cdesc_tok[] = { '\r', '\n', '\0' };
        ctype_desc_t cdesc;
        pstream_t line;

        ctype_desc_build(&cdesc, cdesc_tok);
        while (!res) {
            if (ps_done(&_G.replay.ps)) {
                e_error(">>>>>>>>>>>>>>>  end of replay  <<<<<<<<<<<<<<<<");
                e_error(">>>>>>>>>>>>>>>  end of replay  <<<<<<<<<<<<<<<<");
                e_error(">>>>>>>>>>>>>>>  end of replay  <<<<<<<<<<<<<<<<");
                e_error(">>>>>>>>>>>>>>>  end of replay  <<<<<<<<<<<<<<<<");
                end_replay();
                break;
            }
            line = ps_get_cspan(&_G.replay.ps, &cdesc);
            res = read_and_set_replay_step(&line);
            ps_skip_span(&_G.replay.ps, &cdesc);
        }
    }
    return res;
}

/* }}} */
/* {{{ qpsstress step computation */

static uint32_t get_random_step(uint32_t *proba)
{
    uint32_t s = 0;

    proba[QPS_WDEREF] = 65536;
    if (_G.free_list.tab[QPS_GENERIC_TYPE].len ==
        _G.vec_type_h.tab[QPS_GENERIC_TYPE].len)
    {
        proba[QPS_ALLOC] = 16384;
        proba[QPS_REALLOC] = proba[QPS_DEALLOC] = 0;
        proba[QPS_WDEREF] = 0;
    } else if (_G.vec_type_h.tab[QPS_GENERIC_TYPE].len -
               _G.free_list.tab[QPS_GENERIC_TYPE].len < 1000000)
    {
        proba[QPS_ALLOC] = 16384;
        proba[QPS_DEALLOC] = 8192;
        proba[QPS_REALLOC] = 1024;
    } else {
        proba[QPS_ALLOC] = 8192;
        proba[QPS_DEALLOC] = 4096;
        proba[QPS_REALLOC] = 1024;
    }

    for (int i = 0; i < QPS_MAX_CASES; i++) {
        s += proba[i];
    }

    s = rand() % s;
    for (int i = 0; i < QPS_MAX_CASES; i++) {
        if (proba[i] > s) {
            s = i;
            break;
        }
        s -= proba[i];
    }
    assert(s < QPS_MAX_CASES);

    return s;
}

static int
create_random_instr(qpsstress_step_t step, qpsstress_instr_t *instr)
{
    switch (step)
    {
    case QPS_ALLOC:
        instr->expected_sz = request_memory_size(QPS_ALLOC, 0);
        break;
    case QPS_REALLOC: {
        void *p;
        size_t o;

        instr->h = get_random_handle(QPS_GENERIC_TYPE, NULL);
        p = qps_handle_deref(_G.qps, instr->h);
        o = qps_sizeof(_G.qps, p);
        instr->expected_sz = request_memory_size(QPS_REALLOC, o);
    } break;
    case QPS_DEALLOC:
    case QPS_WDEREF:
        instr->h = get_random_handle(QPS_GENERIC_TYPE, NULL);
        break;
    case QPS_SNAPSHOT:
    case QPS_SNAPSHOT_WAIT:
    case QPS_REOPEN:
        /* Nothing to do. */
        break;
    case QPS_OBJ_CREATE:
        instr->obj_instr.type = get_random_qps_object_type();
        instr->obj_instr.create.is_nullable = get_random_bool();
        instr->obj_instr.create.val_len = get_random_qhat_value_len();
        break;
    case QPS_OBJ_CLEAR:
    case QPS_OBJ_DELETE:
        instr->obj_instr.type = get_random_qps_object_type();
        instr->h = get_random_handle(instr->obj_instr.type,
                                     &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        break;
    case QPS_OBJ_SET:
    case QPS_OBJ_GET:
    case QPS_OBJ_RM_ENTRY:
        instr->obj_instr.type = get_random_qps_object_type();
        instr->h = get_random_handle(instr->obj_instr.type,
                                     &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        instr->obj_instr.key = get_random_qps_obj_key();
        break;
    case QPS_OBJ_MULTIPLE_SET:
    case QPS_OBJ_MULTIPLE_GET:
    case QPS_OBJ_MULTIPLE_RM_ENTRY:
        instr->obj_instr.type = get_random_qps_object_type();
        instr->h = get_random_handle(instr->obj_instr.type,
                                     &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        instr->obj_instr.mul_op.key = get_random_qps_obj_key();
        get_random_qps_mul_op(&instr->obj_instr.mul_op);
        break;
    case QPS_HAT_RESET_ENUMERATOR:
        instr->obj_instr.type = QPS_QHAT;
        instr->h = get_random_handle(QPS_QHAT, &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        break;
    case QPS_HAT_MV_ENUMERATOR:
        instr->obj_instr.type = QPS_QHAT;
        instr->h = get_random_handle(QPS_QHAT, &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        instr->obj_instr.key = get_random_mv_count_for_qhat_en();
        instr->obj_instr.move.safe = get_random_bool();
        break;
    case QPS_HAT_MV_ENUMERATOR_TO:
        instr->obj_instr.type = QPS_QHAT;
        instr->h = get_random_handle(QPS_QHAT, &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        instr->obj_instr.key = get_random_qps_obj_key();
        break;
    case QPS_HAT_CHECK_ENUMERATOR:
        instr->obj_instr.type = QPS_QHAT;
        instr->h = get_random_handle(QPS_QHAT, &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        instr->obj_instr.check.en_path = get_random_bool();
        instr->obj_instr.check.safe = get_random_bool();
        break;
    case QPS_HAT_SET_ENUMERATOR:
    case QPS_HAT_FIX_STORED0:
        instr->obj_instr.type = QPS_QHAT;
        instr->h = get_random_handle(QPS_QHAT, &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        break;
    case QPS_HAT_COMPUTE_COUNTS:
        instr->obj_instr.type = QPS_QHAT;
        instr->h = get_random_handle(QPS_QHAT, &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        instr->obj_instr.do_stats = get_random_bool();
        break;
    case QPS_HAT_COMPUTE_MEMORY:
        instr->obj_instr.type = QPS_QHAT;
        instr->h = get_random_handle(QPS_QHAT, &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        instr->obj_instr.compute_memory_overhead = get_random_bool();
        break;
    case QPS_BITMAP_COMPUTE_STATS:
        instr->obj_instr.type = QPS_QBITMAP;
        instr->h = get_random_handle(QPS_QBITMAP, &instr->obj_instr.pos);
        THROW_ERR_IF(instr->h == QPS_HANDLE_NULL);
        break;
    case QPS_MAX_CASES:
        assert(0);
    }
    return 0;
}

static void
update_proba_for_next_random_step(uint32_t *proba, uint32_t step)
{
    switch (step) {
    case QPS_SNAPSHOT:
        proba[QPS_SNAPSHOT] = 0;
        proba[QPS_REOPEN] = 0;
        proba[QPS_SNAPSHOT_WAIT] = 256;
        break;
    case QPS_SNAPSHOT_WAIT:
        _G.has_snapshotted = true;
        proba[QPS_SNAPSHOT] = 16;
        proba[QPS_REOPEN] = 1;
        proba[QPS_SNAPSHOT_WAIT] = 0;
        break;
    case QPS_REOPEN:
        _G.has_snapshotted = true;
        proba[QPS_SNAPSHOT] = 16;
        proba[QPS_SNAPSHOT_WAIT] = 0;
        break;
    default:
        break;
    }
}

/* }}} */

#define STEP_DESC_ENTRY(_fct) { #_fct, &_fct }

const qpsstress_step_desc_t g_list_steps[QPS_MAX_CASES] = {
    [QPS_ALLOC] = STEP_DESC_ENTRY(qalloc),
    [QPS_REALLOC] = STEP_DESC_ENTRY(qrealloc),
    [QPS_WDEREF] = STEP_DESC_ENTRY(qwderef),
    [QPS_DEALLOC] = STEP_DESC_ENTRY(qdealloc),
    [QPS_SNAPSHOT] = STEP_DESC_ENTRY(qsnapshot),
    [QPS_SNAPSHOT_WAIT] = STEP_DESC_ENTRY(qsnapshot_wait),
    [QPS_REOPEN] = STEP_DESC_ENTRY(qreopen),

    [QPS_OBJ_CREATE] = STEP_DESC_ENTRY(qobj_create),
    [QPS_OBJ_SET] = STEP_DESC_ENTRY(qobj_set),
    [QPS_OBJ_MULTIPLE_SET] = STEP_DESC_ENTRY(qobj_mul_set),
    [QPS_OBJ_GET] = STEP_DESC_ENTRY(qobj_get),
    [QPS_OBJ_MULTIPLE_GET] = STEP_DESC_ENTRY(qobj_mul_get),
    [QPS_OBJ_RM_ENTRY] = STEP_DESC_ENTRY(qobj_rm_entry),
    [QPS_OBJ_MULTIPLE_RM_ENTRY] = STEP_DESC_ENTRY(qobj_mul_rm_entry),
    [QPS_OBJ_CLEAR] = STEP_DESC_ENTRY(qobj_clear),
    [QPS_OBJ_DELETE] = STEP_DESC_ENTRY(qobj_delete),

    [QPS_HAT_RESET_ENUMERATOR] = STEP_DESC_ENTRY(qhat_reset_en),
    [QPS_HAT_MV_ENUMERATOR] = STEP_DESC_ENTRY(qhat_mv_en),
    [QPS_HAT_MV_ENUMERATOR_TO] = STEP_DESC_ENTRY(qhat_mv_en_to),
    [QPS_HAT_CHECK_ENUMERATOR] = STEP_DESC_ENTRY(qhat_check_en),
    [QPS_HAT_SET_ENUMERATOR] = STEP_DESC_ENTRY(qhat_set_current_en),
    [QPS_HAT_COMPUTE_COUNTS] = STEP_DESC_ENTRY(qhat_req_compute_counts),
    [QPS_HAT_COMPUTE_MEMORY] = STEP_DESC_ENTRY(qhat_req_compute_memory),
    [QPS_HAT_FIX_STORED0] = STEP_DESC_ENTRY(qhat_req_fix0),

    [QPS_BITMAP_COMPUTE_STATS] = STEP_DESC_ENTRY(qbitmap_req_compute_stats),
};

#undef STEP_DESC_ENTRY

static void run_step(uint32_t step, qpsstress_instr_t *instr)
{
    if (step >= QPS_MAX_CASES) {
        return;
    }

    g_list_steps[step].run_step(instr);
}

int main(int argc, char **argv)
{
    const char *arg0 = NEXTARG(argc, argv);
    uint32_t proba[QPS_MAX_CASES] = {
        [QPS_ALLOC] = 0,
        [QPS_REALLOC] = 0,
        [QPS_WDEREF] = 0,
        [QPS_DEALLOC] = 0,
        [QPS_SNAPSHOT] = 16,
        [QPS_SNAPSHOT_WAIT] = 0,
        [QPS_REOPEN] = 1,

        [QPS_OBJ_CREATE] = 512,
        [QPS_OBJ_SET] = 512,
        [QPS_OBJ_MULTIPLE_SET] = 512,
        [QPS_OBJ_GET] = 512,
        [QPS_OBJ_MULTIPLE_GET] = 512,
        [QPS_OBJ_RM_ENTRY] = 512,
        [QPS_OBJ_MULTIPLE_RM_ENTRY] = 512,
        [QPS_OBJ_CLEAR] = 16,
        [QPS_OBJ_DELETE] = 512,

        [QPS_HAT_RESET_ENUMERATOR] = 4096,
        [QPS_HAT_MV_ENUMERATOR] = 4096,
        [QPS_HAT_MV_ENUMERATOR_TO] = 4096,
        [QPS_HAT_CHECK_ENUMERATOR] = 4096,
        [QPS_HAT_SET_ENUMERATOR] = 4096,
        [QPS_HAT_COMPUTE_COUNTS] = 64,
        [QPS_HAT_FIX_STORED0] = 8,

        [QPS_BITMAP_COMPUTE_STATS] = 64,
    };

    MODULE_REQUIRE(qps);

    argc = parseopt(argc, argv, qpsstress_popt_g, 0);
    if (argc < 1 || _G.opt_help) {
        makeusage(_G.opt_help ? EX_OK: EX_USAGE, arg0, qpsstress_usage_g,
                  NULL, qpsstress_popt_g);
    }

    _G.path = NEXTARG(argc, argv);

    qps_unlink(_G.path);
    _G.qps = qps_create(_G.path, "stress", 0755, NULL, 0);
    if (!_G.qps) {
        e_fatal("unable to open qps");
    }

    if (argc) {
        init_replay(NEXTARG(argc, argv));
    }

    init_qpsstress_vectors();
    for (;;) {
        qpsstress_replay_t *replay = get_replay_step();
        uint32_t s;

        if (replay) {
            s = replay->step;
            run_step(replay->step, &replay->instr);
        } else if (_G.replay.opt_end_app) {
            break;
        } else {
            qpsstress_instr_t instr;

            s = get_random_step(proba);
            if (create_random_instr(s, &instr) < 0) {
                continue;
            }
            run_step(s, &instr);
        }
        /* Update probabilities even in replay mode, so we are not
         * unsynchronized when we leave it! */
        update_proba_for_next_random_step(proba, s);
        check_qps();
    }

    qps_close(&_G.qps);
    end_replay();
    destroy_qpsstress_vectors();

    MODULE_RELEASE(qps);
    return 0;
}
